<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="本文使用的CompletableFuture版本为java 8（java 11的CompletableFuture新增了一些方法）。 简介Java 8 新增加了 CompletableFuture 类，该类提供了非常强大的 Future 扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8 CompletableFuture">
<meta property="og:url" content="https://blog.zhaolq.com/article/2022/02/Java8%20CompletableFuture/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="本文使用的CompletableFuture版本为java 8（java 11的CompletableFuture新增了一些方法）。 简介Java 8 新增加了 CompletableFuture 类，该类提供了非常强大的 Future 扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-19T00:00:01.000Z">
<meta property="article:modified_time" content="2022-02-19T00:00:01.000Z">
<meta property="article:author" content="zhaolq">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.zhaolq.com/article/2022/02/Java8%20CompletableFuture/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2022/02/Java8%20CompletableFuture/","path":"article/2022/02/Java8 CompletableFuture/","title":"Java8 CompletableFuture"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java8 CompletableFuture | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">贪婪，找不到比这更好的词了，是件好事。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Future"><span class="nav-number">2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CompletionStage"><span class="nav-number">3.</span> <span class="nav-text">CompletionStage</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E5%8C%BA%E5%88%86"><span class="nav-number">3.1.</span> <span class="nav-text">阶段区分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thenXXX"><span class="nav-number">3.2.</span> <span class="nav-text">thenXXX()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runXXX"><span class="nav-number">3.3.</span> <span class="nav-text">runXXX()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XXXEither"><span class="nav-number">3.4.</span> <span class="nav-text">XXXEither()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exceptionally"><span class="nav-number">3.5.</span> <span class="nav-text">exceptionally()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#whenComplete"><span class="nav-number">3.6.</span> <span class="nav-text">whenComplete()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handle"><span class="nav-number">3.7.</span> <span class="nav-text">handle()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toCompletableFuture"><span class="nav-number">3.8.</span> <span class="nav-text">toCompletableFuture()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">4.</span> <span class="nav-text">CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">4.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E5%AE%8C%E6%88%90"><span class="nav-number">4.3.</span> <span class="nav-text">主动完成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#complete"><span class="nav-number">4.3.1.</span> <span class="nav-text">complete()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#completeExceptionally"><span class="nav-number">4.3.2.</span> <span class="nav-text">completeExceptionally()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isCompletedExceptionally"><span class="nav-number">4.3.3.</span> <span class="nav-text">isCompletedExceptionally()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.3.4.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E5%AE%8C%E6%88%90-%E5%BC%BA%E5%8A%A0%E5%80%BC"><span class="nav-number">4.4.</span> <span class="nav-text">主动完成-强加值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#obtrudeValue"><span class="nav-number">4.4.1.</span> <span class="nav-text">obtrudeValue()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#obtrudeException"><span class="nav-number">4.4.2.</span> <span class="nav-text">obtrudeException()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">4.4.3.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getNow"><span class="nav-number">4.5.</span> <span class="nav-text">getNow()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join"><span class="nav-number">4.6.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allOf-%E4%B8%8E"><span class="nav-number">4.7.</span> <span class="nav-text">allOf()-与</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#anyOf-%E6%88%96"><span class="nav-number">4.8.</span> <span class="nav-text">anyOf()-或</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getNumberOfDependents"><span class="nav-number">4.9.</span> <span class="nav-text">getNumberOfDependents()</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">554</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2022/02/Java8%20CompletableFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java8 CompletableFuture | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java8 CompletableFuture
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-19 08:00:01" itemprop="dateCreated datePublished" datetime="2022-02-19T08:00:01+08:00">2022-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文使用的CompletableFuture版本为java 8（java 11的CompletableFuture新增了一些方法）。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java 8 新增加了 <code>CompletableFuture</code> 类，该类提供了非常强大的 <code>Future</code> 扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合 <code>CompletableFuture</code> 的方法。</p>
<p>CompletableFuture 实现了 Future 和 CompletionStage 两个接口。</p>
<span id="more"></span>

<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>它用来描述一个异步计算的结果。<code>isDone()</code> 方法可以用来检查计算是否完成，<code>get()</code> 方法可以用来获取结果，直到完成前一直阻塞当前线程，<code>cancel()</code> 方法可以取消任务。而对于结果的获取，只能通过阻塞 <code>get()</code> 或者轮询的方式 <code>while(!isDone)</code> 。阻塞的方式违背了异步编程的理念，轮询的方式耗费无谓的CPU资源（CPU空转）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Future 表示异步计算的结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消此任务的执行。</span></span><br><span class="line"><span class="comment">     * 取消失败：如果任务已完成、已被取消或由于其他原因无法取消，则此尝试将失败。</span></span><br><span class="line"><span class="comment">     * 取消成功：如果取消成功，并且在调用取消时此任务尚未启动，则不应运行此任务。如果任务已经开始，则 mayInterruptIfRunning 参数确定是否应该中断执行此任务的线程以尝试停止任务。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此方法返回后，对 isDone 的后续调用将始终返回 true。</span></span><br><span class="line"><span class="comment">     * 如果此方法返回 true，则对 isCancelled 的后续调用将始终返回 true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：mayInterruptIfRunning——如果执行此任务的线程应该被中断，则为true；否则，允许完成正在进行的任务。</span></span><br><span class="line"><span class="comment">     * 返回：如果任务无法取消，则返回 false，通常是因为它已经正常完成；否则为true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此任务在完成之前被取消，则返回 true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此任务完成，则返回 true。完成可能是由于正常终止、异常或取消——在所有这些情况下，此方法将返回 true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，等待计算完成，然后检索其结果。</span></span><br><span class="line"><span class="comment">     * 返回：计算结果。</span></span><br><span class="line"><span class="comment">     * 抛出：CancellationException – 如果计算被取消</span></span><br><span class="line"><span class="comment">     *      ExecutionException – 如果计算抛出异常</span></span><br><span class="line"><span class="comment">     *      InterruptedException – 如果当前线程在等待时被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，最多等待给定的计算完成时间，然后检索其结果（如果可用）。</span></span><br><span class="line"><span class="comment">     * 参数：timeout - 最长等待时间</span></span><br><span class="line"><span class="comment">     *      unit - 超时参数的时间单位</span></span><br><span class="line"><span class="comment">     * 返回：计算结果。</span></span><br><span class="line"><span class="comment">     * 抛出：CancellationException – 如果计算被取消</span></span><br><span class="line"><span class="comment">     *      ExecutionException – 如果计算抛出异常</span></span><br><span class="line"><span class="comment">     *      InterruptedException – 如果当前线程在等待时被中断</span></span><br><span class="line"><span class="comment">     *      TimeoutException – 如果等待超时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h1><p>一个CompletionStage对象是异步计算中的一个阶段，当一个CompletionStage完成时会触发下一个阶段。</p>
<p>CompletionStage解决了Future的一些问题：Future没有提供通知机制，对于结果的获取，只能通过阻塞 <code>get()</code> 或者轮询的方式 <code>while(!isDone)</code> 。CompletionStage完美的解决了该问题，前一个阶段执行成功后可以自动触发下一个阶段的执行(回调)，中间无需等待。而且CompletableFuture还能够将任务放到不同的线程中执行，既可以在当前线程中直接执行任务，也可以将其放到其他任务线程中执行，这个过程是自动的，无需干预。</p>
<p>CompletionStage的方法虽多，但有命名规则，从名字上可以轻松知道这些方法是做什么的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个可能的异步计算 stage(阶段)，在另一个 CompletionStage 完成时执行操作或计算值。一个 stage 在其计算终止时完成，但这可能反过来触发其他相关 stage。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此接口中定义的功能仅采用几种基本形式，这些形式扩展为更大的方法集，以捕获一系列使用风格：</span></span><br><span class="line"><span class="comment"> * 1、阶段执行的计算可以表示为 Function、Consumer 或 Runnable（使用名称分别包括 apply、accept 或 run 的方法），具体取决于它是否需要参数或产生结果。</span></span><br><span class="line"><span class="comment"> * 例如 stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.print(x)).thenRun(() -&gt; System.out.println()).</span></span><br><span class="line"><span class="comment"> * 2、一个阶段的执行可以由单个阶段的完成、或两个阶段的完成、或两个阶段中的任何一个的完成触发。</span></span><br><span class="line"><span class="comment"> *       ！！！由两个阶段中的任何一个触发的那些不能保证哪些结果或效果用于依赖阶段的计算！！！</span></span><br><span class="line"><span class="comment"> * 3、阶段之间的依赖关系控制计算的触发，但不保证任何特定的顺序。此外，新阶段计算的执行可以通过以下三种方式中的任何一种进行安排：</span></span><br><span class="line"><span class="comment"> *       a) 默认执行</span></span><br><span class="line"><span class="comment"> *       b) 默认异步执行（使用带有后缀 async 的方法，该方法采用阶段的默认异步执行工具）</span></span><br><span class="line"><span class="comment"> *       c) 自定义（通过提供的 Executor）。</span></span><br><span class="line"><span class="comment"> *    a 和 b 的执行属性由 CompletionStage 实现指定，而不是此接口。</span></span><br><span class="line"><span class="comment"> *    具有显式 Executor 参数的方法可能具有任意执行属性，甚至可能不支持并发执行，但会以适应异步的方式进行处理。</span></span><br><span class="line"><span class="comment"> * 4、两种方法形式用来处理 触发阶段是正常完成还是异常完成：</span></span><br><span class="line"><span class="comment"> *       whenComplete 方法：无论此阶段结果如何，都允许注入一个action。</span></span><br><span class="line"><span class="comment"> *                         如果action正常完成，whenComplete方法返回的新阶段将保留此阶段的结果或异常（异常和结果不会同时存在，其中一个是null）。</span></span><br><span class="line"><span class="comment"> *                         如果action遇到异常，返回新阶段 异常完成 并携带这个异常。</span></span><br><span class="line"><span class="comment"> *       handle 方法：允许新阶段处理此阶段的结果并返回，该结果同样允许其他相关阶段进行进一步处理。</span></span><br><span class="line"><span class="comment"> * 在所有其他情况下，如果一个阶段的计算因（未经检查的）异常或错误而突然终止，则所有需要其完成的相关阶段也会异常完成，并且将 CompletionException 异常作为其原因。</span></span><br><span class="line"><span class="comment"> *       如果一个阶段依赖于两个阶段，并且都异常完成，那么 CompletionException 可能对应于这些异常中的任何一个。</span></span><br><span class="line"><span class="comment"> *       如果一个阶段依赖于其他两个阶段中的任何一个，并且其中只有一个异常完成，则无法保证依赖阶段是正常完成还是异常完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所有方法都遵循上述触发、执行和异常完成规范（在单个方法规范中不再重复）。此外，用于接收阶段完成结果的参数（即 T 类型的参数）可以为 null，但任何其他参数传递 null 值将引发 NullPointerException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该接口未定义初始创建、正常或异常强制完成、探测完成状态或结果或等待阶段完成的方法。CompletionStage 的实现可以酌情提供实现这种效果的方法。</span></span><br><span class="line"><span class="comment"> * 方法 toCompletableFuture 通过提供一个通用的转换类型来实现此接口的不同实现之间的互操作性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompletionStage</span>&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阶段区分"><a href="#阶段区分" class="headerlink" title="阶段区分"></a><font color="red">阶段区分</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stage.thenApply(x -&gt; square(x));</span><br></pre></td></tr></table></figure>

<p>stage：此阶段。</p>
<p>thenApply返回值：下一个阶段。</p>
<h2 id="thenXXX"><a href="#thenXXX" class="headerlink" title="thenXXX()"></a>thenXXX()</h2><p>以then开头的方法，表示<font color="red"><strong>当任务正常完成后</strong></font>，便执行指定的回调逻辑。有的回调可以有返回值(CompletableFuture将返回值作为任务结果)，有的回调没有返回值。</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">回调方法</th>
<th>回调方法参数</th>
<th>回调方法返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">thenApply</td>
<td align="left">Function</td>
<td>此阶段结果</td>
<td>阶段的泛型值</td>
</tr>
<tr>
<td align="left">thenAccept</td>
<td align="left">Consumer</td>
<td>此阶段结果</td>
<td>无</td>
</tr>
<tr>
<td align="left">thenRun</td>
<td align="left">Runnable</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td align="left">thenCombine</td>
<td align="left">BiFunction</td>
<td>此阶段结果和另一个给定阶段的结果</td>
<td>阶段的泛型值</td>
</tr>
<tr>
<td align="left">thenAcceptBoth</td>
<td align="left">BiConsumer</td>
<td>此阶段结果和另一个给定阶段的结果</td>
<td>无</td>
</tr>
<tr>
<td align="left">thenCompose</td>
<td align="left">Function</td>
<td>此阶段结果</td>
<td><font color="red"><strong>阶段</strong></font></td>
</tr>
</tbody></table>
<p>注意：<code>thenCompose()</code> 方法的回调方法的返回值是一个 <font color="red"><strong>阶段</strong></font>，而非阶段的泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段正常完成时，将使用此阶段的结果作为所提供函数的参数来执行该阶段。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数：fn – 用于计算返回的 CompletionStage 值的函数</span></span><br><span class="line"><span class="comment"> * 类型参数：&lt;U&gt; – 函数的返回类型</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段正常完成时，将使用此阶段的结果作为所提供操作的参数来执行该阶段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：action - 在完成返回的 CompletionStage 之前要执行的操作</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段正常完成时，执行给定操作。不接受其他任务结果参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：action - 在完成返回的 CompletionStage 之前要执行的操作</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段和另一个给定阶段都正常完成时，将使用两个结果作为所提供函数的参数执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：other – 另一个 CompletionStage</span></span><br><span class="line"><span class="comment"> *      fn – 用于计算返回的 CompletionStage 值的函数</span></span><br><span class="line"><span class="comment"> * 类型参数：&lt;U&gt; – 其他 CompletionStage 的结果类型</span></span><br><span class="line"><span class="comment"> *         &lt;V&gt; – 函数的返回类型</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletionStage&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">     BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletionStage&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">     BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletionStage&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">     BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段和另一个给定阶段都正常完成时，将使用两个结果作为所提供操作的参数执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：other – 另一个 CompletionStage</span></span><br><span class="line"><span class="comment"> *      action – 在完成返回的 CompletionStage 之前要执行的操作</span></span><br><span class="line"><span class="comment"> * 类型参数：&lt;U&gt; – 其他 CompletionStage 的结果类型</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">     BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">     BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">     BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段正常完成时，将使用此阶段作为所提供函数的参数执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：fn – 返回新的 CompletionStage 的函数</span></span><br><span class="line"><span class="comment"> * 类型参数：&lt;U&gt; – 返回的 CompletionStage 结果的类型</span></span><br><span class="line"><span class="comment"> * 返回：CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br></pre></td></tr></table></figure>

<h2 id="runXXX"><a href="#runXXX" class="headerlink" title="runXXX()"></a>runXXX()</h2><p>回调方法是Runnable，无参数，无返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段和另一个给定阶段都正常完成时，执行给定操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：other – 另一个 CompletionStage</span></span><br><span class="line"><span class="comment"> *      action – 在完成返回的 CompletionStage 之前要执行的操作</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段或另一个给定阶段正常完成时，执行给定操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：other – 另一个 CompletionStage</span></span><br><span class="line"><span class="comment"> *      action – 在完成返回的 CompletionStage 之前要执行的操作</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br></pre></td></tr></table></figure>

<h2 id="XXXEither"><a href="#XXXEither" class="headerlink" title="XXXEither()"></a>XXXEither()</h2><p><font color="blue" size="5"><strong>applyToEither()</strong></font> </p>
<p>方法有三，表示此阶段<font color="red"><strong>或者</strong></font>other阶段，任意一个正常完成后，执行fn逻辑。</p>
<p>回调方法是Function，参数为此阶段结果或另一个给定阶段的结果，<font color="red"><strong>取决于哪个先完成</strong></font>，<font color="red"><strong>有</strong></font>返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段或另一个给定阶段正常完成时，将使用相应的结果作为所提供函数的参数执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：other – 另一个 CompletionStage</span></span><br><span class="line"><span class="comment"> *      fn – 用于计算返回的 CompletionStage 值的函数</span></span><br><span class="line"><span class="comment"> * 类型参数：&lt;U&gt; – 函数的返回类型</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br></pre></td></tr></table></figure>

<p><font color="blue" size="5"><strong>acceptEither()</strong></font> </p>
<p>和 applyToEither 方法相似。</p>
<p>方法有三，表示此阶段<font color="red"><strong>或者</strong></font>other阶段，任意一个正常完成后，执行action逻辑。</p>
<p>回调方法是Consumer，参数为此阶段结果或另一个给定阶段的结果，<font color="red"><strong>取决于哪个先完成</strong></font>，<font color="red"><strong>无</strong></font>返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段另一个给定阶段正常完成时，将使用相应的结果作为所提供操作的参数执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：other – 另一个 CompletionStage</span></span><br><span class="line"><span class="comment"> *      action – 在完成返回的 CompletionStage 之前要执行的操作</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br></pre></td></tr></table></figure>

<h2 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally()"></a>exceptionally()</h2><p>如果此阶段执行过程中抛出了异常，那么将异常对象传输给 fn，fn 对异常对象做处理。如果任务正常结束了，直接将正常完成的结果作为返回的 CompletionStage 对象的结果(泛型)。</p>
<p>回调方法是Function，参数为此阶段抛出的异常，<font color="red"><strong>有</strong></font>返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage</span></span><br><span class="line"><span class="comment"> * 如果此阶段异常完成，将使用此阶段的异常作为所提供函数的参数来执行该阶段。</span></span><br><span class="line"><span class="comment"> * 如果此阶段正常完成，则 exceptionally 方法返回的阶段也会以相同的值(此阶段的正常结果)正常完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：fn – 如果此 CompletionStage 异常完成，则用于计算返回的 CompletionStage 值的函数</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete()"></a>whenComplete()</h2><p>方法有三，表示<font color="red"><strong>无论此阶段正常完成还是异常完成</strong></font>，都会执行action回调。</p>
<p>回调方法是BiConsumer，参数为 <strong>此阶段的结果</strong> 和 <strong>此阶段抛出的异常</strong>，这两个参数都可以为null。该函数式接口的方法<font color="red"><strong>无</strong></font>返回值，但是whenComplete方法有返回值。</p>
<p>如果提供的 <font color="red"><strong>action 正常完成：</strong></font>whenComplete方法返回的新阶段将保留此阶段的结果或异常（异常和结果不会同时存在，其中一个是 <code>null</code> ）。</p>
<blockquote>
<p>调用CompletableFuture的get()时，正常完成时就获取到结果，出现异常时就会抛出异常。</p>
</blockquote>
<p>如果提供的 <font color="red"><strong>action 遇到异常：</strong></font>返回新阶段 异常完成 并携带这个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个与此阶段具有相同结果或异常的新 CompletionStage，它在此阶段完成时执行给定的操作。</span></span><br><span class="line"><span class="comment"> * 当此阶段完成时，使用此阶段的结果（如果没有，则为 null）和异常（如果没有，则为 null）作为参数调用给定的操作，此阶段的结果和异常也是返回的新阶段的结果和异常。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数：action——要执行的动作</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br></pre></td></tr></table></figure>

<p>应用场景：发生异常后回滚等操作。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            whenComplete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">whenComplete</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Long&gt; future = CompletableFuture</span><br><span class="line">                .supplyAsync(() -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;step1 threadName: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">                &#125;, executor)</span><br><span class="line">                .whenCompleteAsync(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Long, Throwable&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Long aLong, Throwable throwable)</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;step2 threadName(whenComplete): &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                                System.out.println(<span class="string">&quot;正常完成: &quot;</span> + aLong);</span><br><span class="line">                                System.out.println(<span class="string">&quot;异常完成: &quot;</span> + throwable.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, executor)</span><br><span class="line">                .exceptionally(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Throwable, Long&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;step3 threadName(exceptionally): &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                        System.out.println(<span class="string">&quot;执行失败！&quot;</span> + throwable.getMessage());</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;future最终结果: &quot;</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="handle"><a href="#handle" class="headerlink" title="handle()"></a>handle()</h2><p>方法有三，表示<font color="red"><strong>无论此阶段正常完成还是异常完成</strong></font>，都会执行fn回调。</p>
<p>回调是BiFunction，参数为 <strong>此阶段的结果</strong> 和 <strong>此阶段抛出的异常</strong>，这两个参数都可以为null，该函数式接口的方法<font color="red"><strong>有</strong></font>返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletionStage，当此阶段正常或异常完成时，将使用此阶段的结果和异常作为所提供函数的参数来执行该阶段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当此阶段完成时，使用此阶段的结果（如果没有，则为 null）和异常（如果没有，则为 null）作为参数调用给定的函数，并使用函数的结果来完成返回的阶段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数： fn - 用于计算返回的 CompletionStage 值的函数</span></span><br><span class="line"><span class="comment"> * 类型参数：&lt;U&gt; – 函数的返回类型</span></span><br><span class="line"><span class="comment"> * 返回：新的 CompletionStage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>; <span class="comment">// 使用此阶段的默认异步执行工具执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span>; <span class="comment">// 使用提供的执行器 Executor 执行</span></span><br></pre></td></tr></table></figure>

<p><font color="red">与 whenComplete 方法区别：</font> </p>
<ul>
<li>whenComplete 方法的回调没有返回值，handle 方法的回调有返回值。</li>
<li>whenComplete 方法返回的新阶段将保留此阶段的结果或异常，<strong>而 handle 方法返回的新阶段的泛型值是回调方法 fn 的返回值</strong>。也就是说 handle 方法回调函数的返回值会影响最终的计算结果。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>若此阶段正常完成，加工结果。</li>
<li>若此阶段异常完成，返回一个默认值并回滚。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            whenComplete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">whenComplete</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Long&gt; future = CompletableFuture</span><br><span class="line">                .supplyAsync(() -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;step1 threadName: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">                &#125;, executor)</span><br><span class="line">                .handleAsync(<span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Long, Throwable, Long&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Long aLong, Throwable throwable)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;step2 threadName(handleAsync): &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                        <span class="keyword">if</span> (throwable == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> aLong;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(throwable.getMessage());</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, executor);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;future最终结果: &quot;</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toCompletableFuture"><a href="#toCompletableFuture" class="headerlink" title="toCompletableFuture()"></a>toCompletableFuture()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个 CompletableFuture 保持与此阶段相同的完成属性。</span></span><br><span class="line"><span class="comment"> * 如果此阶段已经是 CompletableFuture，则此方法可能会返回此阶段本身。否则，此方法的调用可能等效于 thenApply(x -&gt; x)，但返回 CompletableFuture 类型的实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不选择与其他实现互操作的 CompletionStage 实现可能会抛出 UnsupportedOperationException。意思就是，实现此接口时可以直接抛出 UnsupportedOperationException (不支持的操作异常)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：CompletableFuture</span></span><br><span class="line"><span class="comment"> * 抛出：UnsupportedOperationException – 如果此实现不与 CompletableFuture 互操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">toCompletableFuture</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>CompletableFuture 类是这样实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">toCompletableFuture</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>CompletableFuture实现了CompletionStage接口和Future接口，前者是对后者的一个扩展，增加了异步回调，支持流式（Stream）的计算处理，使 Java 在处理多任务的协同工作时更加顺畅便利。</p>
<p>比如：结果的合并；对结果异步的处理；阶段1产生的结果可以直接作为阶段2的入参，参与阶段2的计算，以此类推。这些功能放到 Futrue 身上也能实现，但现成 API 更简洁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以明确完成的 &#123;<span class="doctag">@link</span> Future&#125;（设置其值和状态），并且可以用作 &#123;<span class="doctag">@link</span> CompletionStage&#125;，支持在其完成时触发的依赖功能和操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">** 当两个或更多线程尝试调用 complete、completeExceptionally、cancel 方法时，只有其中一个成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 除了直接操纵状态和结果的相关方法外，CompletableFuture 还使用以下策略实现接口 CompletionStage：</span></span><br><span class="line"><span class="comment"> * 1、对非异步方法的依赖完成提供的操作，可以由完成当前 CompletableFuture 的线程执行，也可以由完成方法的任何其他调用者执行。</span></span><br><span class="line"><span class="comment"> * 2、所有没有显式 Executor 参数的异步方法都使用 ForkJoinPool.commonPool() 执行（除非它不支持至少两个并行级别，在这种情况下，会创建一个新线程来运行每个任务）。</span></span><br><span class="line"><span class="comment"> * 为了简化监控、调试和跟踪，所有生成的异步任务都是标记接口 CompletableFuture.AsynchronousCompletionTask 的实例。</span></span><br><span class="line"><span class="comment"> * 3、所有 CompletionStage 接口的方法都独立于其他公共方法实现，因此一个方法的行为不会受到子类中其他方法的覆盖的影响。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CompletableFuture 还使用以下策略实现 Future：</span></span><br><span class="line"><span class="comment"> * 1、与 FutureTask 类不同，此类在对 boolean cancel(boolean mayInterruptIfRunning) 的实现过程中没有用到 mayInterruptIfRunning 参数，</span></span><br><span class="line"><span class="comment"> * 无法直接控制正在执行的线程，因此cancle被视为另一种形式的异常完成。方法 cancel 与 completeExceptionally(new CancellationException()) 具</span></span><br><span class="line"><span class="comment"> * 有相同的效果。方法 isCompletedExceptionally 可用于确定 CompletableFuture 是否以任何异常方式完成。</span></span><br><span class="line"><span class="comment"> * 2、如果出现带有 CompletionException 的异常完成，get() 和 get(long, TimeUnit) 方法会抛出 ExecutionException，并且异常原因与对应</span></span><br><span class="line"><span class="comment"> * 的 CompletionException 相同。为了在大多数情况下简化使用，此类还定义了 join() 和 getNow 方法，它们在这些情况下直接抛出 CompletionException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果任务很耗时，记得传 Executor，或者方法末尾加上 <code>future.get()</code>，因为 CompletableFuture 默认使用 ForkJoinPool，而 ForkJoinPool 里面的线程都是daemon线程，主线程跑完就 over 了。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><font color="blue"><strong>创建异步操作的四个静态方法：</strong></font> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure>

<p>前两个回调方法是 Runnable，无返回值。</p>
<p>后两个回调方法是 Supplier，有返回值。</p>
<p>入参有一个线程池 Executor，如果不指定就使用默认的线程池  <code>{@link ForkJoinPool#commonPool()}</code> 。如果机器是<strong>单核</strong>的，则默认使用 <code>ThreadPerTaskExecutor</code>，该类是一个内部类，每次执行execute都会创建一个新线程。详情请查看 CompletableFuture 源码。</p>
<p><font color="blue"><strong>创建一个没有任何操作的 CompletableFuture 对象：</strong></font> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 CompletableFuture，它已经用给定的值完成了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：value - 值</span></span><br><span class="line"><span class="comment"> * 类型参数：&lt;U&gt; - 值的类型</span></span><br><span class="line"><span class="comment"> * 返回：完成的 CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">completedFuture</span><span class="params">(U value)</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException,InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;run end ...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Void</span> <span class="variable">voidResult</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;voidResult = &quot;</span> + voidResult); <span class="comment">// 由于没有返回值，这里输出null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException,InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">supplyAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;run end ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">completeTime</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;completeTime = &quot;</span> + completeTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主动完成"><a href="#主动完成" class="headerlink" title="主动完成"></a>主动完成</h2><h3 id="complete"><a href="#complete" class="headerlink" title="complete()"></a>complete()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果尚未完成，则将 get() 和相关方法返回的值设置为给定值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：value - 结果值</span></span><br><span class="line"><span class="comment"> * 返回：如果此调用导致此 CompletableFuture 转换为已完成状态，则为true，否则为false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>

<p>为什么叫CompletableFuture？CompletableFuture字面翻译过来，就是“可完成的Future”。同传统的Future相比较，CompletableFuture能够<strong>主动设置计算的结果值</strong>（主动终结计算过程，即completable），从而在某些场景下主动结束阻塞等待。而Future由于不能主动设置计算结果值，一旦调用get()进行阻塞等待，要么当计算结果产生，要么超时，才会返回。</p>
<h3 id="completeExceptionally"><a href="#completeExceptionally" class="headerlink" title="completeExceptionally()"></a>completeExceptionally()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果尚未完成，则导致调用 get() 和相关方法抛出给定的异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：ex – 异常</span></span><br><span class="line"><span class="comment"> * 返回： 如果此调用导致此 CompletableFuture 转换为已完成状态，则返回 true，否则返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">completeExceptionally</span><span class="params">(Throwable ex)</span></span><br></pre></td></tr></table></figure>

<h3 id="isCompletedExceptionally"><a href="#isCompletedExceptionally" class="headerlink" title="isCompletedExceptionally()"></a>isCompletedExceptionally()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此CompletableFuture以任何方式异常完成，则返回true。可能的原因包括取消、显式调用完成异常以及突然终止完成阶段操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：如果此CompletableFuture异常完成，则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompletedExceptionally</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>complete()</code> <font color="red"><strong>或</strong></font> <code>completeExceptionally()</code> 只能调用一次，后续调用将被忽略。若想覆盖 future 之前的值请小心使用 CompletableFuture.obtrudeValue()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.complete(<span class="number">100</span>);</span><br><span class="line">        future.completeExceptionally(<span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;手动异常完成&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(future.isCompletedExceptionally());</span><br><span class="line">        System.out.println(future.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主动完成-强加值"><a href="#主动完成-强加值" class="headerlink" title="主动完成-强加值"></a>主动完成-强加值</h2><h3 id="obtrudeValue"><a href="#obtrudeValue" class="headerlink" title="obtrudeValue()"></a>obtrudeValue()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制设置或重置方法 get() 和相关方法随后返回的值，无论是否已经完成。此方法仅用于错误恢复操作，即使在这种情况下，也可能导致使用已建立与</span></span><br><span class="line"><span class="comment"> * 覆盖结果的持续依赖完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：value - 完成值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtrudeValue</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>

<h3 id="obtrudeException"><a href="#obtrudeException" class="headerlink" title="obtrudeException()"></a>obtrudeException()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制导致方法 get() 和相关方法的后续调用抛出给定异常，无论是否已经完成。此方法仅用于错误恢复操作，即使在这种情况下，也可能导致使用已建立与</span></span><br><span class="line"><span class="comment"> * 覆盖结果的持续依赖完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：ex – 异常</span></span><br><span class="line"><span class="comment"> * 抛出： NullPointerException – 如果异常为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtrudeException</span><span class="params">(Throwable ex)</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.obtrudeValue(<span class="number">100</span>);</span><br><span class="line">        future.obtrudeValue(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// future.obtrudeException(new Exception(&quot;强加手动异常完成1&quot;));</span></span><br><span class="line">        <span class="comment">// future.obtrudeException(new Exception(&quot;强加手动异常完成2&quot;));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(future.isCompletedExceptionally());</span><br><span class="line">        System.out.println(future.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getNow"><a href="#getNow" class="headerlink" title="getNow()"></a>getNow()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数： valueIfAbsent - 如果未完成则返回的值</span></span><br><span class="line"><span class="comment"> * 返回：结果值，如果完成，否则给定值IfAbsent</span></span><br><span class="line"><span class="comment"> * 抛出：CancellationException – 如果计算被取消</span></span><br><span class="line"><span class="comment"> *      CompletionException – 如果这个未来异常完成或完成计算发生异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br></pre></td></tr></table></figure>

<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成时返回结果值，如果异常完成则抛出（未经检查的）异常。为了更好地符合通用函数形式的使用，如果此CompletableFuture在执行中发生计算异常，</span></span><br><span class="line"><span class="comment"> * 则此方法将抛出一个（未经检查的）CompletionException，并将底层异常作为其原因。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：结果值</span></span><br><span class="line"><span class="comment"> * 抛出：CancellationException – 如果计算被取消</span></span><br><span class="line"><span class="comment"> *      CompletionException – 如果这个future异常完成或完成计算发生异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>最简单的方式就是通过构造函数创建一个CompletableFuture实例。如下代码所示。由于新创建的CompletableFuture还没有任何计算结果，这时调用join，当前线程会一直阻塞在这里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.join();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>此时，如果在另外一个线程中，主动设置该CompletableFuture的值，则上面线程中的结果就能返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future.complete(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><font color="blue" size="4"><strong>与 <code>Future.get()</code> 的区别：</strong></font> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br></pre></td></tr></table></figure>

<p><code>get()</code> 方法上声明了异常，所以必须捕获。</p>
<p><code>join()</code> 方法上未声明异常，不用捕获，但可能抛出异常。</p>
<p>两者抛出的异常不同。</p>
<h2 id="allOf-与"><a href="#allOf-与" class="headerlink" title="allOf()-与"></a>allOf()-与</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当所有给定的 CompletableFuture 完成时，返回一个新的 CompletableFuture。</span></span><br><span class="line"><span class="comment"> * 如果任意给定的 CompletableFuture 异常完成，则返回的 CompletableFuture 也异常完成，并将此异常作为其原因。</span></span><br><span class="line"><span class="comment"> * 如果所有给定的 CompletableFuture 正常完成，它们的结果（如果有）不会反映在返回的 CompletableFuture 中，但可以通过单独检查它们来获得。</span></span><br><span class="line"><span class="comment"> * 如果没有提供 cfs，则返回一个 CompletableFuture 完成且值为 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法的应用之一是在继续程序之前等待一组独立的 CompletableFuture 完成，如：CompletableFuture.allOf(c1, c2, c3).join();。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：cfs – CompletableFutures</span></span><br><span class="line"><span class="comment"> * 返回：当所有给定的 CompletableFuture 完成时，返回一个新的 CompletableFuture</span></span><br><span class="line"><span class="comment"> * 抛出： NullPointerException – 如果数组或其任何元素为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure>

<p><code>allOf()</code> 的返回值是 <code>CompletableFuture&lt;Void&gt;</code> 类型，这是因为每个传入的 CompletableFuture 的返回值都可能不同，所以组合的结果无法用某种类型来表示，索性返回 <code>Void</code> 类型。那么，如何获取每个 CompletableFuture 的执行结果呢？</p>
<p>因为 <code>allof()</code> 没有返回值，所以通过 <code>theApply()</code>，给 allFutures 附上一个回调函数，在回调函数里面，调用每一个 Future 的 <code>get()/join()</code> 函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Boolean&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture.allOf(future1, future2, future3).thenApply((res) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;future1结果: &quot;</span> + future1.join());</span><br><span class="line">            System.out.println(<span class="string">&quot;future2结果: &quot;</span> + future2.join());</span><br><span class="line">            System.out.println(<span class="string">&quot;future3结果: &quot;</span> + future3.join());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;结束&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="anyOf-或"><a href="#anyOf-或" class="headerlink" title="anyOf()-或"></a>anyOf()-或</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当任意给定的 CompletableFuture 完成时（包括正常完成和异常完成），返回一个和它结果或异常相同的新的 CompletableFuture。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：cfs – CompletableFutures</span></span><br><span class="line"><span class="comment"> * 返回：一个新的CompletableFuture，当任意一个完成时，它与任何给定CompletableFuture的结果或异常一起完成</span></span><br><span class="line"><span class="comment"> * 抛出： NullPointerException – 如果数组或其任何元素为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure>

<p>任意一个 CompletableFuture 结束，就返回一个和它结果或异常相同的新的 CompletableFuture。</p>
<p>由于每个 CompletableFuture 的返回值类型都可能不同，无法判断最终返回类型，所以 anyOf 的返回值是 <code>CompletableFuture&lt;Object&gt;</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// try &#123;</span></span><br><span class="line">            <span class="comment">//     TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line">            <span class="comment">// &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">            <span class="comment">//     e.printStackTrace();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Boolean&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Object&gt; resultFuture = CompletableFuture.anyOf(future1, future2, future3);</span><br><span class="line">        resultFuture.thenApply((res) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(res.getClass() + <span class="string">&quot; 结果: &quot;</span> + res);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;结束&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getNumberOfDependents"><a href="#getNumberOfDependents" class="headerlink" title="getNumberOfDependents()"></a>getNumberOfDependents()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回其完成正在等待此 CompletableFuture 完成的 CompletableFuture 的估计数量。此方法设计用于监视系统状态，而不是用于同步控制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：依赖的 CompletableFuture 的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfDependents</span><span class="params">()</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2022/02/SQL%E4%B8%AD%E5%BC%95%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="prev" title="SQL中引号的使用">
                  <i class="fa fa-angle-left"></i> SQL中引号的使用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2022/02/Spring%E4%B8%AD@Async%E5%92%8C@Scheduled%E6%B3%A8%E8%A7%A3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="next" title="Spring中@Async和@Scheduled注解、自定义线程池">
                  Spring中@Async和@Scheduled注解、自定义线程池 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
