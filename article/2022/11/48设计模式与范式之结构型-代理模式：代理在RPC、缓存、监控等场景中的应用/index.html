<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="前面几节，我们学习了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。 其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，">
<meta property="og:type" content="article">
<meta property="og:title" content="48设计模式与范式之结构型-代理模式：代理在RPC、缓存、监控等场景中的应用">
<meta property="og:url" content="https://blog.zhaolq.com/article/2022/11/48%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="前面几节，我们学习了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。 其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.zhaolq.com/article/2022/11/48%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/jnbNov2005-1.png">
<meta property="article:published_time" content="2022-11-18T00:00:00.000Z">
<meta property="article:modified_time" content="2022-11-18T00:00:00.000Z">
<meta property="article:author" content="zhaolq">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.zhaolq.com/article/2022/11/48%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/jnbNov2005-1.png">


<link rel="canonical" href="https://blog.zhaolq.com/article/2022/11/48%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2022/11/48%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","path":"article/2022/11/48设计模式与范式之结构型-代理模式：代理在RPC、缓存、监控等场景中的应用/","title":"48设计模式与范式之结构型-代理模式：代理在RPC、缓存、监控等场景中的应用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>48设计模式与范式之结构型-代理模式：代理在RPC、缓存、监控等场景中的应用 | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">贪婪，找不到比这更好的词了，是件好事。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">代理模式的原理解析(静态代理)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">动态代理的原理解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.</span> <span class="nav-text">代理模式的应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91"><span class="nav-number">3.1.</span> <span class="nav-text">1.业务系统的非功能性需求开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">2.代理模式在RPC、缓存中的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90-%E6%89%A9%E5%B1%95"><span class="nav-number">4.</span> <span class="nav-text">动态代理详细解析(扩展)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">静态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">JDK动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.2.1.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB"><span class="nav-number">4.2.2.</span> <span class="nav-text">原始类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0InvocationHandler%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.2.3.</span> <span class="nav-text">实现InvocationHandler接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="nav-number">4.2.4.</span> <span class="nav-text">创建动态代理类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="nav-number">4.2.5.</span> <span class="nav-text">使用动态代理类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.6.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CGLIB-Code-Generation-Library"><span class="nav-number">4.3.</span> <span class="nav-text">CGLIB(Code Generation Library)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%8A%E5%96%9C%EF%BC%81%EF%BC%81%EF%BC%81"><span class="nav-number">4.3.1.</span> <span class="nav-text">惊喜！！！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCGLIB%EF%BC%9F"><span class="nav-number">4.3.2.</span> <span class="nav-text">什么是CGLIB？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIB%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.3.</span> <span class="nav-text">CGLIB原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIB%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.4.</span> <span class="nav-text">CGLIB的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8CGLIB%EF%BC%9F"><span class="nav-number">4.3.5.</span> <span class="nav-text">为什么使用CGLIB？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIB%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.6.</span> <span class="nav-text">CGLIB组成结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIB%E7%9A%84API"><span class="nav-number">4.3.7.</span> <span class="nav-text">CGLIB的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIb%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">4.3.8.</span> <span class="nav-text">CGLIb实现动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB-1"><span class="nav-number">4.3.8.1.</span> <span class="nav-text">原始类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0MethodInterceptor%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.8.2.</span> <span class="nav-text">实现MethodInterceptor接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="nav-number">4.3.8.3.</span> <span class="nav-text">创建和使用动态代理类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callback-%E5%92%8CCallbackFilter"><span class="nav-number">4.3.9.</span> <span class="nav-text">Callback[]和CallbackFilter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0FixedValue%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.9.1.</span> <span class="nav-text">实现FixedValue接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0CallbackFilter%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.9.2.</span> <span class="nav-text">实现CallbackFilter接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">4.3.9.3.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%AF%B9%E8%B1%A1-%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.3.10.</span> <span class="nav-text">延迟加载对象(懒加载)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB-2"><span class="nav-number">4.3.10.1.</span> <span class="nav-text">原始类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0LazyLoader%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.10.2.</span> <span class="nav-text">实现LazyLoader接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Dispatcher%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.10.3.</span> <span class="nav-text">实现Dispatcher接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.3.10.4.</span> <span class="nav-text">创建延迟加载对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="nav-number">4.3.10.5.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%94%9F%E6%88%90%E5%99%A8InterfaceMaker"><span class="nav-number">4.3.11.</span> <span class="nav-text">接口生成器InterfaceMaker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot%E4%B8%AD%E7%9A%84AOP%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="nav-number">4.4.</span> <span class="nav-text">SpringBoot中的AOP使用哪种代理？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="nav-number">5.</span> <span class="nav-text">重点回顾</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E5%A0%82%E8%AE%A8%E8%AE%BA"><span class="nav-number">6.</span> <span class="nav-text">课堂讨论</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">554</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2022/11/48%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="48设计模式与范式之结构型-代理模式：代理在RPC、缓存、监控等场景中的应用 | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          48设计模式与范式之结构型-代理模式：代理在RPC、缓存、监控等场景中的应用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-18 08:00:00" itemprop="dateCreated datePublished" datetime="2022-11-18T08:00:00+08:00">2022-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>前面几节，我们学习了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p>
<p>其中，<font color="blue"><strong>单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</strong></font> </p>
<p>从今天起，我们开始学习另外一种类型的设计模式：结构型模式。<font color="red"><strong>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。</strong></font>结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<span id="more"></span>

<h1 id="代理模式的原理解析-静态代理"><a href="#代理模式的原理解析-静态代理" class="headerlink" title="代理模式的原理解析(静态代理)"></a>代理模式的原理解析(静态代理)</h1><p><strong>代理模式</strong>（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。我们通过一个简单的例子来解释一下这段话。</p>
<p>这个例子来自我们在第25、26、39、40节中讲的性能计数器。当时我们开发了一个MetricsCollector类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个MetricsCollector类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略login逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略register逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</p>
<p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类UserControllerProxy和原始类UserController实现相同的接口IUserController。UserController类只负责业务功能。代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并<font color="red"><strong>通过委托的方式调用原始类来执行业务代码</strong></font>。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">  UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略login逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略register逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">(UserController userController)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userController = userController;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托</span></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure>

<p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，<font color="red">代理类和原始类需要实现相同的接口。</font>但是，<font color="red">如果原始类并没有定义接口</font>，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也<font color="red">没办法直接修改原始类</font>，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</p>
<p><font color="red">对于这种外部类的扩展，我们一般都是采用继承的方式。</font>这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>();</span><br></pre></td></tr></table></figure>

<h1 id="动态代理的原理解析"><a href="#动态代理的原理解析" class="headerlink" title="动态代理的原理解析"></a>动态代理的原理解析</h1><p>不过，刚刚的代码实现还是有点<font color="red"><strong>问题</strong></font>。<font color="red"><strong>一方面</strong></font>，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。<font color="red"><strong>另一方面</strong></font>，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</p>
<p>如果有50个要添加附加功能的原始类，那我们就要创建50个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p>
<p>我们可以使用动态代理来解决这个问题。所谓<font color="red"><strong>动态代理</strong>（Dynamic Proxy）</font>，<font color="green"><strong>就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</strong></font>那如何实现动态代理呢？</p>
<p>如果你熟悉的是Java语言，实现动态代理就是件很简单的事情。因为<font color="blue"><strong>Java语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是Java的反射语法）。</strong></font>我们来看一下，如何用Java的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCollectorProxy</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MetricsCollectorProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    <span class="type">DynamicProxyHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">      <span class="type">String</span> <span class="variable">apiName</span> <span class="operator">=</span> proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MetricsCollectorProxy使用举例</span></span><br><span class="line"><span class="type">MetricsCollectorProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetricsCollectorProxy</span>();</span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> (IUserController) proxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure>

<p>实际上，Spring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>
<h1 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h1><p>代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在你的项目开发中。</p>
<h2 id="1-业务系统的非功能性需求开发"><a href="#1-业务系统的非功能性需求开发" class="headerlink" title="1.业务系统的非功能性需求开发"></a>1.业务系统的非功能性需求开发</h2><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发（<font color="red"><strong>这里有个问题，如何让多个非功能性需求共同生效，创建多个代理实例？还是生成代理的代理，一层层嵌套的代理？</strong></font>）。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p>
<p>如果你熟悉Java语言和Spring开发框架，这部分工作都是可以在Spring AOP切面中完成的。前面我们也提到，Spring AOP底层的实现原理就是基于动态代理。</p>
<h2 id="2-代理模式在RPC、缓存中的应用"><a href="#2-代理模式在RPC、缓存中的应用" class="headerlink" title="2.代理模式在RPC、缓存中的应用"></a>2.代理模式在RPC、缓存中的应用</h2><p><strong>实际上，RPC框架也可以看作一种代理模式</strong>，GoF的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p>
<p>关于远程代理的代码示例，我自己实现了一个简单的RPC框架Demo，放到了GitHub中，你可以点击这里的<a target="_blank" rel="noopener" href="https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc">链接</a>查看。</p>
<p>**我们再来看代理模式在缓存中的应用。**假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</p>
<p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p>
<p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于Spring框架来开发的话，那就可以在AOP切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在AOP切面中拦截请求，如果请求中带有支持缓存的字段（比如http:&#x2F;&#x2F;…?..&amp;cached&#x3D;true），我们便从缓存（内存缓存或者Redis缓存等）中获取数据直接返回。</p>
<h1 id="动态代理详细解析-扩展"><a href="#动态代理详细解析-扩展" class="headerlink" title="动态代理详细解析(扩展)"></a>动态代理详细解析(扩展)</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p> <a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/proxy-pattern.html">代理模式 - 菜鸟</a> </p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK中的动态代理是通过 <font color="red"><strong>反射类 Proxy</strong></font> 以及 <font color="red"><strong>InvocationHandler 回调接口</strong></font> 实现的，JDK中所有<font color="red"><strong>要进行动态代理的类必须要实现一个接口</strong></font>，也就是说<font color="blue"><strong>只能对该类所实现接口中定义的方法进行代理</strong></font>，这在实际编程中具有一定的局限性，而且使用反射的效率也并不是很高。</p>
<p>动态代理神奇的地方就是：</p>
<ul>
<li>代理对象是在程序运行时产生的，而不是编译期；</li>
<li><strong>对代理对象的所有接口方法调用都会转发到 <code>InvocationHandler.invoke()</code> 方法</strong>，在 <code>invoke()</code> 方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；之后我们通过某种方式执行真正的方法体。</li>
</ul>
<blockquote>
<p><font color="green"><strong>注意：对于从Object中继承的方法，JDK Proxy会把 <font color="red"><code>hashCode()</code>、<code>equals()</code>、<code>toString()</code></font> 这三个非接口方法转发给 <code>InvocationHandler</code>，其余的Object方法则不会转发。详见<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/reflect/Proxy.html">JDK Proxy官方文档</a>。</strong></font> </p>
</blockquote>
<p>通过秒表代理创建动态代理类，实现程序执行时间的计算：</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>被代理类（原始类）必须要实现的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要动态代理的类必须要实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">selectPasswdById</span><span class="params">(Integer userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原始类"><a href="#原始类" class="headerlink" title="原始类"></a>原始类</h3><p>被代理类（原始类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要动态代理的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">selectPasswdById</span><span class="params">(Integer userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过用户ID查询: selectById&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟查询耗时</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现InvocationHandler接口"><a href="#实现InvocationHandler接口" class="headerlink" title="实现InvocationHandler接口"></a>实现InvocationHandler接口</h3><p>实现 java.lang.reflect.InvocationHandler 接口，定义一个调用处理程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用处理程序，实现 &#123;<span class="doctag">@link</span> java.lang.reflect.InvocationHandler&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.reflect.InvocationHandler &#123;</span><br><span class="line">    <span class="comment">// 被代理的对象（原始类对象）</span></span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line">    <span class="comment">// 这里还可以委托其他对象，比如想记录程序执行时间就可以委托收集器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomInvocationHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 动态生成的代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理的接口方法对应的Method实例，即原始类中方法的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 对象数组，被代理的方法参数，如果接口方法不带参数，则为null。接口中未声明的方法不被代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> StopWatch.createStarted();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始方法调用前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args); <span class="comment">// 调用原始类的原始方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始方法调用后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="type">String</span> <span class="variable">apiName</span> <span class="operator">=</span> proxy.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">        System.out.println(apiName + <span class="string">&quot; 执行耗时: &quot;</span> + stopWatch.getTime() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里可以通过组合委托实现其他操作，比如记录程序执行时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.join(<span class="string">&quot;代理修改了结果: &quot;</span>, <span class="string">&quot;21218CCA77804D2BA1922C33E0151105&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建动态代理类"><a href="#创建动态代理类" class="headerlink" title="创建动态代理类"></a>创建动态代理类</h3><p>可以称为 <strong>创建代理对象的工厂</strong> 吧。<font color="orang"><strong>实际上将 InvocationHandler 的实现类作为 private 修饰的内部类更加合适，由于下文 CGLIB 会用到，所以放到外面。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomProxy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxiedObject 被代理的对象（原始类对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">createCustomProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> proxiedObject.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">        <span class="type">CustomInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomInvocationHandler</span>(proxiedObject);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个代理类对象，接收三个参数，Proxy类提供了很多方法，但是我们最常用的是newProxyInstance方法。</span></span><br><span class="line"><span class="comment">            loader：用于定义代理类的类加载器</span></span><br><span class="line"><span class="comment">            interfaces：代理类要实现的接口列表。代理类实现了这些接口，就可以调用接口中声明的所有方法。</span></span><br><span class="line"><span class="comment">            h：表示当通过动态代理对象调用方法时，将方法调用分发到InvocationHandler对象上，并最终由其调用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用动态代理类"><a href="#使用动态代理类" class="headerlink" title="使用动态代理类"></a>使用动态代理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 将JDK动态代理生成的类保存为.class文件。默认在项目的根目录下</span></span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// JDK8之前</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// JDK8之后</span></span><br><span class="line"></span><br><span class="line">        <span class="type">IUserService</span> <span class="variable">userService</span> <span class="operator">=</span> (IUserService) CustomProxy.createCustomProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        System.out.println(userService.selectPasswdById(<span class="number">123456</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类     : &quot;</span> + userService.getClass()); <span class="comment">// InvocationHandler.invoke的proxy参数就是代理类的实例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类的父类: &quot;</span> + userService.getClass().getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;代理类的实现: &quot;</span> + Arrays.toString(userService.getClass().getInterfaces()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Proxy类的另外两个方法的使用</span></span><br><span class="line">        <span class="keyword">if</span> (java.lang.reflect.Proxy.isProxyClass(userService.getClass())) &#123;</span><br><span class="line">            java.lang.reflect.<span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> java.lang.reflect.Proxy.getInvocationHandler(userService);</span><br><span class="line">            System.out.println(<span class="string">&quot;调用处理程序: &quot;</span> + handler.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始方法调用前</span><br><span class="line">通过用户ID查询: selectById</span><br><span class="line">原始方法调用后</span><br><span class="line">com.sun.proxy.$Proxy0:selectPasswdById 执行耗时: 105ms</span><br><span class="line">代理修改了结果: 21218CCA77804D2BA1922C33E0151105</span><br><span class="line"></span><br><span class="line">代理类     : class com.sun.proxy.$Proxy0</span><br><span class="line">代理类的父类: class java.lang.reflect.Proxy</span><br><span class="line">代理类的实现: [interface com.zhaolq.mars.demo.a.IUserService]</span><br><span class="line">调用处理程序: class com.zhaolq.mars.demo.a.CustomInvocationHandler</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><font style="background-color:yellow;">问题</font></h3><p><code>InvocationHandler</code> 的 <code>invoke</code> 方法的<font color="red">第一个参数 <code>proxy</code> 好像从来没有用过</font>。</p>
<ul>
<li><p><font color="red">为什么JDK的动态代理一定要基于接口实现</font><br>查看代理类源码可知，其继承了 <code>java.lang.reflect.Proxy</code> 类，实现了被代理的接口。<font color="red">由于Java是单继承，不能再继承其他类，</font>所以JDK的动态代理不支持对实现类的代理，只支持接口的代理。</p>
</li>
<li><p>proxy代表什么意思<br>proxy是真实对象的真实代理对象，invoke方法可以返回调用代理对象方法的返回结果，也可以返回对象的真实代理对象（com.sun.proxy.$Proxy0）。</p>
</li>
<li><p>proxy参数怎么用及什么时候用<br>当需要代理后的方法返回代理对象进行后续调用时使用。</p>
</li>
<li><p>proxy参数的类型是什么<br><code>com.zhaolq.mars.demo.$Proxy0</code>（被代理接口为非public）或 <code>com.sun.proxy.$Proxy0</code>（被代理接口为public）真实的代理对象。</p>
</li>
<li><p>为什么不用 <code>this</code> 代替 <code>proxy</code><br>因为 <code>this</code> 代表的是 <code>InvocationHandler</code> 接口实现类本身，并不是真实的代理对象。</p>
</li>
</ul>
<h2 id="CGLIB-Code-Generation-Library"><a href="#CGLIB-Code-Generation-Library" class="headerlink" title="CGLIB(Code Generation Library)"></a>CGLIB(Code Generation Library)</h2><h3 id="惊喜！！！"><a href="#惊喜！！！" class="headerlink" title="惊喜！！！"></a><font color="red">惊喜！！！</font></h3><p>将上文实现的 JDK 动态代理示例中所有的</p>
<p> <strong>java.lang.reflect.Proxy 、 java.lang.reflect.InvocationHandler</strong> </p>
<p>修改为</p>
<p> <strong>net.sf.cglib.proxy.Proxy 、 net.sf.cglib.proxy.InvocationHandler</strong> </p>
<p><font color="red">代理一样可以运行，同样的，原始类必须实现接口。由此可见，CGLIB 实现了 JDK 动态代理 的相同功能，JDK 动态代理 是 CGLIB 的子集。</font> </p>
<h3 id="什么是CGLIB？"><a href="#什么是CGLIB？" class="headerlink" title="什么是CGLIB？"></a>什么是CGLIB？</h3><p>CGLIB 是一个功能强大，高性能的代码生成包。它<font color="red">为没有实现接口的类提供代理</font>，为 <font color="red">JDK 动态代理</font>提供了很好<font color="red">的补充</font>。通常可以使用 Java 的动态代理创建代理，但<font color="blue"><strong>当要代理的类没有实现接口或者为了更好的性能</strong>，CGLIB是一个好的选择。</font></p>
<p>CGLIB 作为一个开源项目，其代码托管在 Github，地址为：<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a> </p>
<h3 id="CGLIB原理"><a href="#CGLIB原理" class="headerlink" title="CGLIB原理"></a>CGLIB原理</h3><p><strong>CGLIB 原理</strong>：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。<font color="red">它比使用java反射的JDK动态代理要快。</font></p>
<p><strong>CGLIB 底层</strong>：使用字节码处理框架<font color="red">ASM</font>，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p><strong>CGLIB缺点</strong>：<font color="red">对于final方法，无法进行代理。</font></p>
<h3 id="CGLIB的应用"><a href="#CGLIB的应用" class="headerlink" title="CGLIB的应用"></a>CGLIB的应用</h3><p>广泛的被许多AOP的框架使用，例如Spring AOP和dynaop。Hibernate使用CGLIB来代理单端single-ended(多对一和一对一)关联。</p>
<h3 id="为什么使用CGLIB？"><a href="#为什么使用CGLIB？" class="headerlink" title="为什么使用CGLIB？"></a>为什么使用CGLIB？</h3><p>CGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是<font color="red">CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。</font>如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。</p>
<h3 id="CGLIB组成结构"><a href="#CGLIB组成结构" class="headerlink" title="CGLIB组成结构"></a>CGLIB组成结构</h3><p><img src="/article/2022/11/48%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/jnbNov2005-1.png" alt="img"></p>
<p>CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。除了CGLIB库外，脚本语言（如Groovy何BeanShell）也使用ASM生成字节码。ASM使用类似SAX的解析器来实现高性能。我们不鼓励直接使用ASM，因为它需要对Java字节码的格式足够的了解。</p>
<h3 id="CGLIB的API"><a href="#CGLIB的API" class="headerlink" title="CGLIB的API"></a>CGLIB的API</h3><p><strong>Maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>CGLIB类库</strong></p>
<p>由于基本代码很少，学起来有一定的困难，主要是缺少文档和示例，这也是CGLIB的一个不足之处。</p>
<p>本系列使用的CGLIB版本是3.3.0。</p>
<ul>
<li><strong>net.sf.cglib.core</strong>: 底层字节码处理类，他们大部分与ASM有关系。</li>
<li><strong>net.sf.cglib.transform</strong>: 编译期或运行期类和类文件的转换</li>
<li><strong>net.sf.cglib.proxy</strong>: 实现创建代理和方法拦截器的类</li>
<li><strong>net.sf.cglib.reflect</strong>: 实现快速反射和C#风格代理的类</li>
<li><strong>net.sf.cglib.util</strong>: 集合排序等工具类</li>
<li><strong>net.sf.cglib.beans</strong>: JavaBean相关的工具类</li>
</ul>
<p>本篇介绍通过MethodInterceptor和Enhancer实现一个动态代理。</p>
<h3 id="CGLIb实现动态代理"><a href="#CGLIb实现动态代理" class="headerlink" title="CGLIb实现动态代理"></a>CGLIb实现动态代理</h3><p>使用CGLIb实现动态代理，<font color="red"><strong>完全不受代理类必须实现接口的限制</strong></font>，而且CGLIb底层采用<strong>ASM字节码生成框架</strong>，使用<font color="blue"><strong>字节码技术</strong></font>生成代理类，<font color="blue"><strong>比使用Java反射效率要高</strong></font>。唯一需要注意的是，<font color="red"><strong>CGLIb不能对声明为final的方法进行代理，因为CGLIb原理是动态生成被代理类（原始类）的子类，final修饰的方法不能被重写。</strong></font></p>
<p>下面，将通过一个实例介绍使用CGLIb实现动态代理。</p>
<h4 id="原始类-1"><a href="#原始类-1" class="headerlink" title="原始类"></a>原始类</h4><p>被代理类（原始类），没有实现任何接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有实现接口，需要CGLIB动态代理的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">selectPasswdById</span><span class="params">(Integer userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过用户ID查询: selectById&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟查询耗时</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodOne</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">methodTwo</span><span class="params">(String paramName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paramName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现MethodInterceptor接口"><a href="#实现MethodInterceptor接口" class="headerlink" title="实现MethodInterceptor接口"></a>实现MethodInterceptor接口</h4><p>创建 Callback 接口的实现，可以实现<font color="red"><strong>子接口</strong></font> net.sf.cglib.proxy.MethodInterceptor、net.sf.cglib.proxy.InvocationHandler，更多子接口见源码。</p>
<p>定义一个方法拦截器。在调用原始方法时，CGLIb 会回调 MethodInterceptor 接口方法拦截，来实现自己的代理逻辑，类似于 JDK 中的 InvocationHandler 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.StopWatch;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法拦截器，实现 &#123;<span class="doctag">@link</span> net.sf.cglib.proxy.MethodInterceptor&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomInterceptor</span> <span class="keyword">implements</span> <span class="title class_">net</span>.sf.cglib.proxy.MethodInterceptor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj CGLIb动态生成的代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理的方法引用，即原始类中方法的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 对象数组，被代理的方法参数，如果接口方法不带参数，则为null。final声明的方法不被代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 方法代理对象，即代理类中方法的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Object 代理类实例的方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] params, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> StopWatch.createStarted();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始方法调用前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, params); <span class="comment">// method和proxy有什么区别？</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始方法调用后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="type">String</span> <span class="variable">apiName</span> <span class="operator">=</span> obj.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">        System.out.println(apiName + <span class="string">&quot; 执行耗时: &quot;</span> + stopWatch.getTime() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里可以通过组合委托实现其他操作，比如记录程序执行时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.join(<span class="string">&quot;代理修改了结果: &quot;</span>, <span class="string">&quot;21218CCA77804D2BA1922C33E0151105&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个<strong>调用处理程序</strong>，**注意不是 JDK 中的 InvocationHandler 接口，这里复用上文的 CustomInvocationHandler，除了实现的接口来自不同包以外，代码完全相同。**见 <font color="red"><strong>惊喜！！！</strong></font> 目录。</p>
<h4 id="创建和使用动态代理类"><a href="#创建和使用动态代理类" class="headerlink" title="创建和使用动态代理类"></a>创建和使用动态代理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展。</span></span><br><span class="line"><span class="comment">         * 首先将原始类（被代理类）UserServiceImpl设置成父类，</span></span><br><span class="line"><span class="comment">         * 然后设置拦截器CustomInterceptor，</span></span><br><span class="line"><span class="comment">         * 最后执行enhancer.create()动态生成一个代理类，并从Object强制转型成父类型UserServiceImpl。</span></span><br><span class="line"><span class="comment">         * 最后，在代理类上调用方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">CustomInterceptor</span>());</span><br><span class="line">        <span class="comment">// enhancer.setCallback(new CustomInvocationHandler(new UserServiceImpl()));</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> (UserServiceImpl) enhancer.create();</span><br><span class="line">        System.out.println(userService.selectPasswdById(<span class="number">123456</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类     : &quot;</span> + userService.getClass()); <span class="comment">// MethodInterceptor.intercept的obj参数就是代理类的实例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类的父类: &quot;</span> + userService.getClass().getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;代理类的实现: &quot;</span> + Arrays.toString(userService.getClass().getInterfaces()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Proxy类的另外两个方法的使用</span></span><br><span class="line">        <span class="keyword">if</span> (net.sf.cglib.proxy.Proxy.isProxyClass(userService.getClass())) &#123;</span><br><span class="line">            net.sf.cglib.proxy.<span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> net.sf.cglib.proxy.Proxy.getInvocationHandler(userService);</span><br><span class="line">            System.out.println(<span class="string">&quot;调用处理程序: &quot;</span> + handler.getClass());</span><br><span class="line">            <span class="comment">// 思考：为什么没有进来呢？--isProxyClass貌似只能用来判断回调接口为net.sf.cglib.proxy.InvocationHandler的代理类。--</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原始方法调用前</span><br><span class="line">通过用户ID查询: selectById</span><br><span class="line">原始方法调用后</span><br><span class="line">com.zhaolq.mars.demo.a.UserServiceImpl$$EnhancerByCGLIB$$fddb78dd:selectPasswdById 执行耗时: 122ms</span><br><span class="line">代理修改了结果: 21218CCA77804D2BA1922C33E0151105</span><br><span class="line"></span><br><span class="line">代理类     : class com.zhaolq.mars.demo.a.UserServiceImpl$$EnhancerByCGLIB$$fddb78dd</span><br><span class="line">代理类的父类: class com.zhaolq.mars.demo.a.UserServiceImpl</span><br><span class="line">代理类的实现: [interface net.sf.cglib.proxy.Factory]</span><br></pre></td></tr></table></figure>

<h3 id="Callback-和CallbackFilter"><a href="#Callback-和CallbackFilter" class="headerlink" title="Callback[]和CallbackFilter"></a>Callback[]和CallbackFilter</h3><p>前面的动态代理类代理了原始类中的所有方法，那么如何让不同方法执行不同的回调（代理）逻辑呢？</p>
<p><strong>Enhancer 类的 <code>public void setCallbacks(Callback[] callbacks)</code> 和 <code>public void setCallbackFilter(CallbackFilter filter)</code> 方法<font color="red">可以设置对不同方法执行不同的回调（代理）逻辑，或者根本不执行回调。</font></strong> </p>
<p><font color="blue"><strong>在 JDK 动态代理中并没有类似的功能，对 InvocationHandler 接口方法的调用对代理类内的所以方法都有效。</strong></font> </p>
<h4 id="实现FixedValue接口"><a href="#实现FixedValue接口" class="headerlink" title="实现FixedValue接口"></a>实现FixedValue接口</h4><p>FixedValue 也是 Callback 的子接口，表示返回固定值的回调。</p>
<p><font color="red">注意：loadObject() 方法的返回值类型必须与代理方法的返回值类型兼容。</font> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.FixedValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示锁定方法返回值，无论被代理类的方法返回什么值，回调方法都返回固定值。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 该回调无法获得正在调用的方法信息（因为loadObject()方法参数中并没有Method对象），并且返回对象的类型必须与代理方法的返回类型兼容。</span></span><br><span class="line"><span class="comment"> * 这使得此回调主要用于强制执行特定方法（通过使用CallbackFilter以很少的开销返回固定值）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomResultFixedValue</span> <span class="keyword">implements</span> <span class="title class_">FixedValue</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类实现FixedValue接口，同时锁定回调值为整型999</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Object 与此回调映射到的每个方法的返回值类型匹配的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现CallbackFilter接口"><a href="#实现CallbackFilter接口" class="headerlink" title="实现CallbackFilter接口"></a>实现CallbackFilter接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Enhancer生成的子类（代理类）的方法映射到特定的回调（代理）数组Callback[]，为每个方法选择的回调类型会影响子类（代理类）中为该方法生成的字节码，并且在类的生命周期内不能更改。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注意： CallbackFilter实现应该是轻量级的，因为 cglib 可能会保持CallbackFilter对象处于活动状态以启用生成类的缓存。更喜欢使用static类来实现CallbackFilter。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomMethodCallbackFilter</span> <span class="keyword">implements</span> <span class="title class_">net</span>.sf.cglib.proxy.CallbackFilter &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将方法映射到回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int 回调数组Callback[]的索引值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">accept</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filter toString == 0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示当调用代理类的toString方法时，执行Callback[]数组中索引为0的回调</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;selectPasswdById&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filter selectPasswdById == 1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;methodOne&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filter method1 == 2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示当调用代理类的其他方法时，执行Callback[]数组中索引为0的回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callback</span> <span class="variable">noOpCallback</span> <span class="operator">=</span> NoOp.INSTANCE; <span class="comment">// 这个NoOp表示no operator，即什么操作也不做，代理类直接调用原始类的方法不进行拦截。</span></span><br><span class="line">        <span class="type">Callback</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomInterceptor</span>();</span><br><span class="line">        <span class="type">Callback</span> <span class="variable">fixedValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomResultFixedValue</span>();</span><br><span class="line">        <span class="comment">// 回调数组Callback[]</span></span><br><span class="line">        Callback[] callbackArray = <span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;noOpCallback, interceptor, fixedValue&#125;;</span><br><span class="line">        <span class="comment">// 代理类各方法映射到特定回调数组Callback[]的CallbackFilter</span></span><br><span class="line">        <span class="type">CallbackFilter</span> <span class="variable">callbackFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomMethodCallbackFilter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        enhancer.setCallbackFilter(callbackFilter);</span><br><span class="line">        enhancer.setCallbacks(callbackArray);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> (UserServiceImpl) enhancer.create();</span><br><span class="line">        ConsoleKeyValue.create()</span><br><span class="line">                .addKeyValue(<span class="string">&quot;selectPasswdById&quot;</span>, userService.selectPasswdById(<span class="number">123456</span>)) <span class="comment">// 索引为1的回调，interceptor</span></span><br><span class="line">                .addKeyValue(<span class="string">&quot;methodOne&quot;</span>, String.valueOf(userService.methodOne(<span class="number">100</span>))) <span class="comment">// 索引为2的回调，fixedValue</span></span><br><span class="line">                .addKeyValue(<span class="string">&quot;methodTwo&quot;</span>, userService.methodTwo(<span class="string">&quot;m2&quot;</span>)) <span class="comment">// 索引为0的回调，noOpCallback</span></span><br><span class="line">                .addKeyValue(<span class="string">&quot;toString&quot;</span>, userService.toString())</span><br><span class="line">                .print(); <span class="comment">// 索引为0的回调，noOpCallback</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filter method1 == 2</span><br><span class="line">filter selectPasswdById == 1</span><br><span class="line">filter toString == 0</span><br><span class="line">原始方法调用前</span><br><span class="line">通过用户ID查询: selectById</span><br><span class="line">原始方法调用后</span><br><span class="line">com.zhaolq.mars.demo.a.UserServiceImpl$$EnhancerByCGLIB$$675f4824:selectPasswdById 执行耗时: 112ms</span><br><span class="line">+----+--------------------+------------------------------------------------------------------------------+</span><br><span class="line">         selectPasswdById: 代理修改了结果: 21218CCA77804D2BA1922C33E0151105                                  </span><br><span class="line">                methodOne: 999                                                                            </span><br><span class="line">                methodTwo: m2                                                                             </span><br><span class="line">                 toString: com.zhaolq.mars.demo.a.UserServiceImpl$$EnhancerByCGLIB$$675f4824@25a65b77     </span><br><span class="line">+----+--------------------+------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="延迟加载对象-懒加载"><a href="#延迟加载对象-懒加载" class="headerlink" title="延迟加载对象(懒加载)"></a>延迟加载对象(懒加载)</h3><p>说到延迟加载，应该经常接触到，尤其是使用Hibernate的时候，本篇将通过一个实例分析延迟加载的实现方式。 </p>
<p><font color="red">两种延迟加载接口可用于创建延迟加载对象，</font>都继承了Callback，所以都是Callback类型（回调类型）：</p>
<ul>
<li>LazyLoader：只在<font color="red"><strong>第一次使用</strong></font>延迟加载对象时触发代理类回调方法</li>
<li>Dispatcher：<font color="red"><strong>每次使用</strong></font>延迟加载对象时都会触发代理类回调方法</li>
</ul>
<p>**示例：**定义一个实体类LoaderBean，该Bean内有一个需要延迟加载的属性PropertyBean。</p>
<h4 id="原始类-2"><a href="#原始类-2" class="headerlink" title="原始类"></a>原始类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PropertyBean [key=&quot;</span> + key + <span class="string">&quot;, value=&quot;</span> + value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现LazyLoader接口"><a href="#实现LazyLoader接口" class="headerlink" title="实现LazyLoader接口"></a>实现LazyLoader接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClassLazyLoader</span> <span class="keyword">implements</span> <span class="title class_">net</span>.sf.cglib.proxy.LazyLoader &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before lazyLoader...&quot;</span>);</span><br><span class="line">        <span class="type">PropertyBean</span> <span class="variable">propertyBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyBean</span>();</span><br><span class="line">        propertyBean.setKey(<span class="string">&quot;objectFromLazyLoader&quot;</span>);</span><br><span class="line">        propertyBean.setValue(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;after lazyLoader...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> propertyBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Dispatcher接口"><a href="#实现Dispatcher接口" class="headerlink" title="实现Dispatcher接口"></a>实现Dispatcher接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClassDispatcher</span> <span class="keyword">implements</span> <span class="title class_">net</span>.sf.cglib.proxy.Dispatcher &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before Dispatcher...&quot;</span>);</span><br><span class="line">        <span class="type">PropertyBean</span> <span class="variable">propertyBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyBean</span>();</span><br><span class="line">        propertyBean.setKey(<span class="string">&quot;objectFromDispatcher&quot;</span>);</span><br><span class="line">        propertyBean.setValue(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;after Dispatcher...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> propertyBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建延迟加载对象"><a href="#创建延迟加载对象" class="headerlink" title="创建延迟加载对象"></a>创建延迟加载对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> PropertyBean propertyBeanLazyLoader;</span><br><span class="line">    <span class="keyword">private</span> PropertyBean propertyBeanDispatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LazyBean</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lazy bean init&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.propertyBeanLazyLoader = createPropertyBeanLazyLoader();</span><br><span class="line">        <span class="built_in">this</span>.propertyBeanDispatcher = createPropertyBeanDispatcher();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用LazyLoader回调类型创建延迟加载对象，只在第一次使用延迟加载对象时初始化（只第一次懒加载）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PropertyBean <span class="title function_">createPropertyBeanLazyLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用cglib进行懒加载 对需要延迟加载的对象添加代理。</span></span><br><span class="line"><span class="comment">         * 当使用延迟加载对象时，先通过代理类回调方法进行对象初始化。</span></span><br><span class="line"><span class="comment">         * 在不需要延迟加载对象时，只要不去使用它，该对象就不会被初始化了（在CGLib的实现中只要使用延迟加载对象，就会自动触发代理类回调）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(PropertyBean.class);</span><br><span class="line">        <span class="type">PropertyBean</span> <span class="variable">pb</span> <span class="operator">=</span> (PropertyBean) enhancer.create(PropertyBean.class, <span class="keyword">new</span> <span class="title class_">ConcreteClassLazyLoader</span>());</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Dispatcher回调类型创建延迟加载对象，每次使用延迟加载对象时都会初始化（每次都懒加载）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PropertyBean <span class="title function_">createPropertyBeanDispatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(PropertyBean.class);</span><br><span class="line">        <span class="type">PropertyBean</span> <span class="variable">pb</span> <span class="operator">=</span> (PropertyBean) enhancer.create(PropertyBean.class, <span class="keyword">new</span> <span class="title class_">ConcreteClassDispatcher</span>());</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyBean <span class="title function_">getPropertyBeanLazyLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> propertyBeanLazyLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPropertyBeanLazyLoader</span><span class="params">(PropertyBean propertyBeanLazyLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyBeanLazyLoader = propertyBeanLazyLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyBean <span class="title function_">getPropertyBeanDispatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> propertyBeanDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPropertyBeanDispatcher</span><span class="params">(PropertyBean propertyBeanDispatcher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyBeanDispatcher = propertyBeanDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LazyBean</span> <span class="variable">lazyBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazyBean</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不会触发延迟加载对象的初始化</span></span><br><span class="line">        System.out.println(lazyBean.getName() + <span class="string">&quot;: &quot;</span> + lazyBean.getAge());</span><br><span class="line">        System.out.println(lazyBean.getName() + <span class="string">&quot;: &quot;</span> + lazyBean.getAge());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只在第一次使用延迟加载对象时初始化（只第一次懒加载）</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(lazyBean.getPropertyBeanLazyLoader());</span><br><span class="line">        System.out.println(lazyBean.getPropertyBeanLazyLoader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次使用延迟加载对象时都会初始化（每次都懒加载）。现象：1、Dispatcher回调每次都执行；2、延迟加载对象的内存地址不同</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(lazyBean.getPropertyBeanDispatcher());</span><br><span class="line">        System.out.println(lazyBean.getPropertyBeanDispatcher());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zhangsan: 18</span><br><span class="line">zhangsan: 18</span><br><span class="line"></span><br><span class="line">before lazyLoader...</span><br><span class="line">after lazyLoader...</span><br><span class="line">PropertyBean [key=objectFromLazyLoader, value=java.lang.Object@58c1c010]</span><br><span class="line">PropertyBean [key=objectFromLazyLoader, value=java.lang.Object@58c1c010]</span><br><span class="line"></span><br><span class="line">before Dispatcher...</span><br><span class="line">after Dispatcher...</span><br><span class="line">PropertyBean [key=objectFromDispatcher, value=java.lang.Object@b7f23d9]</span><br><span class="line">before Dispatcher...</span><br><span class="line">after Dispatcher...</span><br><span class="line">PropertyBean [key=objectFromDispatcher, value=java.lang.Object@61d47554]</span><br></pre></td></tr></table></figure>

<h3 id="接口生成器InterfaceMaker"><a href="#接口生成器InterfaceMaker" class="headerlink" title="接口生成器InterfaceMaker"></a>接口生成器InterfaceMaker</h3><p>InterfaceMaker 会<font color="red">动态生成一个接口，该接口包含指定类定义的所有方法</font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.InterfaceMaker;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, IllegalAccessException,</span><br><span class="line">                                                  IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        <span class="type">InterfaceMaker</span> <span class="variable">interfaceMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceMaker</span>();</span><br><span class="line">        <span class="comment">// 抽取某个类的方法生成接口方法</span></span><br><span class="line">        interfaceMaker.add(UserServiceImpl.class);</span><br><span class="line">        Class&lt;?&gt; userServiceInterface = interfaceMaker.create();</span><br><span class="line">        <span class="keyword">for</span> (Method method : userServiceInterface.getMethods()) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口代理并设置代理接口方法拦截</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> Enhancer.create(Object.class, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;userServiceInterface&#125;, <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;selectPasswdById&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;filter selectPasswdById &quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;methodOne&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;filter methodOne &quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">123456</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;methodTwo&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;filter methodTwo &quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">targetMethod1</span> <span class="operator">=</span> object.getClass().getMethod(<span class="string">&quot;methodOne&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;<span class="type">int</span>.class&#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) targetMethod1.invoke(object, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">666666</span>&#125;);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">targetMethod</span> <span class="operator">=</span> object.getClass().getMethod(<span class="string">&quot;methodTwo&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) targetMethod.invoke(object, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;abc&quot;</span>&#125;);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">selectPasswdById</span><br><span class="line">methodOne</span><br><span class="line">methodTwo</span><br><span class="line"></span><br><span class="line">filter methodOne </span><br><span class="line">123456</span><br><span class="line">filter methodTwo </span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot中的AOP使用哪种代理？"><a href="#SpringBoot中的AOP使用哪种代理？" class="headerlink" title="SpringBoot中的AOP使用哪种代理？"></a>SpringBoot中的AOP使用哪种代理？</h2><p>Spring 和 SpringBoot 在动态代理的策略上是否相同，具体还要看哪个版本。</p>
<p>SpringBoot 中可以查看 <code>AopAutoConfiguration</code> 类，这个自动化配置主要是在讨论 application.properties 配置文件中的 <code>spring.aop.proxy-target-class</code> 属性的值。</p>
<p>具体起作用的是 <code>@ConditionalOnProperty</code> 注解，关于这个注解中的几个属性，松哥也来稍微说下：</p>
<ul>
<li>prefix：配置文件的前缀。</li>
<li>name：配置文件的名字，和 prefix 共同组成配置的 key。</li>
<li>havingValue：期待配置的值，如果实际的配置和 having 的值相同，则这个配置类就会生效，否则不生效。</li>
<li>matchIfMissing：如果开发者没有在 application.properties 中进行配置，那么这个配置类是否生效。</li>
</ul>
<p>基于如上介绍，我们很容易看出：</p>
<ul>
<li>如果开发者设置了 <code>spring.aop.proxy-target-class</code> 为 false，则使用 JDK 代理。</li>
<li>如果开发者设置了 <code>spring.aop.proxy-target-class</code> 为 true，则使用 Cglib 代理。</li>
<li>如果开发者一开始就没配置 <code>spring.aop.proxy-target-class</code> 属性，则使用  Cglib 代理（<strong>SpringBoot2.0</strong>）。</li>
</ul>
<p><font color="red"><strong>在 Controller 中 IUserService 的调用处打断点，DEBUG 运行一下，查看代理实例的变量信息（userService），会有大大的标志。</strong></font> </p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p>
<p><strong>1.代理模式的原理与实现</strong></p>
<p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p>
<p><strong>2.动态代理的原理与实现</strong></p>
<p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p><strong>3.代理模式的应用场景</strong></p>
<p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。</p>
<h1 id="课堂讨论"><a href="#课堂讨论" class="headerlink" title="课堂讨论"></a>课堂讨论</h1><ol>
<li>除了Java语言之外，在你熟悉的其他语言中，如何实现动态代理呢？</li>
<li>我们今天讲了两种代理模式的实现方法，<font color="red"><strong>一种是基于组合，一种基于继承，请对比一下两者的优缺点。</strong></font></li>
</ol>
<p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2022/11/47%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9C%80%E5%BF%AB%E9%80%9F%E5%9C%B0clone%E4%B8%80%E4%B8%AAHashMap%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9F/" rel="prev" title="47设计模式与范式之创建型-原型模式：如何最快速地clone一个HashMap散列表？">
                  <i class="fa fa-angle-left"></i> 47设计模式与范式之创建型-原型模式：如何最快速地clone一个HashMap散列表？
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2022/11/49%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B8%A0%E9%81%93%E7%9A%84%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F%EF%BC%9F/" rel="next" title="49设计模式与范式之结构型-桥接模式：如何实现支持不同类型和渠道的消息推送系统？">
                  49设计模式与范式之结构型-桥接模式：如何实现支持不同类型和渠道的消息推送系统？ <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
