<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="推荐链接：   分类:AJAX - 维基百科   同源策略 - 维基百科   跨域资源共享 (CORS) - 维基百科   跨站脚本 (XSS) - 维基百科   跨站请求伪造 (缩写为 CSRF 或者 XSRF) - 维基百科   内容安全策略 (CSP) - 维基百科">
<meta property="og:type" content="article">
<meta property="og:title" content="AJAX与跨域通信">
<meta property="og:url" content="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="推荐链接：   分类:AJAX - 维基百科   同源策略 - 维基百科   跨域资源共享 (CORS) - 维基百科   跨站脚本 (XSS) - 维基百科   跨站请求伪造 (缩写为 CSRF 或者 XSRF) - 维基百科   内容安全策略 (CSP) - 维基百科">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/AJAX-1.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/AJAX-2.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/image-20210323124506546.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/image-20210323125515242.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/image-20210323134806752.png">
<meta property="article:published_time" content="2019-11-25T05:59:13.000Z">
<meta property="article:modified_time" content="2019-11-25T05:59:13.000Z">
<meta property="article:author" content="zhaolq">
<meta property="article:tag" content="跨域">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/AJAX-1.png">


<link rel="canonical" href="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/","path":"article/2019/11/AJAX与跨域通信/","title":"AJAX与跨域通信"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>AJAX与跨域通信 | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">贪婪，找不到比这更好的词了，是件好事。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">1.</span> <span class="nav-text">异步请求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#XMLHttpRequest"><span class="nav-number">1.1.</span> <span class="nav-text">XMLHttpRequest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AJAX"><span class="nav-number">1.2.</span> <span class="nav-text">AJAX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios-js"><span class="nav-number">1.3.</span> <span class="nav-text">axios-js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fetch-API"><span class="nav-number">1.4.</span> <span class="nav-text">Fetch API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AJAX-%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">2.</span> <span class="nav-text">AJAX 与同源策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AJAX-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">AJAX 解决了什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XMLHttpRequest-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.</span> <span class="nav-text">XMLHttpRequest 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AJAX-%E8%AF%B7%E6%B1%82"><span class="nav-number">2.3.</span> <span class="nav-text">AJAX 请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-XML-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="nav-number">2.3.1.</span> <span class="nav-text">创建 XML 对象的实例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E8%AF%B7%E6%B1%82"><span class="nav-number">2.3.2.</span> <span class="nav-text">准备请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="nav-number">2.3.3.</span> <span class="nav-text">设置请求头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-number">2.3.4.</span> <span class="nav-text">发送请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94"><span class="nav-number">2.3.5.</span> <span class="nav-text">处理响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">2.3.6.</span> <span class="nav-text">取消异步请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XMLHttpRequest-2-%E7%BA%A7"><span class="nav-number">2.4.</span> <span class="nav-text">XMLHttpRequest 2 级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FormData"><span class="nav-number">2.4.1.</span> <span class="nav-text">FormData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E8%AE%BE%E5%AE%9A"><span class="nav-number">2.4.2.</span> <span class="nav-text">超时设定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overrideMimeType-%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.3.</span> <span class="nav-text">overrideMimeType() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.4.4.</span> <span class="nav-text">进度事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">2.5.</span> <span class="nav-text">同源策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90"><span class="nav-number">2.5.1.</span> <span class="nav-text">源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="nav-number">2.5.2.</span> <span class="nav-text">特定操作：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1"><span class="nav-number">2.6.</span> <span class="nav-text">跨域通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.</span> <span class="nav-text">跨域解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JSONP"><span class="nav-number">3.1.</span> <span class="nav-text">JSONP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CORS"><span class="nav-number">3.2.</span> <span class="nav-text">CORS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="nav-number">3.2.1.</span> <span class="nav-text">简单请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="nav-number">3.2.2.</span> <span class="nav-text">非简单请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F-Ping"><span class="nav-number">3.3.</span> <span class="nav-text">图像 Ping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#document-domain"><span class="nav-number">3.4.</span> <span class="nav-text">document.domain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#window-name"><span class="nav-number">3.5.</span> <span class="nav-text">window.name</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#postMessage"><span class="nav-number">3.6.</span> <span class="nav-text">postMessage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#location-hash"><span class="nav-number">3.7.</span> <span class="nav-text">location.hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket"><span class="nav-number">3.8.</span> <span class="nav-text">WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B-WebSocket-%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.8.1.</span> <span class="nav-text">建立 WebSocket 连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82"><span class="nav-number">3.8.2.</span> <span class="nav-text">发起请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">3.9.</span> <span class="nav-text">Nginx 反向代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nodejs-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="nav-number">3.10.</span> <span class="nav-text">Nodejs 中间件代理</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">554</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="AJAX与跨域通信 | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AJAX与跨域通信
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-25 13:59:13" itemprop="dateCreated datePublished" datetime="2019-11-25T13:59:13+08:00">2019-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%B7%A8%E5%9F%9F/" itemprop="url" rel="index"><span itemprop="name">跨域</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><font color="blue"><strong>推荐链接：</strong></font> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Category:AJAX">分类:AJAX - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">同源策略 - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E4%BA%AB">跨域资源共享 (<strong>CORS</strong>) - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">跨站脚本 (<strong>XSS</strong>) - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">跨站请求伪造 (缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>) - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5">内容安全策略 (<strong>CSP</strong>) - 维基百科</a> </p>
<span id="more"></span>

<p> <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰</a> </p>
<p> <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015597029">不要再问我跨域的问题了</a> </p>
<p> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略 - MDN Web Docs</a> </p>
<p> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享(CORS) - MDN Web Docs</a> </p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247494788&idx=2&sn=7759a32c023fb8a452bb100b3044d61f">SpringBoot 解决跨域，3种解决方案！</a> </p>
<h1 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h1><p> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests">同步和异步请求 - MDN Web Docs</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiqinl/p/11279950.html">异步请求xhr、ajax、axios与fetch的区别比较</a> </p>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/XMLHttpRequest">XMLHttpRequest - 维基百科</a> </p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/AJAX">AJAX - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/ajax/ajax-tutorial.html">AJAX 教程 - 菜鸟教程</a> </p>
<h2 id="axios-js"><a href="#axios-js" class="headerlink" title="axios-js"></a>axios-js</h2><p> <a target="_blank" rel="noopener" href="http://www.axios-js.com/">http://www.axios-js.com/</a> </p>
<p> <a target="_blank" rel="noopener" href="https://github.com/axios/axios">https://github.com/axios/axios</a> </p>
<h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><p> <a target="_blank" rel="noopener" href="https://bkso.baidu.com/item/Fetch/20173436">Fetch (网页开发技术) - 百度百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://github.com/github/fetch">https://github.com/github/fetch</a> </p>
<p> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">1、Fetch API - MDN Web Docs</a> </p>
<p> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">2、使用 Fetch - MDN Web Docs</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.w3cschool.cn/fetch_api/">Fetch API官方文档 - w3cschool</a> </p>
<p> <a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/187527.html">Fetch API - 阿里云</a> </p>
<p> <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">Fetch API 教程 - 阮一峰</a> </p>
<h1 id="AJAX-与同源策略"><a href="#AJAX-与同源策略" class="headerlink" title="AJAX 与同源策略"></a>AJAX 与同源策略</h1><h2 id="AJAX-解决了什么问题？"><a href="#AJAX-解决了什么问题？" class="headerlink" title="AJAX 解决了什么问题？"></a>AJAX 解决了什么问题？</h2><p>在远古时代，如果浏览器需要从服务器请求资源，其交互模式为 “客户端发出请求 -&gt; 服务端接收请求并返回相应 HTML 文档 -&gt; 页面刷新，客户端加载新的 HTML文档”，很显然，在这种情况下，即使只是为了更新部分数据，我们也不得不重新加载整个重绘的页面。而 AJAX 的出现解决了这个问题。</p>
<p>AJAX 即异步 JavaScript 和 XML，它可以在不重新加载整个网页的情况下，对网页的某部分进行异步更新。</p>
<h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p>AJAX 的核心实现依靠的是浏览器提供的 <code>XMLHttpRequest</code> 对象。可以看作是一个构造函数，由此我们可以通过 <code>const xhr = new XMLHttpRequest()</code> 创建一个 XML 对象的实例，该实例有以下方法：</p>
<ul>
<li><code>open()</code>：准备启动一个 AJAX 请求；</li>
<li><code>setRequestHeader()</code>：设置请求头部信息；</li>
<li><code>send()</code>：发送 AJAX 请求；</li>
<li><code>getResponseHeader()</code>: 获得响应头部信息；</li>
<li><code>getAllResponseHeader()</code>：获得一个包含所有头部信息的长字符串；</li>
<li><code>abort()</code>：取消异步请求；</li>
</ul>
<p>以及以下属性：</p>
<ul>
<li><code>responseText</code>：包含响应主体返回文本；</li>
<li><code>responseXML</code>：如果响应的内容类型是 text&#x2F;xml 或 application&#x2F;xml，该属性将保存包含着相应数据的 XML DOM文档；</li>
<li><code>status</code>：响应的 HTTP 状态；</li>
<li><code>statusText</code>：HTTP 状态的说明；</li>
<li><code>readyState</code>：表示“请求”&#x2F;“响应”过程的当前活动阶段</li>
</ul>
<h2 id="AJAX-请求"><a href="#AJAX-请求" class="headerlink" title="AJAX 请求"></a>AJAX 请求</h2><h3 id="创建-XML-对象的实例："><a href="#创建-XML-对象的实例：" class="headerlink" title="创建 XML 对象的实例："></a>创建 XML 对象的实例：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>

<h3 id="准备请求"><a href="#准备请求" class="headerlink" title="准备请求"></a>准备请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;demo.php?name=Sam&amp;job=coder&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>open()</code> 方法接收三个参数：请求方式，请求 URL 地址和是否为异步请求的布尔值。</p>
<ul>
<li>请求方式：有 GET 和 POST 两种，GET 请求用于向服务器拿取数据，我们可以像示例代码中那样给 URL 加上查询参数，即 <code>?name=Sam&amp;job=coder</code>，表示要查询的特定资源；POST 请求用于向服务器发送要保存的数据，数据存放的位置通过 <code>send()</code> 方法的参数来指定。那么，对于 GET 请求，<code>send()</code> 方法是否可以不传递参数呢？——不可以，应该传递 <code>null</code>。</li>
<li>请求 URL：可以是相对路径和绝对路径</li>
<li>是否为异步请求：true 为异步，false 为同步。</li>
</ul>
<h3 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Header&#x27;</span>,<span class="string">&#x27;Value&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>每个 HTTP 请求和响应都会带有相应的头部信息，包含一些与数据、收发者网络环境与状态等相关信息。<br>默认情况下，当发送 AJAX 请求时，会附带以下头部信息：</p>
<ul>
<li>Accept：浏览器能够处理的内容类型；</li>
<li>Accept-Charset: 浏览器能够显示的字符集；</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码；</li>
<li>Accept-Language：浏览器当前设置的语言；</li>
<li>Connection：浏览器与服务器之间连接的类型；</li>
<li>Cookie：当前页面设置的任何Cookie；</li>
<li>Host：发出请求的页面所在的域；<font color="blue"> <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1467299">host、referer和origin的区别</a> </font> </li>
<li>Referer：发出请求的页面URI；</li>
<li>User-Agent：浏览器的用户代理字符串；</li>
</ul>
<p>另外，我们还可以通过 <code>setRequestHeader()</code> 方法来设置请求头信息。该函数接受两个参数：头部字段（部分默认的或者自定义的）的名称和头部字段的值。</p>
<p>这个方法要在 <code>open()</code> 和 <code>send()</code> 之间调用</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line">xhr.<span class="title function_">send</span>(data_holder)</span><br></pre></td></tr></table></figure>

<h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><p>目前为止，我们只是发送了请求，还没有针对服务器的响应结果做出一些处理。比方说，响应成功了怎么怎么样，响应失败了怎么怎么样。但是怎么知道是成功还是失败呢？这里就用到前面讲过的 <code>xhr.status</code> 属性，状态码可分为五大类：</p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP状态码 - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-status-codes.html">HTTP状态码 - 菜鸟教程</a> </p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>信息提示</td>
</tr>
<tr>
<td>2XX</td>
<td>成功</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p>那么，根据 <code>xhr.status</code> 这个响应结果，我们就可以进行相应处理了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写对于同步请求（我们前面设置 <code>open()</code> 时第三个参数是 false）来说当然没问题 —— 因为是同步的，所以一定是 send 之后，服务器那边响应结果了才会继续执行后面判断 status 的代码，那么不管请求成功还是失败，这个判断一定是可以被正常执行的。但是如果是异步请求呢？对于异步请求，不需要等待服务器响应结果我们就可以执行后面的判断了，甚至可能出现一种情况是：服务器还没来得及响应结果，判断已经先执行了。那么这时候，请求一定会失败。</p>
<p>也就是说，我们需要加一层判断，确保收到服务器的响应结果之后，再去判断请求成功还是失败。这里就用到前面讲过的 <code>xhr.readyState</code> 属性，readyState 会随着 AJAX 的进程而不断变化，我们可以通过 <code>onreadystatechange()</code> 去监听它的变化，进而判断何时收到服务器的响应结果。</p>
<p>readyState 可取值有：</p>
<table>
<thead>
<tr>
<th>状态值</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>未初始化</td>
<td>尚未调用 <code>open()</code> 方法</td>
</tr>
<tr>
<td>1</td>
<td>启动</td>
<td>已经调用 <code>open()</code> 方法，但尚未调用 <code>send()</code> 方法</td>
</tr>
<tr>
<td>2</td>
<td>发送</td>
<td>已经调用 <code>send()</code> 方法，但尚未接收到响应</td>
</tr>
<tr>
<td>3</td>
<td>接受</td>
<td>已经接收到部分响应数据</td>
</tr>
<tr>
<td>4</td>
<td>完成</td>
<td>已经接收到全部响应数据，而且已经可以在客户端使用了</td>
</tr>
</tbody></table>
<p>那么，前面的代码就变成了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readystate</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消异步请求"><a href="#取消异步请求" class="headerlink" title="取消异步请求"></a>取消异步请求</h3><p>设想这么一种情况：我们正在上传一张图片（也就是发送一个 AJAX 请求），由于耗时过长，我们决定取消上传，那么取消上传其实就是取消 AJAX 请求，这是通过 <code>abort()</code> 方法实现的。一旦调用这个方法，xhr 就会停止触发事件，而且也不再允许访问任何与响应相关的对象属性。在终止请求之后，不要忘了对 xhr 对象解引用。</p>
<p>正常上传：</p>
<p><img src="/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/AJAX-1.png" alt="img"></p>
<p>取消上传：</p>
<p><img src="/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/AJAX-2.png" alt="img"></p>
<h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><p>通常提交表单数据的时候，这些数据需要经过序列化，虽然 <code>$(&#39;#form&#39;).serialize()</code> 可以实现序列化，但对于文件流无能为力。而 <code>FormData</code> 不仅可以做到表单序列化，而且支持异步上传二进制文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Sam&#x27;</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>(<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h3><p>为 <code>xhr.timeout</code> 指定一个毫秒为单位的时间，一旦浏览器在这个规定的时间内没有收到响应，就会触发 <code>timeout</code> 事件，执行回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;<span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful:&quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;timeout.php&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">1000</span>;</span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Request did not return in a second&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>注意：这时候很可能出现一种情况，就是超过1秒后浏览器没收到响应，因此终止了请求，而这时候恰好 <code>xhr.status</code> 为4，因此又调用函数进行判断，这个判断需要访问 <code>xhr.status</code> 属性，而请求已经被终止，这个属性是无法访问的，此时要用 <code>try...catch...</code> 捕获这个错误。</p>
<h3 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType() 方法"></a>overrideMimeType() 方法</h3><p>服务器返回的响应头中有一个是 <code>Content-Type</code>，用以告诉客户端返回的资源类型（MIME）以及应该用什么编码去解码。例如 <code>Content-Type:text/html;charset=UTF-8</code>，那么客户端就会通过 UTF-8 对资源进行解码，然后对资源进行 HTML 解析。<br>但可能存在一种情况：虽然服务器返回数据是 XML，但 MIME 类型指定为 <code>text/plain</code>，那么这时候客户端就会当作纯文本去处理了，这显然不对，所以我们可以利用 <code>overrideMineType()</code> 方法重写响应的 MIME 类型，这样，客户端就可以将其当作 XML 去处理了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;text.php&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">overrideMineType</span>(<span class="string">&#x27;text/xml&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>注意，必须在 send 调用之前重写。</p>
<h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><p>Progress Events规范规范定义了与客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以<strong>更细的颗粒度</strong>掌控数据传输过程中的细节。有以下6个进度事件：</p>
<ul>
<li><p>loadstart：在接受到响应数据的第一个字节时触发</p>
</li>
<li><p>progress：在接受响应期间持续不断地触发</p>
</li>
<li><p>error：在请求错误时触发</p>
</li>
<li><p>abort：在因为调用 <code>abort()</code> 方法而终止连接时触发</p>
</li>
<li><p>load：在接收到完整的响应数据时触发</p>
</li>
<li><p>loadend：在通信完成或触发 error、abort、load 事件后触发</p>
<p>每个请求都从触发 loadstart 事件开始，接下来是一或多个 progress 事件，然后触发 error、abort 或 load 中的一个，最后以触发 loadend 事件结束。</p>
</li>
</ul>
<p>有没有发现，前面的 <code>xhr.readyState == 4</code> 以及这里的 <code>load</code> 事件都可以判断是否接受到完整响应？ <code>load</code> 事件实际上简化了这个过程，它不需要像前者那样，既绑定一个监听函数又做一次 <code>readyState</code> 的判断，而只需要绑定监听函数即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote>
<p>浏览器的同源策略即 Same-Origin Policy （SOP），它限制了不同源之间执行特定操作。</p>
</blockquote>
<h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><p>一个源由<strong>协议</strong>、<strong>端口</strong>、<strong>域名</strong>组成，只要有一个不同，就认为是不同源。</p>
<p>以 <a target="_blank" rel="noopener" href="http://test.com/dist/demo.html">http://test.com/dist/demo.html</a> 为例，不同源以及同源可能有以下情况：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>URL</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>不同协议</td>
<td><a target="_blank" rel="noopener" href="https://test.com/dist/demo.html">https://test.com/dist/demo.html</a></td>
<td>失败</td>
</tr>
<tr>
<td>不同端口</td>
<td><a target="_blank" rel="noopener" href="http://test.com/dist/demo.html">http://test.com:80/dist/demo.html</a></td>
<td>失败</td>
</tr>
<tr>
<td>不同域名</td>
<td><a target="_blank" rel="noopener" href="http://test.cn/dist/demo.html">http://test.cn/dist/demo.html</a> 或者 <a target="_blank" rel="noopener" href="http://www.test.com/dist/demo.html">http://www.test.com/dist/demo.html</a></td>
<td>失败</td>
</tr>
<tr>
<td>不同路径</td>
<td><a target="_blank" rel="noopener" href="http://test.com/dist2/demo.html">http://test.com/dist2/demo.html</a></td>
<td>成功</td>
</tr>
</tbody></table>
<h3 id="特定操作："><a href="#特定操作：" class="headerlink" title="特定操作："></a><font color="red">特定操作：</font></h3><p>特定操作指的是：</p>
<ul>
<li>读取 Cookie、LocalStorage、IndexDB</li>
<li>获取 DOM 元素</li>
<li>发送 AJAX 请求</li>
</ul>
<p>为什么同源策略要禁止不同源之间进行这些操作呢？我们不妨假设一下，不存在同源策略、且不同源之间这些操作是允许的，看看可能会发生什么事。</p>
<ul>
<li>我A源可以读取B源的 Cookie、LocalStorage、IndexDB，那么等于B源存储的信息都暴露了，所以同源策略禁止不同源之间读取 Cookie、LocalStorage、IndexDB；</li>
<li>A源可以获取B源的 DOM 元素。那么假定用户访问了我在A源中用 iframe 引入的B源网页，他的所有操作都会在我们的掌握之中，因为我们可以在A源操作B源的 DOM 元素；</li>
<li>A 源可以自由发送 AJAX 请求给B源。假定现在有一个用户首先登录了 <a target="_blank" rel="noopener" href="https://chorer.github.io/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/">Bank.com</a>，那么本地客户端的 Cookie 就会记录用户在该网站的身份信息，之后用户不小心点进了危险网站 <a target="_blank" rel="noopener" href="https://chorer.github.io/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/">Evil.com</a>，这个网站做了一些设置，一旦用户进入，就自动发送 AJAX 请求给 <a target="_blank" rel="noopener" href="https://chorer.github.io/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/">Bank.com</a>，由于发送请求的时候，浏览器会自动在本地检索目标网站的 Cookie ，并添加到请求报文中，所以此时目标网站的 Cookie 被请求携带着发送过去了，而 <a target="_blank" rel="noopener" href="https://chorer.github.io/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/">Bank.com</a> 的响应头又是携带着 Cookie 返回的，那么这时候等于 <a target="_blank" rel="noopener" href="https://chorer.github.io/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/">Evil.com</a> 已经拿到了这个 Cookie。也就是说，发送请求前它确实拿不到这个 Cookie（是浏览器给请求报文加上的，不是我们），但接受到响应后它的的确确拿到了，于是事情一发不可收拾……</li>
</ul>
<h2 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h2><p>这样看来，同源策略确实很有存在的必要，不然网络安全无从谈起。等等，既然有同源策略的限制，那我A域怎么去请求B域中的资源呢？也就是说，要怎么解决跨域通信的问题呢？</p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p>常见的几种跨域方案：</p>
<p><code>JSONP</code>、<code>CORS</code>、<code>图像Ping</code>、<code>document.domain</code>、<code>window.name</code>；</p>
<p><code>postMessage</code>、<code>location.hash</code>、<code>WebSocket</code>、<code>Nginx 反向代理</code>、<code>Nodejs 中间件代理</code>；</p>
<p>开始之前，要先清楚一件事：</p>
<blockquote>
<p>跨域不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。</p>
</blockquote>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><code>&lt;link&gt;</code> 获取 CSS，<code>&lt;script&gt;</code> 获取 JS，<code>&lt;img&gt;</code> 获取图片，这些<font color="blue">明明也是跨域获取资源，为什么不会被禁止呢？</font>很简单，因为这些<font color="blue">都不属于上述特定操作之一</font>，这里请求资源压根没用到 AJAX 请求。再看看我们的需求，我们现在是要在 A 域中获取 B 域资源，那么我完全可以在 A 域中动态创建一个 <code>script</code> 并请求 B 域资源，然后，因为 A 域中的 js 和 <code>scirpt</code> 中的 js 是在同一个作用域中的，所以要在 A 域中展示 B 域的数据也完全不成问题。虽然说法比较简陋，但这就是 JSONP 的原理。下面我们来看看具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.动态创建 script </span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://test.com/json?callback=handleResponse&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(script,<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br></pre></td></tr></table></figure>

<p>首先是客户端的角度，这段代码声明了一个用以接受数据的回调函数，之后动态创建了 <code>script</code> ，执行完毕之后来到 <code>body</code>，这时候遇到语句 <code>&lt;script src=&#39;http://test.com/json?callback=handleResponse&#39;&gt;&lt;/script&gt;</code> ，此时会向服务器发起一次资源请求；然后来到服务端的角度，服务端解析上述的 url，得到查询参数 callback 的值是 handleResponse，此时会生成一个对应的函数执行语句，也就是 <code>handleResponse(data)</code>，这个语句返回给了客户端这边，客户端执行该语句（因为当前作用域确实声明了这个 handleResponse 函数），打印相关数据。这样就算完成一次跨域请求了。</p>
<p>JSONP 使用起来虽然很简单，但是有如下缺点：</p>
<ul>
<li>无法发送 POST 请求</li>
<li>安全问题。万一服务端那边夹带恶意代码返回过来，那么客户端这边是会直接执行的，因此有安全隐患</li>
<li>无法监测 JSONP 请求是否成功或失败</li>
</ul>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><blockquote>
<p>CORS 即 Cross-origin resource sharing，跨域资源共享 ，是由 W3C 官方推广的允许通过 AJAX 技术跨域获取资源的规范 。</p>
</blockquote>
<p>CORS 的关键在于服务端，也就是客户端这边发送请求，服务端那边做一些<strong>判断</strong>（请求方是否在自己的“白名单”里？），如果没问题就返回数据，否则拒绝。</p>
<p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要<strong>同时满足</strong>以下两大条件，就属于简单请求：</p>
<ul>
<li>请求方法只属于 <strong>HEAD</strong>，<strong>GET</strong>，<strong>POST</strong> 请求的其中一种；</li>
<li>HTTP的头信息只限于以下字段：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type（只能为 <code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code> 和 <code>text/plain</code> 其中一种）</li>
</ul>
</li>
</ul>
<p>凡不同时满足以上两大条件的，都属于非简单请求。</p>
<p>下面我们看一下针对这两种请求，CORS 是怎么处理。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>首先是客户端的角度，发送请求时浏览器检测到这是一个简单请求，因此在请求头额外增加一个 <code>Origin</code>，它的值是请求代码所在的源，例如 <code>http://test.com</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//test.com</span></span><br><span class="line"><span class="title class_">Host</span>: target.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span> ...</span><br></pre></td></tr></table></figure>

<p>然后是服务端的角度，服务端收到请求，首先检测请求报头的 <code>Origin</code> 是否在自己的许可范围内，</p>
<p>如果确实是许可的域，那么待会响应的时候，响应头会额外增加如下字段：</p>
<ul>
<li><strong>Access-Control-Allow-Origin</strong>（必选） ：这个字段用来告知客户端，服务端能够接受的发送 AJAX 请求的域，因为此次请求得到许可，所以这里返回与先前请求报头中 <code>Origin</code> 匹配的 <code>http://test.com</code>。当然，也可以返回 <code>*</code>，表示接受任何域的 AJAX 请求（<code>*</code> 是通配的意思）。</li>
<li><strong>Access-Control-Allow-Credentials</strong> （可选）：告知浏览器，是否允许客户端发送请求的时候携带 Cookie，true 表示允许，false 表示禁止，出于安全问题考虑（前面说过），CORS 默认不允许跨域 AJAX 请求携带 Cookie。</li>
<li><strong>Access-Control-Expose-Headers</strong>（可选）：该字段用来向客户端暴露可获取的响应头。默认情况下，xhr 的 <code>getResponseHeader()</code> 方法只能拿到 6 个基本响应头字段，如果还想额外拿到其它字段，那么前端要和后端商量好，让后端在 <code>Access-Control-Expose-Headers</code> 指定好前端可以通过该方法获取的额外响应头字段。</li>
</ul>
<p>如果不是许可的域，那么这时候其实压根不会返回 <code>Access-Control-Allow-Origin</code> 这个响应头，而浏览器会捕获这次错误，如下图所示：</p>
<p><img src="/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/image-20210323124506546.png" alt="image-20210323124506546"></p>
<p>PS：虽然禁止跨域 AJAX 请求携带 Cookie 是为了安全考虑，但由于它在身份验证中的重要性，我们有时候还是得携带 Cookie 的。 具体方法是：</p>
<ul>
<li>客户端配置 <code>withCredentials</code> 属性：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>服务端配置 <code>Access-Control-Allow-Credential</code> 为 true，配置 <code>Access-Control-Allow-Origin</code> 为指定的域（而不是 <code>*</code>），</li>
</ul>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求包括两次请求，第一次请求是 <font color="red">preflight request</font>，也就是<font color="red">预检&#x2F;查询请求</font>，这次请求试探性地“询问”服务端，自己打算进行的非简单请求是否合法 —— 不管是否合法，服务端都会通过某种方式通知客户端，客户端基于这个结果，判断是否进行第二次真正的请求。</p>
<p>预检请求是这样的：</p>
<p>首先是客户端的角度，发送请求时浏览器检测到这是一个非简单请求，所以事先向服务端发送一个预检请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">OPTIONS</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//test.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: <span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: <span class="title class_">Custom</span>-<span class="title class_">Header1</span>,<span class="title class_">Custom</span>-<span class="title class_">Header2</span></span><br><span class="line"><span class="title class_">Host</span>: target.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，这里这个预检请求的类型是 <strong>OPTIONS</strong> 。</li>
<li>像之前的简单请求一样，这里浏览器会追加一个 <code>Origin</code>，表示请求代码所在的源</li>
<li>前面我们说过，非简单请求会多出额外的请求头字段，这里多出来的就是 <code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> ，这其实是告诉服务端，“我待会要进行的真正请求，类型是这里 <code>Access-Control-Request-Headers</code> 指定的类型，然后自定义请求头是这里 <code>Access-Control-Request-Headers</code> 指定的值，你看看行不行，给我个回应“。</li>
</ul>
<p>好了，我们来看看服务器作何反应。来到服务端的角度，服务端收到这个请求，它会检测请求头中的信息，发现这个请求是合法的、没啥毛病，“好，我同意你的第二次请求”，不过光说不行，得在返回的响应头中告诉客户端这一点，此时响应头是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Mon</span>, <span class="number">01</span> <span class="title class_">Dec</span> <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">Server</span>: <span class="title class_">Apache</span>/<span class="number">2.0</span><span class="number">.61</span>（<span class="title class_">Unix</span>）</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//test.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>, <span class="variable constant_">POST</span>, <span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: <span class="title class_">Custom</span>-<span class="title class_">Header1</span>,<span class="title class_">Custom</span>-<span class="title class_">Header2</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: <span class="number">1728000</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">type</span>: text/html; charset=utf-<span class="number">8</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Encoding</span>: gzip</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Keep</span>-<span class="title class_">Alive</span>: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Keep</span>-<span class="title class_">Alive</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/plain</span><br></pre></td></tr></table></figure>

<ul>
<li>Access-Control-Allow-Origin：这里和之前一样，可以是 <a target="_blank" rel="noopener" href="http://test.com/">http://test.com</a> 或者 <code>*</code>，也就是告诉客户端，“我给你的域下了许可证“</li>
<li>Access-Control-Allow-Methods：这里告诉客户端，服务端允许的跨域 AJAX 请求的类型，”虽然你刚才告诉我你准备进行的是 PUT 请求，不过你要进行 GET 或者 POST 请求，我也是允许的“</li>
<li>Access-Control-Allow-Headers：这里告诉客户端，服务端允许的发送请求时的自定义请求头</li>
<li>Access-Control-Max-Age: 这里告诉客户端预检请求的有效期，省去了多次的预检请求。也就是说，”我给你开个后门，1728000 秒内（20天内）你可以直接发送真正的 AJAX 请求，不用每次都来问我了“</li>
</ul>
<p>再回到客户端这边，客户端收到响应，知道服务端允许了自己的请求，于是进行第二次真正的 AJAX 跨域请求。此后每次 <font color="red">CORS 请求</font> 都相当于一次简单请求了。</p>
<p>但是，如果发现客户端<font color="red">请求不合法</font>，那么<font color="red">服务端</font>虽然会返回<font color="red">正常响应</font>，<font color="red">但不会返回 CORS 相关的响应头</font>，而客户端这边”心领神会“，知道被拒绝了，所以由 xhr 对象捕获这个错误，如下图所示：</p>
<p><img src="/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/image-20210323125515242.png" alt="image-20210323125515242"></p>
<p>我们可以来解读一下这个报错：上图的 Response to preflight request 就是服务端对于预检请求的响应，这个响应返回到客户端之后，客户端进行一次 access control check，也就是检查这个响应是否有标志着服务端同意的响应头，因为 No ‘Access-Control-Allow-Origin’ header is present on the requested resource，也就是说我客户端这边并没有检查到服务端本应提供的 Access-Control-Allow-Origin 响应头，所以最终 doesn’t pass access control check，也就是没有通过这次检查。</p>
<h2 id="图像-Ping"><a href="#图像-Ping" class="headerlink" title="图像 Ping"></a>图像 Ping</h2><ul>
<li>图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式，请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，通常是像素图和 204 响应。浏览器虽然得不到任何具体数据，但由于可以监听 load 和 error 事件，所以能知道响应是什么时候接受到的。</li>
<li>图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数</li>
<li>缺点：单向通信，只支持 GET 请求；无法访问服务器的响应文本</li>
</ul>
<h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>介绍 document.domain 跨域之前，先解释一下域名的一些概念。</p>
<ul>
<li>顶级域名：诸如 .com、.cn、.net、.org 等都是顶级域名，也叫一级域名</li>
<li>二级域名：诸如 baidu.com、zhihu.com、mdn.org 等</li>
<li>父域名、子域名：这是相对的概念，诸如 .com 是 tool.com 的父域名，而 tool.com 的子域名是 editor.tool.com，editor.tool.com 的子域名是 <a target="_blank" rel="noopener" href="http://www.editor.tool.com/">www.editor.tool.com</a></li>
</ul>
<p>document.domain 适用于<strong>主域相同、子域不同</strong>的两个域之间的跨域通信。假设我现在有一个A域为 <a target="_blank" rel="noopener" href="http://www.test.com/a.html">http://www.test.com/a.html</a> ，另一个B域为 <a target="_blank" rel="noopener" href="http://test.com/b.html">http://test.com/b.html</a> ，因为是不同源的（域名不相同），所以我不能在A域中拿到B域的东西，但是呢，我们注意到这两个域的主域是相同的，只是子域不同而已，所以我们可以用 document.domain 的方法实现跨域，具体来说，就是重新设置两个页面的 document.domain 为一个相同的值。</p>
<p>但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成<strong>自身或更高一级的父域，且主域必须始终保持相同</strong>。例如：a.b.test.com 中某个文档的 document.domain 可以设成a.b.test.com（自身）、b.test.com（上一级父域） 、test.com（上上一级父域）中的任意一个，但是不可以设成 c.a.b.test.com（下一级子域），因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了，这里的主域必须始终保持为 test.com 不变。</p>
<p>来看代码：</p>
<p>A域 <a target="_blank" rel="noopener" href="http://www.test.com/a.html">http://www.test.com/a.html</a> ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot; http://test.com/b.html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;test.com&#x27;</span>; <span class="comment">// 设置成主域</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>).<span class="property">contentWindow</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>B域 <a target="_blank" rel="noopener" href="http://test.com/b.html">http://test.com/b.html</a> ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;test.com&#x27;</span>; <span class="comment">// 虽然本来就是 test.com，但还是要显式设置一次</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后，我们就<font color="red">可以在 A 域中拿到 B 域的东西</font>了。注意，尽管这时候 document.domain 是一样的，但两个域之间只是可以交互而已，<font color="red">仍然不能发送 AJAX 请求</font>。</p>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>首先要明白一件事 —— window 对象有个 name 属性，在一个窗口的生命周期内，<code>window.name</code> 会被该窗口的所有页面所共享、所读写，不管这些页面是同源还是不同源。</p>
<p>那么，我们岂不是可以把数据放在 <code>window.name</code> 里，然后通过页面跳转把这些数据拿到自己这边来？有道理，不过每次要拿数据就得跳转页面，好像有点麻烦，不妨我们把这个页面跳转的过程放在 <code>iframe</code> 里进行。假定请求数据的页面是 a.html，存放数据的页面是 c.html，那么我们在 a.html 中通过 <code>iframe</code> 加载 c.html，这时候数据已经存放在 <code>iframe</code> 这个窗口的 <code>window.name</code> 里了，之后我们让其跳转到与 a.html 同源的 b.html，根据前面说的，<code>window.name</code> 仍然是被保留的、可访问的，那么 <code>window.name</code> 由 c 传递到了 b，并且由于此时 a.html、b.html 同源，所以 <code>window.name</code> 又可经由 b 传递给 a。</p>
<p>下面说说代码实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">name</span> = 我是要传递的 json 数据;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    我只是一个中转站</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> isFirst = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">iframe.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3001/c.html&#x27;</span>; </span></span><br><span class="line"><span class="language-javascript">iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//监听 iframe 的两次加载</span></span></span><br><span class="line"><span class="language-javascript">iframe.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(isFirst)&#123;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        isFirst = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        p.<span class="property">innerHTML</span> = iframe.<span class="property">contentWindow</span>.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 销毁iframe</span></span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">contentWindow</span>.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">src</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        iframe = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里动态创建了 <code>iframe</code>，并指定第一次加载的 <code>iframe</code> 是 c.html，一旦加载好（很显然这时候 <code>window.name</code> 的值已经记录在这个窗口里了），就执行回调函数，通过修改 src 让页面跳转到 b.html（这时候 <code>window.name</code> 的值传递给了 b.html），第二次触发执行回调函数，将最初的数据传递给 a.html。</p>
<p>注意两个地方：</p>
<ul>
<li>由于整个过程是悄悄进行的，我们给 <code>iframe</code> 设置 <code>display:none</code></li>
<li>拿到数据后记得销毁 <code>iframe</code>，防止内存泄露</li>
</ul>
<p>上面的写法不需要重写 onload 回调函数，只用一个 flag 标识第一和第二次加载；我们也可以采用下面的方法重写 onload 回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iframe.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        p.<span class="property">innerHTML</span> = iframe.<span class="property">contentWindow</span>.<span class="property">name</span>;</span><br><span class="line">        iframe.<span class="property">contentWindow</span>.<span class="title function_">close</span>();</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(iframe);</span><br><span class="line">        iframe.<span class="property">src</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        iframe = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iframe.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>HTML5 提供了 <code>postMessage</code> 和 <code>onmessage</code> 两个 api 用于在跨域站点页面之间进行通信。</p>
<p>假设A域要向B域发送消息，那么：</p>
<ul>
<li>一方面，我们在A域页面中通过 <code>iframe</code> 引入B域，之后用B域的 window 对象调用 <code>postMessage</code>方法（谁接受消息，谁就去调用）。这个方法接受两个参数，第一个参数是发送的消息， 它可以是任何类型的数据，但部分浏览器只支持字符串格式；第二个参数是可以接受消息的域，如果不想限定某个域（比如B）去接受消息，那么可以传 <code>*</code>。</li>
<li>另一方面，B域监听 <code>message</code> 事件，一旦接收到消息就调用某个函数接受数据。<code>message</code> 事件的事件对象有三个属性，<code>event.data</code> 表示接受到的数据，<code>event.origin</code> 为消息发送方的源，<code>event.source</code> 为消息发送方的窗口对象的引用。</li>
</ul>
<p>B域接收到了消息，要通知A域，其实就是上面的过程反过来。</p>
<p>B域要向A域发送消息，那么：</p>
<ul>
<li>一方面，B 域的 <code>window.parent</code> 可以访问父级（A域）窗口对象，我们在B域里通过该对象调用 <code>postMessage</code> 方法，发送通知给A域</li>
<li>另一方面，A域监听 <code>message</code> 事件，收到B域通知，进行相应处理</li>
</ul>
<p>核心代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http://test.com/a.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://anothertest.com/b.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myIframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;我是数据&#x27;</span>,<span class="string">&#x27;http://anothertest.com/b.html&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我收到的B域通知是:&#x27;</span>+ event.<span class="property">data</span>); <span class="comment">// 我收到的B域通知是:B域收到A域的消息了，通知你一声</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http://anothertest.com/b.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我接受到的消息是:&#x27;</span>+event.<span class="property">data</span>); <span class="comment">//我接受到的消息是:我是数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送消息的源是:&#x27;</span>+event.<span class="property">origin</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送消息的窗口对象是:&#x27;</span>+event.<span class="property">source</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;B域收到A域的消息了，通知你一声&#x27;</span>,<span class="string">&#x27;http://test.com/a.html&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么这就是简单的<strong>跨域窗口间通信</strong>了，不过这只是客户端层面上的，如果A域的客户端要发送 AJAX 请求给B域服务端呢？只要稍微改进上面的方法就可以，也就是说，B域客户端充当一个中转站，A 域客户端先通过上面的方法把数据发送给B域客户端，B域客户端再把数据转发给B域服务端（这两个是同源的，直接发送 AJAX 请求）；然后，反过来也一样，B域返回的数据经由B域客户端交给A域客户端。</p>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http://anothertest.com/b.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> url = <span class="string">&#x27;http://anothertest.com/test.php?msg=&#x27;</span> + event.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">request</span>(url);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">onreadystatechange</span> = response;</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,url);</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 返回响应结果</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">response</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;<span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;服务端返回的数据是:&#x27;</span>+ xhr.<span class="property">responseText</span>,<span class="string">&#x27;http://test.com/a.html&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外还要关注安全问题。 postMessage 本质上是依赖于客户端脚本设置了相应的 <code>message</code> 监听事件，因此只要有消息通过<code>postMessage</code>发送过来，我们的脚本都会接收并进行处理 —— 而任何域都可以通过 <code>postMessage</code> 发送跨域信息，因此对于设置了事件监听器的页面来说，判断到达页面的信息是否安全是非常重要的。通常可以通过 <code>event.origin</code> 检测消息方是否在消息源白名单中。</p>
<h2 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h2><p>默认情况下，改变页面的 url 会导致页面跳转，但是 hash 是个例外，譬如将 <a target="_blank" rel="noopener" href="http://test.com/a.html#hash">http://test.com/a.html#hash</a> 改为 <a target="_blank" rel="noopener" href="http://test.com/a.html#anotherhash">http://test.com/a.html#anotherhash</a> ，并不会引起页面跳转，所以我们可以利用 hash 来传输数据。</p>
<p>假设A域有 a.html 和 b.html，B域有 c.html，且 a.html 和 c.html 之间要进行跨域通信。</p>
<ul>
<li>一方面，我们在 a.html 中通过 <code>iframe</code> 引入 c.html，引用的 src 带上 hash —— 实际上这时候已经<strong>通过 hash 的方式把数据传给 c.html 了</strong></li>
<li>另一方面，在 c.html 中，我们对这个数据进行一些处理，之后想办法返回给 a.html。怎么返回呢？假定 a、c 同域，那么可以通过将数据赋值给 <code>window.parent.location.hash</code> 的方式，让 a.html 的 hash 改变，同时 a.html 监听这个改变，保存传过来的数据。但问题是，a、c 是不同源的，我们无法在 c.html 中通过 <code>window.parent</code> 去访问 a.html。那么谁能和 a.html 直接通信呢？肯定是和 a.html 同源的 html，因此我们想到，在 c.html 中利用 <code>iframe</code> 引入与 a.html 同源的 b.html，引用的 src 带上 hash —— 实际上这时候已经<strong>通过 hash 的方式把数据传给 b.html 了</strong>，而 b.html 拿到数据后，由于它和 a.html 是同源的，所以可以直接将数据赋值给 <code>window.parent.parent.location.hash</code> ，之后，a.html 监听 hash 改变，保存数据。</li>
</ul>
<p>如下图所示：</p>
<p><img src="/article/2019/11/AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/image-20210323134806752.png" alt="image-20210323134806752"></p>
<p>下面我们看一下代码是怎么写的。</p>
<p>像前面说的，我们创建 <code>iframe</code> 引用 c.html，通过 hash 传值，同时监听 a.html 的 hash 改变 —— 这里有两种方式，我们可以直接用 onhashchange 监听，也可以设置一个定时器，每隔两秒轮询一次 hash，一旦改变就打印数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>No changes yet<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">iframe.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3001/c.html#getdata&#x27;</span>;   <span class="comment">// location.hash为&#x27;#getdata&#x27;</span></span></span><br><span class="line"><span class="language-javascript">iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 原生 onhashchange 监听，有些浏览器不支持 onhashchange</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = location.<span class="property">hash</span> ? location.<span class="property">hash</span>.<span class="title function_">substring</span>(<span class="number">1</span>) : <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    p.<span class="property">innerHTML</span> = data;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//定时器轮询 hash</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// function checkHash() &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//     let data = location.hash ? location.hash.substring(1) : &#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//     p.innerHTML = data;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// setInterval(checkHash, 2000);   // 每隔2s监听hash值是否发生变化</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们根据不同的参数采取不同的处理，因为传过来的是 <code>#getdata</code>，所以调用 <code>callBack</code> 函数，函数首先尝试直接用 <code>parent.location.hash</code> 改变 a.html 的 hash，发现是不同源的，更改失败，改为将数据传给 b.html。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">switch</span>(location.<span class="property">hash</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">case</span> <span class="string">&#x27;#getdata&#x27;</span>:</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">callBack</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">case</span> <span class="string">&#x27;#getAnotherData&#x27;</span>:</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//do something……</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">callBack</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> message = <span class="string">&#x27;name=Sam&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        parent.<span class="property">location</span>.<span class="property">hash</span> = message;   <span class="comment">// 因为不同域，这里通过 parent.location.hash 直接更改会报错</span></span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">catch</span>(e)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 采用 b.html 作为中转站</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ifrproxy = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        ifrproxy.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        ifrproxy.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000/b.html#&#x27;</span> + message; <span class="comment">// 注意该文件在3000端口下</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(ifrproxy);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于 b.html 和 a.html 同源，所以可以直接更改 a.html 的 hash。更改后触发 a.html 中的事件，打印数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    parent.parent.location.hash = self.location.hash;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>location.hash 跨域的大致过程就是这样，当然，它的缺点也很明显：</p>
<ul>
<li>数据直接暴露在了 url 中</li>
<li>数据容量和类型有限</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p> <a target="_blank" rel="noopener" href="https://www.runoob.com/html/html5-websocket.html">https://www.runoob.com/html/html5-websocket.html</a> </p>
<p>传统的 http 协议有一个缺陷：通信只能由客户端发起，服务端无法主动向客户端推送信息。比如，服务端这边某个状态发生变化，它是无法主动通知客户端的，而只能由客户端采用轮询的方式，每隔一段时间发送一次请求进行探测。</p>
<p>这时候出现了一种新的叫做 WebSocket 的协议，它使用<code>ws://</code>（非加密）和 <code>wss://</code>（加密）作为协议前缀，特点在于支持双向通信 —— 客户端可以主动向服务端发送信息，服务端也可以主动向客户端推送信息 。那么这和跨域有什么关系呢？事实上，<font color="red">WebSocket 本身就不受同源策略的影响</font>，这意味着，一旦客户端与服务端建立的是 WebSocket 连接，天然就可以实现跨域资源共享。</p>
<h3 id="建立-WebSocket-连接"><a href="#建立-WebSocket-连接" class="headerlink" title="建立 WebSocket 连接"></a>建立 WebSocket 连接</h3><p>客户端要求升级至 WebSocket 协议：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /chat <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: server.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat, superchat</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure>

<p>服务端同意升级：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">101</span> <span class="title class_">Switching</span> <span class="title class_">Protocols</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Accept</span>: <span class="title class_">HSmrc0</span>sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat</span><br></pre></td></tr></table></figure>

<h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>同源策略限制了不同源之间无法发送 AJAX 请求，但是 WebSocket 发送的并不是 AJAX 请求，而是 WebSocket 请求。在了解怎么发起 ws 请求之前，先看一下一些相关属性。</p>
<ul>
<li><code>WebSocket</code> 对象的 <code>readyState</code> 属性用来表示对象实例当前所处的连接状态，有四个值：<ul>
<li><strong>0</strong>：表示正在连接中（CONNECTING）；</li>
<li><strong>1</strong>：表示连接成功，可以通信（OPEN）；</li>
<li><strong>2</strong>：表示连接正在关闭（CLOSING）；</li>
<li><strong>3</strong>：表示连接已经关闭或打开连接失败（CLOSED）；</li>
</ul>
</li>
<li>另外还有四个事件属性：<ul>
<li><code>onopen</code>：用于指定连接成功后的回调函数；</li>
<li><code>onclose</code>：用于指定连接关闭后的回调函数；</li>
<li><code>onmessage</code>：用于指定收到服务器数据后的回调函数；</li>
<li><code>onerror</code>：用于指定报错时的回调函数；</li>
</ul>
</li>
<li>另外还提供了 <code>bufferedAmount</code> 属性，表示还剩下多少字节的二进制数据没有发送出去</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:3000&#x27;</span>);</span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接成功，准备发送信息!&#x27;</span>);</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;发送信息&#x27;</span>);</span><br><span class="line">&#125;    </span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;后端返回的是&#x27;</span> + e.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过， 原生的 WebSocket API 使用起来不太方便，可以使用 Socket.io，它很好地封装了 WebSocket 接口，提供了更简单、灵活的接口，也对不支持 WebSocket 的浏览器提供了向下兼容。</p>
<h2 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h2><h2 id="Nodejs-中间件代理"><a href="#Nodejs-中间件代理" class="headerlink" title="Nodejs 中间件代理"></a>Nodejs 中间件代理</h2><p>原理和 nginx 相同，通过代理服务器，实现数据的转发 。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%B7%A8%E5%9F%9F/" rel="tag"># 跨域</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2019/11/Oracle%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-plsql-developer-%E5%AE%89%E8%A3%85/" rel="prev" title="Oracle管理工具 pl&#x2F;sql developer 安装">
                  <i class="fa fa-angle-left"></i> Oracle管理工具 pl/sql developer 安装
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2019/11/SpringBoot%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/" rel="next" title="SpringBoot实现跨域的5种方式">
                  SpringBoot实现跨域的5种方式 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
