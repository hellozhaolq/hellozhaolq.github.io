<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="推荐： 视频教程：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1wh411e7nd 对应代码：https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq&#x2F;2021-Java-ThreadPool-Tutorial 对于数据库连接，我们经常听到数据库连接池这个概念。因为建立数据库连接是非常耗时的一个操作，其中涉及到网络IO的一些操作。因此就想出把连接通过一个连接池来管理。需要">
<meta property="og:type" content="article">
<meta property="og:title" content="28Java多线程之线程池">
<meta property="og:url" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="推荐： 视频教程：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1wh411e7nd 对应代码：https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq&#x2F;2021-Java-ThreadPool-Tutorial 对于数据库连接，我们经常听到数据库连接池这个概念。因为建立数据库连接是非常耗时的一个操作，其中涉及到网络IO的一些操作。因此就想出把连接通过一个连接池来管理。需要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241129103158944.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130230853124.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130231616596.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130233415821.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130141530423.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130192011239.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130220905236.png">
<meta property="article:published_time" content="2015-10-15T01:00:00.000Z">
<meta property="article:modified_time" content="2015-10-15T01:00:00.000Z">
<meta property="article:author" content="zhaolq">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241129103158944.png">


<link rel="canonical" href="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/","path":"article/2015/10/28Java多线程之线程池/","title":"28Java多线程之线程池"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>28Java多线程之线程池 | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">贪婪，找不到比这更好的词了，是件好事。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-UML-%E7%B1%BB%E5%9B%BE"><span class="nav-number">2.</span> <span class="nav-text">线程池 UML 类图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Executor"><span class="nav-number">3.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ExecutorService"><span class="nav-number">4.</span> <span class="nav-text">ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E9%83%A8%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">全部接口方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractExecutorService"><span class="nav-number">4.2.</span> <span class="nav-text">AbstractExecutorService</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ScheduledExecutorService"><span class="nav-number">4.3.</span> <span class="nav-text">ScheduledExecutorService</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">5.</span> <span class="nav-text">线程池的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Executors%E5%B7%A5%E5%8E%82%E7%B1%BB-%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-number">5.1.</span> <span class="nav-text">Executors工厂类-不推荐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82"><span class="nav-number">5.1.1.</span> <span class="nav-text">创建线程工厂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newFixedThreadPool-%E6%85%8E%E7%94%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">newFixedThreadPool-慎用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newSingleThreadExecutor-%E6%85%8E%E7%94%A8"><span class="nav-number">5.1.3.</span> <span class="nav-text">newSingleThreadExecutor-慎用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newCachedThreadPool-%E6%85%8E%E7%94%A8"><span class="nav-number">5.1.4.</span> <span class="nav-text">newCachedThreadPool-慎用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newWorkStealingPool"><span class="nav-number">5.1.5.</span> <span class="nav-text">newWorkStealingPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newSingleThreadScheduledExecutor"><span class="nav-number">5.1.6.</span> <span class="nav-text">newSingleThreadScheduledExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">5.1.7.</span> <span class="nav-text">newScheduledThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.1.8.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor%E7%B1%BB-%E6%8E%A8%E8%8D%90"><span class="nav-number">5.2.</span> <span class="nav-text">ThreadPoolExecutor类-推荐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ScheduledThreadPoolExecutor%E7%B1%BB"><span class="nav-number">5.3.</span> <span class="nav-text">ScheduledThreadPoolExecutor类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoinPool%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text">ForkJoinPool类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.</span> <span class="nav-text">线程池的使用示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#execute%E5%92%8Csubmit%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">execute和submit区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Future-UML-%E7%B1%BB%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">Future UML 类图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E5%92%8C%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="nav-number">9.</span> <span class="nav-text">线程池的关闭和运行状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">线程池是怎样执行任务的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CompletionService"><span class="nav-number">11.</span> <span class="nav-text">CompletionService</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">如何监控线程池？</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">554</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="28Java多线程之线程池 | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          28Java多线程之线程池
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-10-15 09:00:00" itemprop="dateCreated datePublished" datetime="2015-10-15T09:00:00+08:00">2015-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>推荐：</p>
<p>视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wh411e7nd">https://www.bilibili.com/video/BV1wh411e7nd</a></p>
<p>对应代码：<a target="_blank" rel="noopener" href="https://github.com/hellozhaolq/2021-Java-ThreadPool-Tutorial">https://github.com/hellozhaolq/2021-Java-ThreadPool-Tutorial</a></p>
<p>对于数据库连接，我们经常听到<font color="blue"><strong>数据库连接池</strong></font>这个概念。因为建立数据库连接是非常耗时的一个操作，其中涉及到网络IO的一些操作。因此就想出把连接通过一个连接池来管理。需要连接的话，就从连接池里取一个。当使用完了，就“关闭”连接，这不是真正意义上的关闭，只是把连接放回池里，供其他人在使用。所以对于线程，也有了<font color="blue"><strong>线程池</strong></font>这个概念，其中的原理和数据库连接池差不多。</p>
<span id="more"></span>

<p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。<strong>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</strong></p>
<p>在 JDK5 之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池。</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>线程池就是限制系统中使用线程的数量以及更好的使用线程</p>
<p>根据系统的运行情况，可以自动或手动设置线程数量，达到运行的最佳效果：配置少了，将影响系统的执行效率，配置多了，又会浪费系统的资源。用线程池配置数量，其他线程排队等候。当一个任务执行完毕后，就从队列中取一个新任务运行，如果没有新任务，那么这个线程将等待。如果来了一个新任务，但是没有空闲线程的话，那么把任务加入到等待队列中。</p>
<p><font color="red"><strong>为什么要用线程池？</strong></font></p>
<ul>
<li>减少线程创建和销毁的次数，使线程可以多次复用</li>
<li>可以根据系统情况，调整线程的数量。防止创建过多的线程，消耗过多的内存（每个线程1M左右）</li>
</ul>
<h1 id="线程池-UML-类图"><a href="#线程池-UML-类图" class="headerlink" title="线程池 UML 类图"></a>线程池 UML 类图</h1><p><img src="/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241129103158944.png" alt="image-20241129103158944"></p>
<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p>Java 里面线程池的顶级接口是 <code>java.util.concurrent.Executor</code>，但是严格意义上讲 Executor 并不是一个线程池，它只是一个执行线程的工具。</p>
<p>真正的线程池接口是 <code>java.util.concurrent.ExecutorService</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在将来的某个时间执行给定的命令。该命令可以在新线程、池线程或调用线程中执行，由Executor实现决定。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：command – 可运行的任务</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果此任务不能被接受执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果命令为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h1><p>ExecutorService 对象表示一个线程池，可以执行 Runnable 对象或者 Callable 对象代表的线程。</p>
<h2 id="全部接口方法"><a href="#全部接口方法" class="headerlink" title="全部接口方法"></a>全部接口方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动有序关闭，继续执行先前已提交的任务，但不会接受新任务。如果已经关闭，调用没有额外的效果。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该方法不等待之前提交的任务完成执行，使用awaitTermination来做到这一点。（人话：该方法无返回值，无法判断池中任务是否完成执行，使用awaitTermination方法判断）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 抛出：SecurityException – 如果存在安全管理器并且关闭此 ExecutorService 可能会操纵调用者不允许修改的线程，</span></span><br><span class="line"><span class="comment">     *                          因为它不持有RuntimePermission (&quot;modifyThread&quot;) ，或者安全管理器的checkAccess方法拒绝访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。</span></span><br><span class="line"><span class="comment">     * 除了尽最大努力停止处理正在执行的任务之外，没有任何保证。例如，典型的实现将通过Thread.interrupt取消，</span></span><br><span class="line"><span class="comment">     * 因此任何无法响应interrupt的任务可能永远不会终止。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 此方法不等待正在执行的任务终止，使用awaitTermination来做到这一点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回：从未开始执行的任务列表</span></span><br><span class="line"><span class="comment">     * 抛出：SecurityException – 如果存在安全管理器并且关闭此 ExecutorService 可能会操纵调用者不允许修改的线程，</span></span><br><span class="line"><span class="comment">     *                          因为它不持有RuntimePermission (&quot;modifyThread&quot;) ，或者安全管理器的checkAccess方法拒绝访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池状态是否 &gt;= SHUTDOWN，ThreadPoolExecutor的实现 runStateAtLeast(ctl.get(), SHUTDOWN)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回：如果此executor已关闭，则为true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池状态是否 &gt;= TERMINATED，ThreadPoolExecutor的实现 runStateAtLeast(ctl.get(), TERMINATED)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果关闭后所有任务均已完成，则返回true。请注意，除非首先调用shutdown或shutdownNow，否则isTerminated永远不会为true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回：如果关闭后所有任务均已完成，则为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监测ExecutorService是否在等待时间内关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：timeout – 等待的最长时间</span></span><br><span class="line"><span class="comment">     *      unit – 超时参数的时间单位</span></span><br><span class="line"><span class="comment">     * 返回：如果executor终止，则为true；如果超时未终止，则为false</span></span><br><span class="line"><span class="comment">     * 抛出：InterruptedException – 如果在等待时被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********************************************************************************/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交Runnable任务以执行并返回代表该任务的Future。Future的get方法将在成功完成后 返回null，返回null，返回null。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：task – 要提交的任务</span></span><br><span class="line"><span class="comment">     * 返回：代表待完成任务的 Future</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果任务为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提 Runnable任务以执行并返回代表该任务的Future。Future的get方法将在成功完成后返回给定的结果。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：task – 要提交的任务</span></span><br><span class="line"><span class="comment">     *      result - 要返回的结果</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – 结果的类型</span></span><br><span class="line"><span class="comment">     * 返回：代表待完成任务的 Future</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果任务为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个返回值的任务以供执行，并返回一个表示该任务待处理结果的 Future。 Future 的get方法将在成功完成后返回任务的结果。</span></span><br><span class="line"><span class="comment">     * 如果您想立即阻止等待任务，可以使用result = exec.submit(aCallable).get();形式的结构。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：Executors类包含一组方法，可以将一些其他常见的类似闭包的对象（例如java.security.PrivilegedAction ）转换为Callable形式，</span></span><br><span class="line"><span class="comment">     * 以便可以提交它们。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：task – 要提交的任务</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – 任务结果的类型</span></span><br><span class="line"><span class="comment">     * 返回：代表待完成任务的 Future</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果任务为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行给定的任务，当全部完成时，返回保存其状态和结果的Futures列表。</span></span><br><span class="line"><span class="comment">     * 对于返回列表的每个元素调用Future.isDone都返回true。请注意，已完成的任务可能已经正常终止，也可能通过引发异常终止。</span></span><br><span class="line"><span class="comment">     * 如果在此操作正在进行时修改了给定的集合，则此方法的结果是不确定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：tasks — 任务的集合</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – 从任务返回的值的类型</span></span><br><span class="line"><span class="comment">     * 返回：表示任务的Futures列表，与给定任务列表的迭代器生成的顺序相同，每个任务都已完成</span></span><br><span class="line"><span class="comment">     * 抛出：InterruptedException – 如果在等待时被中断，在这种情况下，未完成的任务将被取消</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果任务或其任何元素为null</span></span><br><span class="line"><span class="comment">     *      RejectedExecutionException – 如果任何任务无法安排执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行给定的任务，当全部完成或超时到期（以先发生者为准）时，返回保存其状态和结果的Futures列表。</span></span><br><span class="line"><span class="comment">     * 对于返回列表的每个元素调用Future.isDone都返回true。返回时，取消未完成的任务。请注意，已完成的任务可能已经正常终止，也可能通过引发异常终止。</span></span><br><span class="line"><span class="comment">     * 如果在此操作正在进行时修改了给定的集合，则此方法的结果是不确定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：tasks — 任务的集合</span></span><br><span class="line"><span class="comment">     *      timeout – 等待的最长时间</span></span><br><span class="line"><span class="comment">     *      unit – 超时参数的时间单位</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – 从任务返回的值的类型</span></span><br><span class="line"><span class="comment">     * 返回：表示任务的Futures列表，其顺序与给定任务列表的迭代器生成的顺序相同。如果操作没有超时，则每个任务都将完成。如果确实超时，其中一些任务将无法完成。</span></span><br><span class="line"><span class="comment">     * 抛出：InterruptedException – 如果在等待时被中断，在这种情况下，未完成的任务将被取消</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果任务、其任何元素或单元为null</span></span><br><span class="line"><span class="comment">     *      RejectedExecutionException – 如果任何任务无法安排执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行给定任务，返回已成功完成的任务的结果（即不抛出异常），如果有的话。</span></span><br><span class="line"><span class="comment">     * 正常或异常返回时，取消未完成的任务。</span></span><br><span class="line"><span class="comment">     * 如果在此操作正在进行时修改了给定的集合，则此方法的结果是不确定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：tasks — 任务的集合</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – 从任务返回的值的类型</span></span><br><span class="line"><span class="comment">     * 返回：其中一项任务返回的结果（最先完成的执行结果）</span></span><br><span class="line"><span class="comment">     * 抛出：InterruptedException – 如果在等待时被中断</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果任务或任何要执行的元素任务为null</span></span><br><span class="line"><span class="comment">     *      IllegalArgumentException – 如果任务为空</span></span><br><span class="line"><span class="comment">     *      ExecutionException – 如果没有任务成功完成</span></span><br><span class="line"><span class="comment">     *      RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行给定任务，返回已成功完成的任务的结果（即不抛出异常），如果未超时。</span></span><br><span class="line"><span class="comment">     * 正常或异常返回时，取消未完成的任务。</span></span><br><span class="line"><span class="comment">     * 如果在此操作正在进行时修改了给定的集合，则此方法的结果是不确定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：tasks — 任务的集合</span></span><br><span class="line"><span class="comment">     *      timeout – 等待的最长时间</span></span><br><span class="line"><span class="comment">     *      unit – 超时参数的时间单位</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – 从任务返回的值的类型</span></span><br><span class="line"><span class="comment">     * 返回：其中一项任务返回的结果（最先完成的执行结果）</span></span><br><span class="line"><span class="comment">     * 抛出：InterruptedException – 如果在等待时被中断</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果任务、单元或任何要执行的元素任务为null</span></span><br><span class="line"><span class="comment">     *      TimeoutException – 如果超过指定时间且没有任何任务成功完成</span></span><br><span class="line"><span class="comment">     *      ExecutionException – 如果没有任务成功完成</span></span><br><span class="line"><span class="comment">     *      RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p>提供 ExecutorService 执行方法的默认实现。该类使用 newTaskFor（返回 RunnableFuture）实现了 submit 、 invokeAny 和 invokeAll 方法，默认为 <code>java.util.concurrent</code> 包中提供的 FutureTask 类。例如， submit(Runnable) 的实现创建一个执行并返回的关联 RunnableFuture 。子类可以重写 newTaskFor方法以返回除 FutureTask 之外的 RunnableFuture 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">新增的两个newTaskFor方法：</span></span><br><span class="line"><span class="comment">    1、供自身实现的方法调用；</span></span><br><span class="line"><span class="comment">    2、供子类重写（例如 ForkJoinPool 类）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title class_">ExecutorService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给定Runnable和默认值的 RunnableFuture 。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：runnable – 被包装的Runnable</span></span><br><span class="line"><span class="comment">     *      value – 返回的 future 的默认值</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – 给定值的类型</span></span><br><span class="line"><span class="comment">     * 返回：RunnableFuture，当运行时，将运行底层Runnable，并且作为Future，将产生给定值作为其结果，并提供底层任务的取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给定Callable的 RunnableFuture 。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：callable – 被包装的Callable</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;T&gt; – Callable结果的类型</span></span><br><span class="line"><span class="comment">     * 返回：RunnableFuture，当运行时，将运行底层Callable，并且作为Future ，将产生给定值作为其结果，并提供底层任务的取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title class_">ExecutorService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并执行在给定延迟后启用的一次性操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：command - 要执行的任务</span></span><br><span class="line"><span class="comment">     *      delay – 从现在开始延迟执行的时间</span></span><br><span class="line"><span class="comment">     *      unit – 延迟参数的时间单位</span></span><br><span class="line"><span class="comment">     * 返回：一个 ScheduledFuture 表示任务的挂起完成，其get()方法将在完成时返回null（因为是Runnable任务）。</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果命令为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并执行在给定延迟后启用的 ScheduledFuture，一次性操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：callable – 要执行的函数</span></span><br><span class="line"><span class="comment">     *      delay – 从现在开始延迟执行的时间</span></span><br><span class="line"><span class="comment">     *      unit – 延迟参数的时间单位</span></span><br><span class="line"><span class="comment">     * 类型参数：&lt;V&gt; – 可调用结果的类型</span></span><br><span class="line"><span class="comment">     * 返回：可用于提取结果或取消的 ScheduledFuture</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果 callable 为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="type">long</span> delay, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并执行一个周期性动作，该动作在给定的初始延迟后首先启用，随后在给定的周期内启用；也就是说，执行将在initialDelay之后开始，</span></span><br><span class="line"><span class="comment">     * 然后是 initialDelay+period，然后是 initialDelay + 2*period，依此类推。</span></span><br><span class="line"><span class="comment">     * 如果此任务的任何执行遇到异常，则后续执行将被抑制。否则，任务只会通过取消或终止executor来终止。</span></span><br><span class="line"><span class="comment">     * 如果此任务的任何执行时间超过其周期，则后续执行可能会延迟开始，但不会同时执行。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：command - 要执行的任务</span></span><br><span class="line"><span class="comment">     *      initialDelay – 延迟首次执行的时间</span></span><br><span class="line"><span class="comment">     *      period周期 – 连续执行之间的时间段，可以理解为个执行的开始和下一个执行的开始之间的延迟</span></span><br><span class="line"><span class="comment">     *      unit – initialDelay 和 period 参数的时间单位</span></span><br><span class="line"><span class="comment">     * 返回：表示待完成任务的 ScheduledFuture，其get()方法将在取消时抛出异常</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果命令为空</span></span><br><span class="line"><span class="comment">     *      IllegalArgumentException – 如果 period 小于或等于零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并执行一个周期性操作，该操作首先在给定的初始延迟后启用，随后在一个执行的终止和下一个执行的开始之间具有给定的延迟。</span></span><br><span class="line"><span class="comment">     * 如果此任务的任何执行遇到异常，则后续执行将被抑制。否则，任务只会通过取消或终止executor来终止。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：command - 要执行的任务</span></span><br><span class="line"><span class="comment">     *      initialDelay – 延迟首次执行的时间</span></span><br><span class="line"><span class="comment">     *      delay延迟 - 一个执行的终止和下一个执行的开始之间的延迟</span></span><br><span class="line"><span class="comment">     *      unit – initialDelay 和 delay 参数的时间单位</span></span><br><span class="line"><span class="comment">     * 返回：表示待完成任务的 ScheduledFuture，其get()方法将在取消时抛出异常</span></span><br><span class="line"><span class="comment">     * 抛出：RejectedExecutionException – 如果无法安排任务执行</span></span><br><span class="line"><span class="comment">     *      NullPointerException – 如果命令为空</span></span><br><span class="line"><span class="comment">     *      IllegalArgumentException – 如果延迟小于或等于零</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pcheng/p/13540619.html">https://www.cnblogs.com/pcheng/p/13540619.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vhua/tag/%E5%B9%B6%E5%8F%91/">https://www.cnblogs.com/vhua/tag/%E5%B9%B6%E5%8F%91/</a></p>
<p>Java 中创建线程池主要有两种方法：</p>
<ul>
<li>通过 Executors 工厂类创建，该类提供了4种不同的线程池可供使用。</li>
<li><strong>通过 ThreadPoolExecutor 类进行自定义创建，</strong><font color="red"><strong>推荐</strong></font>。</li>
</ul>
<h2 id="Executors工厂类-不推荐"><a href="#Executors工厂类-不推荐" class="headerlink" title="Executors工厂类-不推荐"></a>Executors工厂类-不推荐</h2><p><code>java.util.concurrent.Executors</code> 类提供了 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和实用方法。该类支持以下几种方法：</p>
<ul>
<li>创建并返回常用配置的 ExecutorService 的方法。</li>
<li>创建并返回常用配置的 ScheduledExecutorService 的方法。</li>
<li>创建并返回“包装的”ExecutorService 的方法，该方法通过使特定于实现的方法不可访问来禁用重新配置。</li>
<li>创建并返回ThreadFactory的方法，该 ThreadFactory 将新创建的线程设置为已知状态。</li>
<li>从其他类似闭包的形式创建并返回Callable方法，因此它们可以在需要Callable执行方法中使用。</li>
</ul>
<h3 id="创建线程工厂"><a href="#创建线程工厂" class="headerlink" title="创建线程工厂"></a>创建线程工厂</h3><p>Executors 提供两个线程工厂（ThreadFactory接口）的实现类及工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用于创建新线程的默认线程工厂。该工厂在同一个ThreadGroup中创建Executor使用的所有新线程。</span></span><br><span class="line"><span class="comment"> * 如果有一个SecurityManager，设置为System.getSecurityManager的组，否则设置为调用这个defaultThreadFactory方法的线程组。</span></span><br><span class="line"><span class="comment"> * 每个新线程都作为非守护线程创建，优先级设置为Thread.NORM_PRIORITY和线程组中允许的最大优先级中的较小者。</span></span><br><span class="line"><span class="comment"> * 新线程的名称可通过pool-N-thread-M的Thread.getName访问，其中N是该工厂的序列号，M是该工厂创建的线程的序列号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：线程工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">defaultThreadFactory</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个线程工厂，用于创建与当前线程具有相同权限的新线程。</span></span><br><span class="line"><span class="comment"> * 该工厂创建与defaultThreadFactory具有相同设置的线程，另外将新线程的AccessControlContext和contextClassLoader设置为与调用</span></span><br><span class="line"><span class="comment"> * 此privilegedThreadFactory方法的线程相同。可以在AccessController.doPrivileged操作中创建一个新的privilegedThreadFactory，</span></span><br><span class="line"><span class="comment"> * 设置当前线程的访问控制上下文，以创建在该操作中保持所选权限设置的线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，虽然在此类线程中运行的任务将具有与当前线程相同的访问控制和类加载器设置，但它们不需要具有相同的ThreadLocal或</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal值。如有必要，可以使用ThreadPoolExecutor.beforeExecute(Thread, Runnable)在ThreadPoolExecutor子类</span></span><br><span class="line"><span class="comment"> * 中运行任何任务之前设置或重置线程局部变量的特定值。此外，如果需要初始化工作线程以使其具有与其他指定线程相同的InheritableThreadLocal设置，</span></span><br><span class="line"><span class="comment"> * 您可以创建一个自定义ThreadFactory，该线程在其中等待并服务请求以创建将继承其值的其他线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：线程工厂</span></span><br><span class="line"><span class="comment"> * 抛出：AccessControlException – 如果当前访问控制上下文没有获取和设置上下文类加载器的权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">privilegedThreadFactory</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="newFixedThreadPool-慎用"><a href="#newFixedThreadPool-慎用" class="headerlink" title="newFixedThreadPool-慎用"></a>newFixedThreadPool-慎用</h3><p>固定大小的线程池，允许的请求队列 LinkedBlockingQueue 容量为 <code>Integer.MAX_VALUE</code>（ 2^31≈21亿5千万），可能会堆积大量的请求，从而导致OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，该线程池重用在共享无界队列上运行的固定数量的线程。在任何时候，最多 nThreads 个线程将是活动的处理任务。</span></span><br><span class="line"><span class="comment"> * 如果在所有线程都处于活动状态时提交了其他任务，它们将在无界队列中等待，直到有线程可用。</span></span><br><span class="line"><span class="comment"> * 如果任何线程在关闭之前的执行过程中由于失败而终止，而后续还有任务需要执行，那么新的线程将取代它。池中的线程将一直存在，直到显式关闭。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：nThreads - 池中的线程数</span></span><br><span class="line"><span class="comment"> * 返回：新创建的线程池</span></span><br><span class="line"><span class="comment"> * 抛出：IllegalArgumentException – 如果 nThreads &lt;= 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上</span></span><br><span class="line"><span class="comment"> * 在需要时使用提供的 ThreadFactory 创建新线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：nThreads - 池中的线程数</span></span><br><span class="line"><span class="comment"> *      threadFactory - 创建新线程时使用的工厂</span></span><br><span class="line"><span class="comment"> * 返回：新创建的线程池</span></span><br><span class="line"><span class="comment"> * 抛出： NullPointerException – 如果 threadFactory 为 null</span></span><br><span class="line"><span class="comment"> *       IllegalArgumentException – 如果 nThreads &lt;= 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="newSingleThreadExecutor-慎用"><a href="#newSingleThreadExecutor-慎用" class="headerlink" title="newSingleThreadExecutor-慎用"></a>newSingleThreadExecutor-慎用</h3><p>单个线程的线程池，允许的请求队列 LinkedBlockingQueue 容量为 <code>Integer.MAX_VALUE</code>（ 2^31≈21亿5千万），可能会堆积大量的请求，从而导致OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 Executor，它使用单个工作线程操作无界队列。</span></span><br><span class="line"><span class="comment"> * 请注意，如果该单线程在关闭前的执行过程中因失败而终止，而后续还有任务需要执行，那么新的线程将取代它。</span></span><br><span class="line"><span class="comment"> * 保证所有任务按顺序执行。</span></span><br><span class="line"><span class="comment"> * 与其他等效的 newFixedThreadPool(1) 不同，返回的executor保证不可重新配置以使用额外的线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：新创建的单线程 Executor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 Executor，它使用单个工作线程操作无界队列，并在需要时使用提供的 ThreadFactory 创建一个新线程。</span></span><br><span class="line"><span class="comment"> * 与其他等效的 newFixedThreadPool(1, threadFactory) 不同，返回的executor保证不能重新配置以使用其他线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：threadFactory – 创建新线程时使用的工厂</span></span><br><span class="line"><span class="comment"> * 返回：新创建的单线程 Executor</span></span><br><span class="line"><span class="comment"> * 抛出：NullPointerException – 如果 threadFactory 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoShutdownDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="newCachedThreadPool-慎用"><a href="#newCachedThreadPool-慎用" class="headerlink" title="newCachedThreadPool-慎用"></a>newCachedThreadPool-慎用</h3><p>可缓存的线程池，使用 SynchronousQueue，允许创建的线程数量为 <code>Integer.MAX_VALUE</code>（ 2^31≈21亿5千万），可能会创建大量的线程，从而导致OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但在可用时将重用以前构造的线程。</span></span><br><span class="line"><span class="comment"> * 这些池通常会提高执行许多短期异步任务的程序的性能。</span></span><br><span class="line"><span class="comment"> * 如果可用，对执行的调用将重用以前构造的线程。如果没有可用的现有线程，将创建一个新线程并将其添加到池中。</span></span><br><span class="line"><span class="comment"> * 六十秒内未使用的线程将被终止并从缓存中删除。</span></span><br><span class="line"><span class="comment"> * 因此，保持空闲足够长时间的池不会消耗任何资源。</span></span><br><span class="line"><span class="comment"> * 请注意，可以使用 ThreadPoolExecutor 构造函数创建具有相似属性但细节不同（例如超时参数）的池。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：新创建的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在可用时重用以前构造的线程，并在需要时使用提供的 ThreadFactory 创建新线程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数：threadFactory – 创建新线程时使用的工厂</span></span><br><span class="line"><span class="comment"> * 返回：新创建的线程池</span></span><br><span class="line"><span class="comment"> * 抛出：NullPointerException – 如果 threadFactory 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><p>fork-join 形式的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，该线程池维护足够的线程来支持给定的并行级别，并且可以使用多个队列来减少争用。并行级别对应于主动参与或可用于参与</span></span><br><span class="line"><span class="comment"> * 任务处理的线程的最大数量。实际线程数可能会动态增长和收缩。work-stealing pool 不保证提交任务的执行顺序。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数：parallelism – 目标并行度</span></span><br><span class="line"><span class="comment"> * 返回：新创建的线程池</span></span><br><span class="line"><span class="comment"> * 抛出：IllegalArgumentException – 如果 parallelism &lt;= 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span></span><br></pre></td></tr></table></figure>

<h3 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h3><p>执行延时或定期任务的单个线程的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个单线程执行程序(executor)，可以安排命令在给定延迟后运行，或定期执行。</span></span><br><span class="line"><span class="comment"> * （但请注意，如果该单线程在关闭前的执行过程中因失败而终止，而后续还有任务需要执行，那么新的线程将取代它。）</span></span><br><span class="line"><span class="comment"> * 保证所有任务按顺序执行，并且在任何给定时间都不会有超过一个任务处于活动状态。</span></span><br><span class="line"><span class="comment"> * 与其他等效的newScheduledThreadPool(1)不同，返回的executor保证不可重新配置以使用额外的线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：新创建的调度执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个单线程执行程序(executor)，可以安排命令在给定延迟后运行，或定期执行。</span></span><br><span class="line"><span class="comment"> * （但请注意，如果该单线程在关闭前的执行过程中因失败而终止，而后续还有任务需要执行，那么新的线程将取代它。）</span></span><br><span class="line"><span class="comment"> * 任务所有保证按顺序执行，并且在任何给定时间都不会有超过一个任务处于活动状态。</span></span><br><span class="line"><span class="comment"> * 与其他等效的newScheduledThreadPool(1, threadFactory)不同，返回的executor保证不能重新配置以使用其他线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数：threadFactory – 创建新线程时使用的工厂</span></span><br><span class="line"><span class="comment"> * 返回：一个新创建的调度执行器</span></span><br><span class="line"><span class="comment"> * 抛出：NullPointerException – 如果threadFactory为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span><br></pre></td></tr></table></figure>

<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>执行延时或定期任务的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，可以安排命令在给定延迟后运行，或定期执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数： corePoolSize - 保留在池中的线程数，即使它们是空闲的</span></span><br><span class="line"><span class="comment"> * 返回：一个新创建的调度线程池</span></span><br><span class="line"><span class="comment"> * 抛出： IllegalArgumentException – 如果 corePoolSize &lt; 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，可以安排命令在给定延迟后运行，或定期执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数： corePoolSize - 保留在池中的线程数，即使它们是空闲的</span></span><br><span class="line"><span class="comment"> *       threadFactory - 执行程序创建新线程时使用的工厂</span></span><br><span class="line"><span class="comment"> * 返回：一个新创建的调度线程池</span></span><br><span class="line"><span class="comment"> * 抛出： IllegalArgumentException – 如果 corePoolSize &lt; 0</span></span><br><span class="line"><span class="comment"> *       NullPointerException – 如果 threadFactory 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：这里用的是 <code>java.util.concurrent.ScheduledExecutorService</code> 接口的 schedule() 方法，不是 <code>java.util.concurrent.ExecutorService</code> 接口的 execute() 方法。</strong> </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建新线程的默认线程工厂</span></span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line">        <span class="comment">// 可用的处理器数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">availableProcessorsNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        System.out.println(<span class="string">&quot;可用的处理器数量: &quot;</span> + availableProcessorsNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个单线程执行程序</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(threadFactory);</span><br><span class="line">        <span class="comment">// 创建固定大小线程池,工作队列LinkedBlockingQueue</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(availableProcessorsNum, threadFactory);</span><br><span class="line">        <span class="comment">// 创建缓存线程池，核心池大小0，最大线程数Integer.MAX_VALUE，当线程数大于核心池大小时空闲线程存活时间60s，工作队列SynchronousQueue，</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool(threadFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个单线程执行程序，可以安排命令在给定延迟后运行，或定期执行。工作队列DelayedWorkQueue</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">singleThreadScheduledExecutor</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor(threadFactory);</span><br><span class="line">        <span class="comment">// 创建一个线程池，可以安排命令在给定延迟后运行，或定期执行。工作队列DelayedWorkQueue</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(availableProcessorsNum,</span><br><span class="line">                threadFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// newSingleThreadScheduledExecutor是否只有一个线程工作？观察输出的线程名称，结果是一个工作线程</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">20</span>).forEach(i -&gt; &#123;</span><br><span class="line">            ScheduledFuture&lt;?&gt; scheduledFuture = singleThreadScheduledExecutor.scheduleAtFixedRate(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">RunnableTask1</span>(),</span><br><span class="line">                    <span class="number">3</span>,</span><br><span class="line">                    <span class="number">5</span>,</span><br><span class="line">                    TimeUnit.SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// newScheduledThreadPool是否固定数量？观察输出的线程名称，结果是固定数量</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">20</span>).forEach(i -&gt; &#123;</span><br><span class="line">            ScheduledFuture&lt;?&gt; scheduledFuture = scheduledThreadPool.scheduleWithFixedDelay(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">RunnableTask1</span>(),</span><br><span class="line">                    <span class="number">3</span>,</span><br><span class="line">                    <span class="number">5</span>,</span><br><span class="line">                    TimeUnit.SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableTask1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; RunnableTask1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; CallableTask1&quot;</span>);</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500000</span>); <span class="comment">// 1毫秒=1000微妙</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CallableTask1 execute success!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadPoolExecutor类-推荐"><a href="#ThreadPoolExecutor类-推荐" class="headerlink" title="ThreadPoolExecutor类-推荐"></a>ThreadPoolExecutor类-推荐</h2><p>ThreadPoolExecutor 类提供了4种构造方法，可根据需要来自定义一个线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他构造方法，省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共7个参数，<font color="red"><strong>详细说明可参考类注释</strong></font>：</p>
<ul>
<li><p>corePoolSize：核心线程数，线程池中始终存活的线程数。</p>
</li>
<li><p>maximumPoolSize：最大线程数，线程池中允许的最大线程数。</p>
</li>
<li><p>keepAliveTime：空闲的非核心线程存活时间（非核心线程数 &#x3D; 最大线程数 - 核心线程数），非核心线程空闲的时间超过设定值会被销毁。</p>
</li>
<li><p>unit：参数 keepAliveTime 的时间单位。</p>
</li>
<li><p>workQueue：一个阻塞的任务队列，用来存储等待执行的任务，均为线程安全，7种可选。</p>
<table>
<thead>
<tr>
<th>任务拒绝策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>一个由数组结构组成的有界阻塞队列。</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td><strong>一个由链表结构组成的有界阻塞队列。</strong></td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>一个不存储元素的阻塞队列，即直接提交给线程不保持它们。（同步队列）</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>一个支持优先级排序的无界阻塞队列。</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素。</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>一个由链表结构组成的无界阻塞队列。与SynchronousQueue类似，还含有非阻塞方法。</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>一个由链表结构组成的双向阻塞队列。</td>
</tr>
</tbody></table>
<p><font color="red"><strong>较常用的是 LinkedBlockingQueue 和 Synchronous 。线程池的排队策略与 BlockingQueue 有关。</strong></font></p>
</li>
<li><p>threadFactory：线程工厂，通过 ThreadFactory 接口可自定义创建线程的行为。以下是默认的线程工厂 <code>Executors.defaultThreadFactory()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    CustomThreadFactory() &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); <span class="comment">// 线程组</span></span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> + poolNumber.getAndIncrement() + <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> namePrefix + threadNumber.getAndIncrement(); <span class="comment">// 自定义线程名称，方便查看日志</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r, threadName, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (thread.isDaemon())</span><br><span class="line">            thread.setDaemon(<span class="literal">false</span>); <span class="comment">// 非守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (thread.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            thread.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 优先级5</span></span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>handler：任务拒绝策略（提交给线程池的任务被拒绝的处理策略），4种可选，AbortPolicy 用的最多，也可自定义。</p>
<p>在什么情况下提交给线程池的任务会被拒绝呢？同时满足以下4种情况：线程池中的线程已满、无法再继续扩容、没有空闲线程、任务队列已满。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>默认的拒绝策略，抛出 RejectedExecutionException 异常。</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>直接丢弃任务。</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃处于任务队列头部（最旧）的任务，添加被拒绝的任务。（队列：队尾入队，队头出队，先进先出）</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>使用调用者的线程直接执行被拒绝的任务。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="ScheduledThreadPoolExecutor类"><a href="#ScheduledThreadPoolExecutor类" class="headerlink" title="ScheduledThreadPoolExecutor类"></a>ScheduledThreadPoolExecutor类</h2><p><font color="red"><strong>调度线程池：</strong></font>具备执行定时、延时、周期性任务的线程池。</p>
<p>4个构造方法都无法指定任务队列，默认是专门的延迟队列 <code>DelayedWorkQueue</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExecutor</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ScheduledExecutorService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他构造方法，省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                       ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                                       RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口方法源码注释见上文 <code>ScheduledExecutorService</code> 接口。</p>
<p>执行周期性任务的两个方法的区别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">scheduleAtFixedRate</th>
<th align="center">scheduleWithFixedDelay</th>
</tr>
</thead>
<tbody><tr>
<td align="center">周期</td>
<td align="center">固定时间</td>
<td align="center">间隔时间</td>
</tr>
</tbody></table>
<p><img src="/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130230853124.png" alt="image-20241130230853124"></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已fork，见github</span></span><br></pre></td></tr></table></figure>

<h2 id="ForkJoinPool类"><a href="#ForkJoinPool类" class="headerlink" title="ForkJoinPool类"></a>ForkJoinPool类</h2><p>什么是 ForkJoin 框架？</p>
<p>ForkJoin 是一个把大任务<strong>分割成若干个小任务</strong>，直到分割的足够小，再对每个小任务得到的<strong>结果进行汇总</strong>，得到大任务结果的框架，这种方式远比用一个线程执行大任务要高效的多。</p>
<p><strong>Fork：表示分割任务。Join：表示合并结果。</strong></p>
<p><img src="/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130231616596.png" alt="image-20241130231616596"></p>
<p>ForkJoinPool 是一个采用 ForkJoin 框架的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关的类：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ForkJoinPool</td>
<td>ForkJoin 线程池</td>
</tr>
<tr>
<td>ForkJoinTask</td>
<td>职责相当于 Future</td>
</tr>
<tr>
<td>RecursiveTask（ForkJoinTask子类）</td>
<td>有返回值任务（相当于Callable）</td>
</tr>
<tr>
<td>RecursiveAction（ForkJoinTask子类）</td>
<td>无返回值任务（相当于Runnable）</td>
</tr>
</tbody></table>
<p>从 1 加到 100 的 ForkJoin 图解：</p>
<p><img src="/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130233415821.png" alt="image-20241130233415821"></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 创建 ForkJoin 线程池</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future = threadPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取结果</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临界值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当开头与结尾之差小于临界值时</span></span><br><span class="line">        <span class="keyword">if</span> ((end - start) &lt; temp) &#123;</span><br><span class="line">            <span class="comment">// 记录计算结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 累加开头-结尾的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 取中间值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 计算开头-中间</span></span><br><span class="line">            <span class="type">Task</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>(start, middle);</span><br><span class="line">            <span class="comment">// 向线程池中添加此任务</span></span><br><span class="line">            task1.fork();</span><br><span class="line">            <span class="comment">// 计算中间-结尾</span></span><br><span class="line">            <span class="type">Task</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 向线程池中添加此任务</span></span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="comment">// 合并结果</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线程池的使用示例"><a href="#线程池的使用示例" class="headerlink" title="线程池的使用示例"></a>线程池的使用示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; resultRunnableTask1 = executor.submit(<span class="keyword">new</span> <span class="title class_">RunnableTask1</span>());</span><br><span class="line">        Future&lt;?&gt; resultRunnableTask2 = executor.submit(<span class="keyword">new</span> <span class="title class_">RunnableTask2</span>(), <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        Future&lt;Integer&gt; resultCallableTask1 = executor.submit(<span class="keyword">new</span> <span class="title class_">CallableTask1</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(resultRunnableTask1.get()); <span class="comment">// null</span></span><br><span class="line">            System.out.println(resultRunnableTask1.get() == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line">            System.out.println(resultRunnableTask2.get()); <span class="comment">// OK</span></span><br><span class="line">            System.out.println(resultCallableTask1.get()); <span class="comment">// CallableTask1 execute success!</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Collection&lt;Callable&lt;String&gt;&gt; collection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">CallableTask1</span>());</span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">CallableTask2</span>());</span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = executor.invokeAll(collection);</span><br><span class="line">        <span class="comment">// List&lt;Future&lt;String&gt;&gt; futureList = executor.invokeAll(collection, 10, TimeUnit.MILLISECONDS);</span></span><br><span class="line">        futureList.forEach(ele -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;resultInvokeAll: &quot;</span> + ele.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// String resultInvokeAny = executor.invokeAny(collection);</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resultInvokeAny</span> <span class="operator">=</span> executor.invokeAny(collection, <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            System.out.println(<span class="string">&quot;resultInvokeAny: &quot;</span> + resultInvokeAny);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//close pool</span></span><br><span class="line">            executor.shutdown();</span><br><span class="line">            <span class="comment">// 只是为了等待一段时间，之后在finally中判断，若有未完成的则关闭</span></span><br><span class="line">            executor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!executor.isTerminated()) &#123;</span><br><span class="line">                List&lt;Runnable&gt; runList = executor.shutdownNow();</span><br><span class="line">                System.out.println(<span class="string">&quot;从未开始执行的任务列表: &quot;</span> + runList.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableTask1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RunnableTask1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableTask2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RunnableTask2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CallableTask1&quot;</span>);</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500000</span>); <span class="comment">// 1毫秒=1000微妙</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CallableTask1 execute success!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CallableTask2&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CallableTask2 execute success!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="execute和submit区别"><a href="#execute和submit区别" class="headerlink" title="execute和submit区别"></a>execute和submit区别</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 归属不同接口</span></span><br><span class="line"><span class="comment">- 返回值类型不同</span></span><br><span class="line"><span class="comment">- 参数不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runnable任务无返回值，为什么还要返回一个Future对象呢？</span></span><br><span class="line"><span class="comment">     *     因为Future除了获取任务执行结果以外，还可以观察任务执行状态、取消任务等操作，所以返回的Future可以选择是否接收。</span></span><br><span class="line"><span class="comment">     *     submit方法支持提交Runnable任务并指定执行结果，若未指定则默认执行结果为null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>; <span class="comment">// 提交Callable任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Future-UML-类图"><a href="#Future-UML-类图" class="headerlink" title="Future UML 类图"></a>Future UML 类图</h1><p><img src="/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130141530423.png" alt="image-20241130141530423"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消任务</span></span><br><span class="line"><span class="comment">     *     方法返回true，调用get将引发CancellationException。</span></span><br><span class="line"><span class="comment">     *         若果任务未执行，则该任务永远不会运行。方法返回true。</span></span><br><span class="line"><span class="comment">     *         若果任务正在执行，则mayInterruptIfRunning参数表示是否中断正在执行的任务。无论是否中断，此方法都返回true。</span></span><br><span class="line"><span class="comment">     *     方法返回false</span></span><br><span class="line"><span class="comment">     *         若果任务已完成或已取消，或者由于某些其他原因无法取消，调用该方法无效。方法返回false。</span></span><br><span class="line"><span class="comment">     * 该方法的返回值并不一定表明任务现在是否被标记为取消，应该使用isCancelled进行判断（注意：任务取消并不代表任务结束执行）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数：mayInterruptIfRunning – 表示是否中断正在执行的任务。</span></span><br><span class="line"><span class="comment">     *          true ：任务被标记为取消。若任务中响应线程中断指令Thread.interrupted()，则任务被中断；否则继续执行。所以为true时任务不一定被中断。</span></span><br><span class="line"><span class="comment">     *          false：任务被标记为取消。但任务依然会继续执行直到结束。</span></span><br><span class="line"><span class="comment">     * 返回：如果任务无法取消，则false，通常是因为任务已经完成；否则为true。</span></span><br><span class="line"><span class="comment">     *      如果两个或多个线程导致任务被取消，则至少其中一个返回true。实施可以提供更有力的保证。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞式获取任务执行结果</span></span><br><span class="line"><span class="comment">     * 抛出: CancellationException – 如果任务被取消</span></span><br><span class="line"><span class="comment">     *      ExecutionException – 如果任务抛出异常</span></span><br><span class="line"><span class="comment">     *      InterruptedException – 如果当前线程在等待时被中断</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意: 这里的InterruptedException不是任务抛出的，而是调用get()方法的线程。Future没有Thread任务中的InterruptedException，</span></span><br><span class="line"><span class="comment">     *      只有CancellationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定时间内阻塞式获取任务执行结果，若超时则抛出异常</span></span><br><span class="line"><span class="comment">     * 抛出：CancellationException – 如果任务被取消</span></span><br><span class="line"><span class="comment">     *      ExecutionException – 如果任务抛出异常</span></span><br><span class="line"><span class="comment">     *      InterruptedException – 如果当前线程在等待时被中断</span></span><br><span class="line"><span class="comment">     *      TimeoutException – 如果等待超时</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意: 这里的InterruptedException不是任务抛出的，而是调用get()方法的线程。Future没有Thread任务中的InterruptedException，</span></span><br><span class="line"><span class="comment">     *      只有CancellationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此任务在正常完成之前被取消，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此任务完成则返回true。完成可能是由于正常终止、异常或取消——在所有这些情况下，此方法都将返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池的关闭和运行状态"><a href="#线程池的关闭和运行状态" class="headerlink" title="线程池的关闭和运行状态"></a>线程池的关闭和运行状态</h1><p>当使用完成 ExecutorService 后应该关闭它，否则它里面的线程会一直处于运行状态（即使没有提交任何任务），导致JVM无法关闭。举个例子，如果的应用程序是通过 main() 方法启动的，在这个 main() 退出之后，如果应用程序中的 ExecutorService 没有关闭，系统将一直运行。</p>
<p>两种关闭线程池的方法对比，实际开发中大多使用 <font color="red"><strong>shutdown()</strong></font>：</p>
<table>
<thead>
<tr>
<th></th>
<th>ExecutorService.shutdown()</th>
<th>ExecutorService.shutdownNow()</th>
</tr>
</thead>
<tbody><tr>
<td>立即关闭线程池</td>
<td><font color="red">false</font></td>
<td><font color="green">true</font></td>
</tr>
<tr>
<td>延时关闭线程池</td>
<td><font color="green">true</font></td>
<td><font color="red">false</font></td>
</tr>
<tr>
<td>不再接收新任务（任务拒绝策略）</td>
<td><font color="green">true</font></td>
<td><font color="green">true</font></td>
</tr>
<tr>
<td>继续正在执行的任务</td>
<td><font color="green">true</font></td>
<td><font color="red">中断能够响应interrupt的任务</font></td>
</tr>
<tr>
<td>执行队列中的任务</td>
<td><font color="green">true</font></td>
<td><font color="red">false</font></td>
</tr>
<tr>
<td>返回队列中的任务列表（未执行任务）</td>
<td><font color="red">false</font></td>
<td><font color="green">true</font></td>
</tr>
<tr>
<td>线程池状态</td>
<td>SHUTDOWN</td>
<td>STOP</td>
</tr>
</tbody></table>
<p>线程池的状态，定义在 ThreadPoolExecutor 类中，包装了两个概念字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>workerCount：表示池中的线程数（或者叫工作线程数）。</p>
</li>
<li><p>runState：表示线程池的运行状态，提供主要的生命周期控制。</p>
<table>
<thead>
<tr>
<th>运行状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>接受新任务，并处理排队任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>不接受新任务，但处理排队任务，继续正在执行的任务。当所有任务都执行完，转为TIDYING状态。</td>
</tr>
<tr>
<td>STOP</td>
<td>不接受新任务，不处理排队任务，并中断正在进行的任务。当正在执行的任务被标记为中断状态后，转为TIDYING状态。</td>
</tr>
<tr>
<td>TIDYING</td>
<td>所有任务都已终止，workerCount为零，转换到TIDYING状态的线程将运行termination()钩子方法。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>线程池彻底关闭</td>
</tr>
</tbody></table>
</li>
</ul>
<p>runState 的状态转换，具体见 ThreadPoolExecutor 类：</p>
<p><img src="/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130192011239.png" alt="image-20241130192011239"></p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEach(i -&gt; executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;finished: &quot;</span> + threadName + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// close pool</span></span><br><span class="line">            executor.shutdown();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;线程池状态是否 &gt;= SHUTDOWN: &quot;</span> + executor.isShutdown()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程池状态是否 &gt;= TERMINATED: &quot;</span> + executor.isTerminated()); <span class="comment">// false</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程池状态是否 &gt;= TERMINATED: &quot;</span> + executor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!executor.isTerminated()) &#123;</span><br><span class="line">                List&lt;Runnable&gt; runList = executor.shutdownNow();</span><br><span class="line">                System.out.println(<span class="string">&quot;从未开始执行的任务列表: &quot;</span> + runList.size());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Thread.sleep(3000);</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;线程池状态是否 &gt;= SHUTDOWN: &quot;</span> + executor.isShutdown()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程池状态是否 &gt;= TERMINATED: &quot;</span> + executor.isTerminated()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程池状态是否 &gt;= TERMINATED: &quot;</span> + executor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池是怎样执行任务的？"><a href="#线程池是怎样执行任务的？" class="headerlink" title="线程池是怎样执行任务的？"></a>线程池是怎样执行任务的？</h1><p>提交任务的方式有两种：</p>
<ul>
<li>ThreadPoolExecutor 类实现的 Executor 接口的 <code>void execute(Runnable command);</code> 方法。</li>
<li>AbstractExecutorService 抽象类实现的 ExecutorService 接口的 <code>Future&lt;?&gt; submit(Runnable task);</code> 方法。</li>
</ul>
<p>它们最终处理任务的方法都是 ThreadPoolExecutor 类中实现的 execute 方法。</p>
<p>submit 方法的实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title class_">ExecutorService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>); <span class="comment">// 转为有返回值任务</span></span><br><span class="line">        execute(ftask); <span class="comment">// 此处调用的是 ThreadPoolExecutor 类中实现的 execute 方法</span></span><br><span class="line">        <span class="keyword">return</span> ftask; <span class="comment">// 返回 Future 对象，调用者根据该对象进行 获取任务执行结果、观察任务执行状态、取消任务 等操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); <span class="comment">// 转为有返回值任务</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute 方法的实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 核心线程是否已满（workerCountOf 获取当前线程池中有多少线程）</span></span><br><span class="line">            <span class="comment">// addWorker方法添加线程，使用了CAS操作保证线程安全</span></span><br><span class="line">            <span class="comment">// 第一个参数：指定线程任务，在线程刚创建时就可以指定任务</span></span><br><span class="line">            <span class="comment">// 第二个参数：指定该线程是否为核心线程，true代表是核心线程。核心线程不会在空闲时被销毁，单独设置允许销毁核心线程除外</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 添加成功就会执行任务，直接return。若核心线程已满，则添加失败。</span></span><br><span class="line">            c = ctl.get(); <span class="comment">// 获取线程池状态和池中线程数，为后续流程做准备。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 当核心线程已满时，如果线程池还在运行，则将任务添加至任务队列中（队列未满则添加成功）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 再次获取线程池状态</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池如果不再运行，则从队列移除任务</span></span><br><span class="line">                reject(command); <span class="comment">// 移除成功，则拒绝任务</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 池中可用线程数是否为零</span></span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>); <span class="comment">// 池中没有可用线程，则添加空任务的非核心线程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) <span class="comment">// 当核心线程已满，且任务队列已满时，再次尝试添加线程，达到最大线程数则添加失败</span></span><br><span class="line">            reject(command); <span class="comment">// 核心线程已满，任务队列已满，且达到最大线程数，则拒绝任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="/article/2015/10/28Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20241130220905236.png" alt="image-20241130220905236"></p>
<h1 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h1><p>如果需求是按任务完成时间先后顺序返回执行结果时，推荐使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 创建 ExecutorCompletionService 对象</span></span><br><span class="line">        ExecutorCompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(threadPool);</span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 创建任务</span></span><br><span class="line">            <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>(i);</span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            completionService.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取多个任务执行结果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取 Future</span></span><br><span class="line">                Future&lt;Integer&gt; future = completionService.take();</span><br><span class="line">                <span class="comment">// 获取执行结果</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">                <span class="comment">// 输出执行结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;返回顺序：&quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> order)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 输出执行时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行顺序：&quot;</span> + order);</span><br><span class="line">        <span class="comment">// 使当前线程休眠指定时间</span></span><br><span class="line">        Thread.sleep(order * <span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 返回执行时间</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何监控线程池？"><a href="#如何监控线程池？" class="headerlink" title="如何监控线程池？"></a>如何监控线程池？</h1><p>自定义带监控功能的线程池，继承 ThreadPoolExecutor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorThreadPool</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MonitorThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                             RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次执行任务前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        monitor(<span class="string">&quot;beforeExecute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次任务完成后调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">        monitor(<span class="string">&quot;afterExecute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池关闭前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor(<span class="string">&quot;terminated  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监控线程池情况</span></span><br><span class="line"><span class="comment">     * 实际开发中，一般写到log，或写到服务器某块儿地方，通过客户端随时查看</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">monitor</span><span class="params">(String ExecutePos)</span> &#123;</span><br><span class="line">        System.out.print(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span>); <span class="comment">// 线程名称</span></span><br><span class="line">        System.out.print(ExecutePos + <span class="string">&quot;\t&quot;</span>); <span class="comment">// 执行时机</span></span><br><span class="line">        <span class="comment">// 监控线程的变化情况</span></span><br><span class="line">        System.out.print(<span class="string">&quot;正在工作线程数：&quot;</span> + getActiveCount() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;当前存在线程数：&quot;</span> + getPoolSize() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;历史最大线程数：&quot;</span> + getLargestPoolSize() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="comment">// 监控任务的变化情况</span></span><br><span class="line">        System.out.print(<span class="string">&quot;已提交任务数：&quot;</span> + getTaskCount() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;已完成任务数：&quot;</span> + getCompletedTaskCount() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;队列中任务数：&quot;</span> + getQueue().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Thread.currentThread().setName(Thread.currentThread().getName() + <span class="string">&quot;          &quot;</span>); <span class="comment">// 为了让控制台输出对齐</span></span><br><span class="line">        <span class="comment">// 创建带监控的线程池</span></span><br><span class="line">        <span class="type">MonitorThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MonitorThreadPool</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 提交多个任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 创建任务</span></span><br><span class="line">                <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>(i);</span><br><span class="line">                <span class="comment">// 提交任务</span></span><br><span class="line">                threadPool.submit(task);</span><br><span class="line">                <span class="comment">// 每隔500毫秒提交一个</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使主线程休眠6秒钟，目的是在关闭线程池之前获取一次情况</span></span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            threadPool.monitor(<span class="string">&quot;beforeShutdown&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使当前线程休眠指定时间</span></span><br><span class="line">            Thread.sleep(timeout * <span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1	beforeExecute	正在工作线程数：1	当前存在线程数：1	历史最大线程数：1	已提交任务数：1	已完成任务数：0	队列中任务数：0</span><br><span class="line">pool-1-thread-2	beforeExecute	正在工作线程数：2	当前存在线程数：2	历史最大线程数：2	已提交任务数：4	已完成任务数：0	队列中任务数：2</span><br><span class="line">pool-1-thread-3	beforeExecute	正在工作线程数：3	当前存在线程数：3	历史最大线程数：3	已提交任务数：5	已完成任务数：0	队列中任务数：2</span><br><span class="line">pool-1-thread-3	afterExecute	正在工作线程数：3	当前存在线程数：3	历史最大线程数：3	已提交任务数：5	已完成任务数：0	队列中任务数：2</span><br><span class="line">pool-1-thread-3	beforeExecute	正在工作线程数：3	当前存在线程数：3	历史最大线程数：3	已提交任务数：5	已完成任务数：1	队列中任务数：1</span><br><span class="line">pool-1-thread-2	afterExecute	正在工作线程数：3	当前存在线程数：3	历史最大线程数：3	已提交任务数：5	已完成任务数：1	队列中任务数：1</span><br><span class="line">pool-1-thread-2	beforeExecute	正在工作线程数：3	当前存在线程数：3	历史最大线程数：3	已提交任务数：5	已完成任务数：2	队列中任务数：0</span><br><span class="line">pool-1-thread-1	afterExecute	正在工作线程数：3	当前存在线程数：3	历史最大线程数：3	已提交任务数：5	已完成任务数：2	队列中任务数：0</span><br><span class="line">pool-1-thread-2	afterExecute	正在工作线程数：2	当前存在线程数：2	历史最大线程数：3	已提交任务数：5	已完成任务数：3	队列中任务数：0</span><br><span class="line">pool-1-thread-3	afterExecute	正在工作线程数：1	当前存在线程数：1	历史最大线程数：3	已提交任务数：5	已完成任务数：4	队列中任务数：0</span><br><span class="line">main          	beforeShutdown	正在工作线程数：0	当前存在线程数：1	历史最大线程数：3	已提交任务数：5	已完成任务数：5	队列中任务数：0</span><br><span class="line">pool-1-thread-3	terminated  	正在工作线程数：0	当前存在线程数：0	历史最大线程数：3	已提交任务数：5	已完成任务数：5	队列中任务数：0</span><br></pre></td></tr></table></figure>






    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2015/10/27Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="prev" title="27Java多线程之线程间通信">
                  <i class="fa fa-angle-left"></i> 27Java多线程之线程间通信
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2015/10/29Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%A7%84%E8%8C%83%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="next" title="29Java多线程之线程规范与线程管理">
                  29Java多线程之线程规范与线程管理 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
