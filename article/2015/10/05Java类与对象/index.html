<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="类与对象事物：                        类： 　　　属性                        成员变量 　　　行为                        成员方法 　类：是一组相关的属性和行为的集合。是一个抽象的概念。　　学生：类 对象：是该类事物的具体表现形式。具体存在的个体。　　　　　班长：对象">
<meta property="og:type" content="article">
<meta property="og:title" content="05Java类与对象">
<meta property="og:url" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="类与对象事物：                        类： 　　　属性                        成员变量 　　　行为                        成员方法 　类：是一组相关的属性和行为的集合。是一个抽象的概念。　　学生：类 对象：是该类事物的具体表现形式。具体存在的个体。　　　　　班长：对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627154836840-538507884.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627154837051-2025730054.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627154837367-1687602335.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627170129265-218190415.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627171635641-510610183.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627171649335-1497412690.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627171930484-1783703799.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174643150-86662574.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174658183-1030194297.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174711224-1319816506.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174754875-1419777129.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174814677-1412793559.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174829627-1501258452.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174918514-517556769.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627183542800-405004801.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184045161-2097194752.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184045411-275941649.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184045755-192109891.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184046137-1450698299.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184046482-798732375.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184046912-1280691095.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184047264-1100962270.png">
<meta property="article:published_time" content="2015-10-03T02:00:00.000Z">
<meta property="article:modified_time" content="2015-10-03T02:00:00.000Z">
<meta property="article:author" content="zhaolq">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627154836840-538507884.png">


<link rel="canonical" href="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","path":"article/2015/10/05Java类与对象/","title":"05Java类与对象"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>05Java类与对象 | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">耳不闻人是非，目不视人之短，口不言人之过。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">类、对象、实例的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">3.</span> <span class="nav-text">类中的成员</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">成员变量和局部变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.2.</span> <span class="nav-text">new关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">成员方法（函数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">3.4.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="nav-number">3.5.</span> <span class="nav-text">形参与实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text">可变长参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%EF%BC%88package%EF%BC%89"><span class="nav-number">3.8.</span> <span class="nav-text">包（package）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="nav-number">3.9.</span> <span class="nav-text">创建对象做了哪些事情</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">匿名对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#private%E3%80%81this%E3%80%81super%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.</span> <span class="nav-text">private、this、super、static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#private"><span class="nav-number">5.1.</span> <span class="nav-text">private</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">5.2.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">5.3.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">5.4.</span> <span class="nav-text">static</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">5.4.1.</span> <span class="nav-text">修饰成员变量和成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">5.4.2.</span> <span class="nav-text">静态的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">5.4.3.</span> <span class="nav-text">静态的内存图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.4.4.</span> <span class="nav-text">静态的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.4.5.</span> <span class="nav-text">静态变量和成员变量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8this%E4%B8%8Esuper"><span class="nav-number">5.4.6.</span> <span class="nav-text">为什么静态方法中不能使用this与super</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">6.</span> <span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">7.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-extends"><span class="nav-number">8.</span> <span class="nav-text">继承(extends)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">8.1.</span> <span class="nav-text">Java中的继承体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">8.2.</span> <span class="nav-text">访问权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96"><span class="nav-number">8.3.</span> <span class="nav-text">方法的重写(覆盖)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">8.4.</span> <span class="nav-text">super关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">8.5.</span> <span class="nav-text">继承中的构造方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">9.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F"><span class="nav-number">9.1.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90"><span class="nav-number">9.2.</span> <span class="nav-text">多态的前提</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%97%B6%E5%8F%AA%E8%83%BD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">9.3.</span> <span class="nav-text">多态时只能调用父类的成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">9.4.</span> <span class="nav-text">多态的好处&#x2F;特点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">9.5.</span> <span class="nav-text">多态的弊端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-number">9.6.</span> <span class="nav-text">多态的表现形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="nav-number">9.6.1.</span> <span class="nav-text">引用多态：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="nav-number">9.6.2.</span> <span class="nav-text">方法多态：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.7.</span> <span class="nav-text">引用数据类型的类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang-Object"><span class="nav-number">9.8.</span> <span class="nav-text">java.lang.Object</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="nav-number">10.</span> <span class="nav-text">抽象类与接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract"><span class="nav-number">10.1.</span> <span class="nav-text">abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interface"><span class="nav-number">10.2.</span> <span class="nav-text">interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">10.3.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3-%E5%85%B3%E7%B3%BB"><span class="nav-number">10.4.</span> <span class="nav-text">类、接口 关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.5.</span> <span class="nav-text">抽象类和接口的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">形式参数和返回值的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text">形式参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.2.</span> <span class="nav-text">返回值类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">11.3.</span> <span class="nav-text">链式编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">12.</span> <span class="nav-text">包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">12.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">12.2.</span> <span class="nav-text">包的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">12.3.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%8C%85%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="nav-number">12.4.</span> <span class="nav-text">带包的编译和运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%8C%85"><span class="nav-number">12.5.</span> <span class="nav-text">导包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">13.</span> <span class="nav-text">常见的修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">13.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%BB%84%E6%88%90"><span class="nav-number">13.2.</span> <span class="nav-text">常见的修饰组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A6%E5%A4%96%E6%AF%94%E8%BE%83%E5%B8%B8%E8%A7%81%E7%9A%84"><span class="nav-number">13.3.</span> <span class="nav-text">另外比较常见的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB-1"><span class="nav-number">14.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="nav-number">14.1.</span> <span class="nav-text">访问规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB-1"><span class="nav-number">14.2.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">14.2.1.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">14.2.2.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">14.2.3.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E9%A2%98"><span class="nav-number">15.</span> <span class="nav-text">面向对象分析题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">16.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE1"><span class="nav-number">17.</span> <span class="nav-text">回顾1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE2"><span class="nav-number">18.</span> <span class="nav-text">回顾2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE3"><span class="nav-number">19.</span> <span class="nav-text">回顾3</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">555</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="05Java类与对象 | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          05Java类与对象
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-10-03 10:00:00" itemprop="dateCreated datePublished" datetime="2015-10-03T10:00:00+08:00">2015-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>事物：                        类：</p>
<p>　　　属性                        成员变量</p>
<p>　　　行为                        成员方法</p>
<p>　类：是一组相关的属性和行为的集合。是一个抽象的概念。　　学生：类</p>
<p>对象：是该类事物的具体表现形式。具体存在的个体。　　　　　班长：对象</p>
<span id="more"></span>

<p>1:面向对象思想</p>
<p>　　面向对象是<strong>基于</strong>面向过程的编程思想。</p>
<p>　　面向过程：强调的是每一个功能的步骤</p>
<p>　　面向对象：强调的是对象，然后由对象去调用功能</p>
<p>2:面向对象的思想特点</p>
<p>　　A:是一种更符合我们思想习惯的思想</p>
<p>　　B:可以将复杂的事情简单化</p>
<p>　　C:将我们从执行者变成了指挥者</p>
<p>3:开发，设计，特征</p>
<p>　　面向对象开发：就是不断的创建对象，使用对象，指挥对象做事情。</p>
<p>　　面向对象设计：其实就是在管理和维护对象之间的关系。</p>
<p>　　面向对象特征：</p>
<p>​				<strong>封装(encapsulation)</strong></p>
<p>​				<strong>继承(inheritance)</strong></p>
<p>​				<strong>多态(polymorphism)</strong></p>
<p>​				抽象</p>
<h1 id="类、对象、实例的关系"><a href="#类、对象、实例的关系" class="headerlink" title="类、对象、实例的关系"></a>类、对象、实例的关系</h1><p><font color="red">每个 <strong>对象</strong> 都是某个 <strong>类</strong> (class)的一个 <strong>实例</strong> (instance)。</font> </p>
<p><font color="red">对象是类实例化的结果 –&gt; 类定义了一个数据类型，而对象是该数据类型的一个实例化。</font> </p>
<h1 id="类中的成员"><a href="#类中的成员" class="headerlink" title="类中的成员"></a>类中的成员</h1><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>　　A:在类中的位置不同</p>
<p>　　　　成员变量（属性，字段，域，全局变量）：在<strong>类中方法外</strong>声明的变量。<strong>用于描述类的特征</strong>。</p>
<p>　　　　局部变量：在方法定义中或者方法声明上。</p>
<p>　　B:在内存中的位置不同</p>
<p>　　　　成员变量：在堆内存</p>
<p>　　　　局部变量：在栈内存</p>
<p>　　C:生命周期不同</p>
<p>　　　　成员变量：随着对象的创建而存在，随着对象的消失而消失</p>
<p>　　　　局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</p>
<p>　　D:初始化值不同</p>
<p>　　　　成员变量：有默认初始化值</p>
<p>　　　　局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。</p>
<p>　　注意事项：局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</p>
<h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><p>​		<strong>在堆中开辟空间，创建类的实例(对象)。</strong></p>
<p>​		<strong>类的每个对象都有自己的成员变量。</strong></p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627154836840-538507884.png" alt="img"></p>
<h2 id="成员方法（函数）"><a href="#成员方法（函数）" class="headerlink" title="成员方法（函数）"></a>成员方法（函数）</h2><p>​		用于描述类的行为(<strong>动作</strong>)。</p>
<p>　　i.    基本格式：</p>
<p>　　　　访问权限 返回类型 方法名([参数列表]){</p>
<p>　　　　　　代码;</p>
<p>　　　　}</p>
<p>　　ii.    当方法不需要返回类型时，使用<strong>void</strong>关键字表示。</p>
<p>　　iii.    return关键字：</p>
<p>　　　　<strong>1.    结束方法。</strong></p>
<p>　　　　2.    返回数据。</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a><font color="red">方法的重载</font></h2><p>　　i.    同一个类中**,<strong>出现</strong>名字相同**，但<strong>参数列表不同</strong>（个数不同，顺序不同，类型不同）的现象。</p>
<p>　　ii.    方法的重载与返回类型，访问权限无关。</p>
<p>　　Override：方法重写</p>
<p>　　Overload：方法重载</p>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a><font color="red">形参与实参</font></h2><p>　　i.    形参为基本数据类型：传递的是值，<strong>形参改变，实参不变</strong>。</p>
<p>　　ii.    形参为引用数据类型：传递的是引用，<strong>通常形参改变，实参也发生改变</strong>。</p>
<h2 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h2><p>​		JDK1.5开始出现。</p>
<p>　　i.    只能用于形参。</p>
<p>　　ii.    格式：数据类型… 参数名</p>
<p>　　iii.    可变长参数的本质：<strong>一维数组</strong></p>
<p>　　iv.    如果方法有多个参数，可变长参数必须出现在最后。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>​		又叫 构造器、构造函数。</p>
<p>　　i.    构造方法的功能（作用）：<strong>为类的成员变量初始化</strong>。</p>
<p>　　ii.    构造方法的特征：</p>
<p>　　　　1.    构造方法的名字与类名相同（普通方法的名字也可以与类名相同）。</p>
<p>　　　　2.    <strong>构造方法<font color="red">没有返回类型，没有具体的返回值，不能使用void</font>关键字</strong>。</p>
<p>　　iii.    <strong>类一定有构造方法</strong>。</p>
<p>　　iv.    构造方法私有将无法创建对象</p>
<p>　　　　　　public class Function {</p>
<p>　　　　　　　　private Function(){}</p>
<p>　　　　　　}</p>
<p>　　v.    <strong>当没有在类中显式的写构造方法时，JVM会自动为类添加默认的无参构造方法</strong>。</p>
<p>　　　　　　默认构造方法：</p>
<p>　　　　　　　　访问权限与类相同 构造方法名(){</p>
<p>　　　　　　}</p>
<p>　　　　当在类中显式的写了构造方法后，JVM不再为类添加默认的构造方法。</p>
<p>　　vi.    通常，构造方法只能在new关键字后面调用。即<strong>构造方法在创建对象时被调用</strong></p>
<p>　　vii.    <strong>构造方法可以重载</strong>。</p>
<p>　　viii.    </p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627154837051-2025730054.png" alt="img"></p>
<h2 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h2><p>　　i.     包的本质就是文件夹。</p>
<p>　　ii.    包的作用：</p>
<p>　　　　1.    解决类的<strong>重名</strong>问题。</p>
<p>　　　　2.    <strong>管理</strong>类。</p>
<p>　　iii.    当类位于某个包中时，类的<strong>首行</strong>必须为package语句（注释除外）。</p>
<p>　　iv.    当使用其它包中的类时，需要使用import语句导入类(导包)。</p>
<p>　　v.     java.lang包中的内容，JVM自动导入。</p>
<p>　　vi.    eclipse中直接创建在src(default package)下的类无法使用import语句导入。</p>
<p>　　vii.    <strong>JAVA命名规范</strong>：包名均为小写。oracle.jdbc.driver.OracleDriver</p>
<h2 id="创建对象做了哪些事情"><a href="#创建对象做了哪些事情" class="headerlink" title="创建对象做了哪些事情"></a>创建对象做了哪些事情</h2><p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627154837367-1687602335.png" alt="img"></p>
<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p><strong>匿名对象：没有名字的对象。 &#x2F;&#x2F;new Student();</strong></p>
<p>　　匿名对象的应用场景：</p>
<p>　　A:调用方法，仅仅只调用一次的时候。</p>
<p>　　　　这种匿名调用的好处：匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。</p>
<p>　　　　new Student().show();</p>
<p>　　　　new Student().show();   &#x2F;&#x2F;这里其实是重新创建了一个新的对象</p>
<p>　　B:匿名对象可以作为实际参数传递</p>
<p>　　　　new StudentDemo().method(<strong>new Student()</strong>);</p>
<h1 id="private、this、super、static关键字"><a href="#private、this、super、static关键字" class="headerlink" title="private、this、super、static关键字"></a>private、this、super、static关键字</h1><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>　　i.      是一个权限修饰符</p>
<p>　　ii.     可以修饰成员（成员变量和成员方法）。被private修饰的成员只能在本类中被访问。构造方法私有将无法创建对象。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li><p>代表<strong>当前类的对象的引用</strong>。</p>
</li>
<li><p>引用<strong>当前类</strong>中的<strong>成员变量</strong>与<strong>成员方法</strong>。</p>
</li>
<li><p>只能在构造方法中通过<strong>this</strong>来调用其他构造方法且要放在首行，普通方法中不能使用。</p>
</li>
<li><p>不能通过<strong>this递归调用</strong>构造方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">// 错误，主方法是静态的，不能使用this关键字。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name; <span class="comment">// 使用直接调用，其实是隐含的this。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>代表父类存储空间的标识。(代表<strong>父类的引用</strong>，用来访问父类的成员)</p>
<ul>
<li>如果自己用<strong>super关键字</strong>在子类里调用父类的构造方法，则必须在子类的构造方法中的<strong>第一行</strong>。</li>
<li>如果子类的构造方法中没有显示调用父类的构造方法，则<strong>系统默认调用父类无参的构造方法</strong>。</li>
<li>如果子类构造方法中既没有显示调用父类的构造方法，而<strong>父类没有无参的构造方法，则编译出错</strong>。</li>
</ul>
<p><strong>注意：super.getClass() 和 this.getClass() 返回的都是 new 对象时指定的类。</strong></p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="修饰成员变量和成员方法"><a href="#修饰成员变量和成员方法" class="headerlink" title="修饰成员变量和成员方法"></a>修饰成员变量和成员方法</h3><p>​		<strong>静态的成员</strong>可以直接使用类名(接口名)直接调用，也可以通过类的对象调用。</p>
<p>　　　　修饰成员变量：<strong>静态变量</strong>。</p>
<p>　　　　　　i.      类所有的对象<strong>共用一份</strong>静态变量。</p>
<p>　　　　　　ii.     静态变量<strong>只在第一次使用类时初始化</strong>，从第二次使用类时不再进行初始化。</p>
<p>　　　　修饰成员方法：静态方法。</p>
<p>　　　　　　i.      <strong>静态方法不能使用this与super关键字</strong>。</p>
<p>　　　　　　<strong>ii.     静态方法只能直接调用当前类中静态的成员。想要调用非静态成员必须通过类的对象调用</strong></p>
<p>　　　　　　<strong>iii.   非静态的方法可以直接调用静态的成员。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">static</span> String num; <span class="comment">// 未使用private修饰，可以使用对象调用</span></span><br><span class="line"></span><br><span class="line">静态方法调用成员：</span><br><span class="line">	调用静态成员：</span><br><span class="line">		Test.num = <span class="string">&quot;&quot;</span>;		<span class="comment">// 通过类名调用</span></span><br><span class="line">		num = <span class="string">&quot;&quot;</span>;			<span class="comment">// 直接调用</span></span><br><span class="line">		<span class="comment">// this.num = &quot;&quot;;	// 错误，static修饰的成员方法（即静态方法）不能使用this与super关键字</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ClassName</span>().num	<span class="comment">// 通过类的对象调用</span></span><br><span class="line">	调用非静态成员：</span><br><span class="line">		<span class="comment">// Test.name = &quot;&quot;;	// 错误，name不是静态的</span></span><br><span class="line">		<span class="comment">// name = &quot;&quot;;		// 错误，name不是静态的</span></span><br><span class="line">		<span class="comment">// this.name = &quot;&quot;;	// 错误，static修饰的成员方法不能使用this与super关键字</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ClassName</span>().name<span class="comment">// 只能通过类的对象调用</span></span><br><span class="line"></span><br><span class="line">非静态方法调用成员：</span><br><span class="line">	调用静态成员：</span><br><span class="line">		Test.num = <span class="string">&quot;&quot;</span>;		<span class="comment">// 通过类名调用</span></span><br><span class="line">		num = <span class="string">&quot;&quot;</span>;			<span class="comment">// 直接调用</span></span><br><span class="line">		<span class="built_in">this</span>.num = <span class="string">&quot;&quot;</span>;		<span class="comment">// this:当前类的对象引用</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ClassName</span>().num	<span class="comment">// 通过类的对象调用</span></span><br><span class="line">	调用非静态成员</span><br><span class="line">		Test.name = <span class="string">&quot;&quot;</span>;		<span class="comment">// 错误，只有‘静态成员’才可以用类名(接口名)调用</span></span><br><span class="line">		name = <span class="string">&quot;&quot;</span>;			<span class="comment">// 直接调用</span></span><br><span class="line">		<span class="built_in">this</span>.name = <span class="string">&quot;&quot;</span>;		<span class="comment">// this:当前类的对象引用</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ClassName</span>().name<span class="comment">// 通过类的对象调用</span></span><br></pre></td></tr></table></figure>

<h3 id="静态的特点"><a href="#静态的特点" class="headerlink" title="静态的特点"></a>静态的特点</h3><p>​		A:随着类的加载而加载</p>
<p>​		B:优先与对象存在</p>
<p>​		C:被类的所有对象共享</p>
<p>​		D:可以通过类名调用：</p>
<p>​		既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。</p>
<h3 id="静态的内存图"><a href="#静态的内存图" class="headerlink" title="静态的内存图"></a>静态的内存图</h3><p>​		静态的内容在方法区的静态区</p>
<h3 id="静态的注意事项"><a href="#静态的注意事项" class="headerlink" title="静态的注意事项"></a>静态的注意事项</h3><p>​		A:在静态方法中没有this对象</p>
<p>​		B:静态只能访问静态</p>
<h3 id="静态变量和成员变量的区别"><a href="#静态变量和成员变量的区别" class="headerlink" title="静态变量和成员变量的区别"></a>静态变量和成员变量的区别</h3><p>​		A:所属不同</p>
<p>​				静态变量：属于类，类变量</p>
<p>​				成员变量：属于对象，对象变量，实例变量</p>
<p>​		B:内存位置不同</p>
<p>​				静态变量：方法区的静态区</p>
<p>​				成员变量：堆内存</p>
<p>​		C:生命周期不同</p>
<p>​				静态变量：静态变量是随着类的加载而加载，随着类的消失而消失</p>
<p>​				成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失</p>
<p>​		D:调用不同</p>
<p>​				静态变量：可以通过对象名调用，也可以通过类名调用</p>
<p>​				成员变量：只能通过对象名调用</p>
<h3 id="为什么静态方法中不能使用this与super"><a href="#为什么静态方法中不能使用this与super" class="headerlink" title="为什么静态方法中不能使用this与super"></a><font color="red">为什么静态方法中不能使用this与super</font></h3><p><font color="red">static修饰的成员归类所有，this和super代表对象的引用 (有对象才会有引用)。类先于任何实例 (对象) 存在，即 static 修饰的成员在类加载时就已经存在了，但对象在创建时才在内存中生成，所以在静态方法中不能使用 this 与 super 关键字。</font></p>
<p><font color="red">对象是类实例化的结果</font></p>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>1、代码块：在Java中，使用{}括起来的代码被称为代码块。</p>
<p>2、根据其位置和声明的不同，可以分为</p>
<p>　　　　局部代码块：<strong>局部位置</strong>，用于限定变量的生命周期。</p>
<p>　　　　构造代码块：在类中的<strong>成员位置</strong>,用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。</p>
<p>　　　　　　作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。</p>
<p>　　　　静态代码块：在类中的<strong>成员位置</strong>，用{}括起来的代码，只不过它用static修饰了。</p>
<p>　　　　　　作用：一般是对类进行初始化。</p>
<p>　　<strong>思考题？</strong></p>
<p>　　　　静态代码块,构造代码块,构造方法的执行顺序?</p>
<p>　　　　　　静态代码块 – 构造代码块 – 构造方法</p>
<p>　　　　静态代码块：只执行一次</p>
<p>　　　　构造代码块：每次调用构造方法都执行</p>
<p>demo1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">static</span> String num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Code</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Code</span>(); <span class="comment">// 创建对象时调用无参构造方法</span></span><br><span class="line">        <span class="comment">// Code b = new Code(10); // 创建对象时调用有参的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果：</span></span><br><span class="line"><span class="comment">	1000</span></span><br><span class="line"><span class="comment">	2000</span></span><br><span class="line"><span class="comment">	100</span></span><br><span class="line"><span class="comment">	200</span></span><br><span class="line"><span class="comment">	无参构造方法code</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Code</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Code</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        System.out.println(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块Fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块Fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法Fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块Zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块Zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法Zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendsTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果：</span></span><br><span class="line"><span class="comment">	静态代码块Fu</span></span><br><span class="line"><span class="comment">	静态代码块Zi</span></span><br><span class="line"><span class="comment">	构造代码块Fu</span></span><br><span class="line"><span class="comment">	构造方法Fu</span></span><br><span class="line"><span class="comment">	构造代码块Zi</span></span><br><span class="line"><span class="comment">	构造方法Zi</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>步骤：</p>
<ul>
<li>类中的成员变量为<strong>private</strong>(私有)</li>
<li>为私有的成员变量提供公有的get()<strong>或</strong>set()方法。</li>
<li>getter和setter方法中加入合法性判断等校验</li>
</ul>
<p>封装的好处：</p>
<ul>
<li><p>隐藏实现细节，提供共有的访问方式</p>
</li>
<li><p>提高了代码的复用性</p>
</li>
<li><p>提高安全性</p>
</li>
</ul>
<p>封装的原则（思想）：</p>
<ul>
<li><p>将不需要对外提供的内容隐藏起来</p>
</li>
<li><p>把属性隐藏，提供公共方法对其访问</p>
</li>
</ul>
<p>封装的体现：private是封装的一种体现。</p>
<p>总结：</p>
<ul>
<li>封装是一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</li>
<li>封装被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</li>
<li>封装特性要求，访问该类的代码和数据，必须通过严格的接口控制。</li>
<li>封装的目的是，在修改代码时只需要修改实现代码片段，而不用修改调用代码片段。</li>
<li>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</li>
</ul>
<h1 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承(extends)"></a>继承(extends)</h1><p>继承是子类继承父类的特征和行为，能使得</p>
<ul>
<li>子类对象（实例）具有父类的实例域和方法。</li>
<li>子类从父类继承方法，使得子类具有父类相同的行为。</li>
</ul>
<p>​		格式：</p>
<p>　　　　class 子类名 extends 父类名 {}</p>
<p>​		好处：</p>
<p>　　　　A:提高了代码的复用性</p>
<p>　　　　B:提高了代码的维护性</p>
<p>　　　　C:让类与类之间产生了关系，是多态的前提</p>
<p>　　类与类产生了关系，其实也是继承的一个弊端：类的耦合性增强了。</p>
<p>　　　　开发的原则：低耦合，高内聚。</p>
<p>　　　　耦合：类与类的关系</p>
<p>　　　　内聚：就是自己完成某件事情的能力</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627170129265-218190415.png" alt="img"></p>
<h2 id="Java中的继承体系"><a href="#Java中的继承体系" class="headerlink" title="Java中的继承体系"></a>Java中的继承体系</h2><ul>
<li><p>Java中使用<strong>extends</strong>关键字来表示<strong>类继承</strong>关系。</p>
</li>
<li><p>Java中使用<strong>implement</strong>关键字来表示<strong>接口实现</strong>关系。</p>
</li>
<li><p>JAVA是（只支持）<strong>单继承</strong>：一个类只能有一个直接的父类；<strong>接口是多实现</strong>。<br>Java支持多层继承(继承体系)，儿子继承父亲，父亲继承爷爷。</p>
</li>
<li><p>Java也可使用内部类的方式来实现类的<strong>多继承</strong>特性。</p>
</li>
<li><p>子类可以继承父类所有的<strong>成员变量与成员方法</strong>（包括private）。<br>子类可以继承父类private的成员，<font color="red">但不能使用</font>。</p>
</li>
<li><p>子类不能继承父类的构造方法。（可使用super关键字）</p>
</li>
<li><p>若子类和父类中的成员变量或方法名称一样，在子类方法中访问一个变量的查找顺序：<br>a:在子类方法的局部范围找，有就使用<br>b:在子类的成员范围找，有就使用<br>c:在父类的成员范围找，有就使用<br>d:如果还找不到，就报错。</p>
</li>
<li><p>JAVA中类不能确定自己是否被继承。</p>
</li>
<li><p>Java中的继承初始化顺序为： <strong>父类对象属性初始化–&gt;父类对象构造方法–&gt;子类对象属性初始化–&gt;子类对象构造方法</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">		System.out.println(aaa); <span class="comment">// 40</span></span><br><span class="line">		System.out.println(<span class="built_in">this</span>.aaa); <span class="comment">// 30</span></span><br><span class="line">		System.out.println(<span class="built_in">super</span>.aaa); <span class="comment">// 20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>类(顶层类)只能使用<strong>public</strong>与<strong>默认</strong>的访问权限修饰。</p>
<table>
<thead>
<tr>
<th></th>
<th>本类</th>
<th>同包中的类</th>
<th>任意包中的子类</th>
<th>其他类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>(无修饰符)</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>protected</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>public</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<p><font color="red"><strong>从上到下：可访问性增强，但封装性变差。</strong></font> </p>
<h2 id="方法的重写-覆盖"><a href="#方法的重写-覆盖" class="headerlink" title="方法的重写(覆盖)"></a>方法的重写(覆盖)</h2><ul>
<li><p>子类根据需要重写父类中的方法。</p>
</li>
<li><p><font color="red">   重写的方法要与被重写的方法具有相同的方法名，参数列表，返回类型。**</font></p>
</li>
<li><p><font color="red">   重写方法的访问权限要大于等于被重写方法的访问权限。**</font></p>
</li>
<li><p><strong><font color="red">   重写方法声明的异常必须小于等于被重写方法声明的异常</font>（当父类的方法声明了异常，子类重写的方法可以不声明异常。如果子类重写的方法声明了异常，必须小于等于父类方法声明的异常）。</strong></p>
</li>
<li><p>父类静态方法，子类也必须通过静态方法进行重写。<br>static<strong>不能</strong>产生重写，但现象确实如此，为什么算不上方法重写，因为在多态中这种现象不成立。</p>
</li>
<li><p>父类中私有（private）方法<strong>不能</strong>产生重写。（可以被“重写”，没有重写的效果，所以并不叫重写）</p>
</li>
<li><p>对于覆写的方法，我们一般使用**@Override**注解标注，有助于静态检查。</p>
</li>
</ul>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>​		在子类中引用父类中的成员（通常，在子类中引用父类同名的成员）。</p>
<p>　　　　this和super的用法：</p>
<p>　　　　　　引用成员：</p>
<p>　　　　　　　　this.成员变量		调用本类的成员变量</p>
<p>　　　　　　　　super.成员变量	调用父类的成员变量</p>
<p>　　　　　　　　this.成员方法		调用本类的成员方法</p>
<p>　　　　　　　　super.成员方法	调用父类的成员方法</p>
<p>　　　　　　引用构造方法：</p>
<p>　　　　　　　　this（参数）：调用本类中另一种形式的构造函数（<strong>应该为构造函数中的第一条语句</strong>）。</p>
<p>　　　　　　　　super（参数）：调用父类中的某一个构造函数（<strong>应该为构造函数中的第一条语句</strong>）。</p>
<h2 id="继承中的构造方法"><a href="#继承中的构造方法" class="headerlink" title="继承中的构造方法"></a>继承中的构造方法</h2><p>　　a)	子类默认会在自己每一个<strong>构造方法的第一行</strong>使用<strong>super()<strong>调用父类</strong>无参</strong>的构造方法。<strong>因为如果不是放在第一条语句上，就可能对父类的数据进行了多次初始化。</strong></p>
<p>​				子类构造方法执行前默认先执行父类的无参构造方法</p>
<p>　　b)    当父类没有无参的构造方法时，而子类也没有调用父类有参数的构造方法，则编译失败。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>多态是同一个行为具有多个不同表现形式或形态的能力。</li>
<li>多态就是同一个接口，使用不同的实例而执行不同操作。</li>
<li>同一个事件发生在不同的对象上会产生不同的结果。</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>​		<strong>父类声明，子类创建。</strong></p>
<p>​		<strong>父 f &#x3D; new 子();</strong></p>
<h2 id="多态的前提"><a href="#多态的前提" class="headerlink" title="多态的前提"></a>多态的前提</h2><p>　　A:要有<strong>继承关系</strong>。</p>
<p>　　B:要有方法重写。</p>
<p>　　　　其实没有也是可以的，但是如果没有这个就没有意义。</p>
<p>　　C:要有父类引用指向子类对象。</p>
<h2 id="多态时只能调用父类的成员"><a href="#多态时只能调用父类的成员" class="headerlink" title="多态时只能调用父类的成员"></a><font color="red">多态时只能调用父类的成员</font></h2><p>　　a)  <strong>多态时调用的成员变量一定为父类的成员变量</strong>。</p>
<p>　　b)  多态时调用的成员方法：</p>
<p>　　　　i.   如果子类没有重写此方法，调用的是父类的方法。</p>
<p>　　　　ii.   如果子类重写了父类的方法，<strong>调用的是子类的方法</strong>。</p>
<p>　　c)   多态时调用的构造方法：</p>
<p>　　　　创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化。</p>
<p>　　d)  多态时调用的static方法</p>
<p>　　　　static方法不能产生重写。现象像重写但不是重写，如果子类“重写”static方法，依然<strong>调用父类的方法。</strong></p>
<p> <img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627171635641-510610183.png" alt="img"></p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627171649335-1497412690.png" alt="img"></p>
<h2 id="多态的好处-特点："><a href="#多态的好处-特点：" class="headerlink" title="多态的好处&#x2F;特点："></a>多态的好处&#x2F;特点：</h2><ul>
<li><strong>替换性</strong>：父类的引用可替换成任意子类。</li>
<li><strong>扩展性</strong>：提高了代码的扩展性(由多态保证)，增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。</li>
<li><strong>接口性</strong>：父类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。</li>
<li><strong>灵活性</strong>：在应用中体现灵活多样的操作，提高了使用效率，由继承保证。</li>
<li><strong>简化性</strong>：简化对应用软件的代码编写和修改过程，在处理大量对象的运算和操作时尤为重要。</li>
</ul>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p><strong>不能使用子类的特有功能。</strong></p>
<p>我就想使用子类的特有功能？行不行？—————-行。</p>
<p>怎么用呢？</p>
<ul>
<li><p>创建子类对象调用方法即可。(可以，但是很多时候不合理。而且，太占内存了)</p>
</li>
<li><p>把父类的引用强制转换为子类的引用。<strong>(向下转型)</strong></p>
</li>
</ul>
<h2 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h2><h3 id="引用多态："><a href="#引用多态：" class="headerlink" title="引用多态："></a>引用多态：</h3><ul>
<li>向上转型：父类引用指向子类对象（父类声明，子类创建）<br>Fu f &#x3D; new Zi(); &#x2F;&#x2F; f是子类型，外界看到的是父类型</li>
<li>向下转型：父类引用转为子类对象<br>Zi z &#x3D; (Zi)f; &#x2F;&#x2F; 外界看到的是父类型，强转成子类型后，外界看到是子类型。要求该f必须是能够转换为Zi的，也就是说f本身就是Zi，所以才能转。</li>
<li>使用<strong>instanceof</strong>运算符，判断引用对象的类型，避免类型转换的安全性问题。</li>
</ul>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627171930484-1783703799.png" alt="img"> </p>
<h3 id="方法多态："><a href="#方法多态：" class="headerlink" title="方法多态："></a>方法多态：</h3><ul>
<li>创建本类对象时，调用本类方法；创建子类对象时，调用为子类重写方法或者继承的方法。</li>
<li><strong>重载</strong> <strong>(Overload)</strong>：一个<strong>同名方法</strong>可以传入多个参数组合。</li>
<li><strong>覆写</strong> <strong>(Override)</strong>：由于继承关系中的子类有一个和父类<strong>同名同参数的方法</strong>，会覆盖掉父类的方法。</li>
<li>基本数据类型存在一个方法匹配调用顺序 <strong>char -&gt;</strong> <strong>int</strong> <strong>-&gt; long -&gt; double</strong>，同时也会进行自动装箱，调用包装类方法。</li>
</ul>
<h2 id="引用数据类型的类型转换"><a href="#引用数据类型的类型转换" class="headerlink" title="引用数据类型的类型转换"></a>引用数据类型的类型转换</h2><p>　　a)  引用数据类型比较大小：父类大，子类小。</p>
<p>　　<strong>b)  子类可以直接赋给父类。</strong></p>
<p>　　<strong>c)  父类必须强转才能赋给子类。</strong></p>
<p>　　d)  当父类的引用指向的实例，不是需要的子类类型，则运行时发生异常。</p>
<p>　　e)  当两个类没有继承关系时不能相互转换，否则编译失败。</p>
<h2 id="java-lang-Object"><a href="#java-lang-Object" class="headerlink" title="java.lang.Object"></a>java.lang.Object</h2><p>　　<strong>a)  是JAVA中所有类的父类。</strong></p>
<p>　　b)  toString()：当输出一个类的对象时，或将类的对象与字符串连接时。JVM会自动调用类的toString().</p>
<p>　　<strong>c)  &#x3D;&#x3D;与equals()</strong></p>
<p>　　　　i.   &#x3D;&#x3D;：<strong>判断栈中的内容是否相等</strong>。基本数据类型比较的是值是否相等。引用数据类型比较的是引用是否相等。</p>
<p>　　　　ii.   equals():<strong>判断当前对象与指定对象是否相等（判断堆中的内容是否相等）。equals()最早出现在Object类中，Object中的equals()仍然判断栈中的内容是否相等。如果自定义的类需要判断是否相等时，建议重写Object类中的equals()方法</strong>。</p>
<h1 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p>　　a)  修饰类：抽象类，<strong>抽象类不能实例化(不能new)，只能使用抽象类的子类进行实例化</strong>。</p>
<p>　　　　　　　　抽象类也有构造方法（抽象类的子类需要在自己构造方法的第一行调用父类的构造方法）。</p>
<p>　　　　　　　　那么问题来了：</p>
<p>　　　　　　　　　　抽象类有构造方法，但是不能实例化?构造方法的作用是什么呢?</p>
<p>　　　　　　　　　　用于子类访问父类数据的初始化</p>
<p>　　b)  修饰方法：<strong>抽象方法</strong>，<strong>抽象方法只有方法的声明没有方法的实现</strong>。<strong>子类必须重写父类中所有的抽象方法</strong>（当子类为抽象类时，子类可以不重写父类中的抽象方法或只重写父类中部分的抽象方法）。</p>
<p>　　　　　　　　　抽象方法所在的<strong>类</strong>必须为抽象类。抽象类中不一定有抽象方法。</p>
<p>　　c)   修饰接口</p>
<p>　　<strong>d)  abstract不能与哪些关键字一起使用：final,private,static,</strong></p>
<p>　　　　　　a:final         冲突</p>
<p>　　　　　　b:private    冲突</p>
<p>　　　　　　c:static       无意义</p>
<p>　　<strong>e)  可以使用final关键字定义方法：</strong></p>
<p>　　　　1、修饰类：该类不允许被继承。</p>
<p>　　　　2、修饰方法：方法不能被子类重写。</p>
<p>　　　　3、修饰属性，则该类的该属性不会进行隐式的初始化，<strong>构造方法中必须唯一赋值</strong>。</p>
<p>　　　　4、修饰变量：该变量只能赋一次值，在声明变量的时候才能赋值，即变为常量。</p>
<p>　　　　思考题：final修饰<strong>局部变量</strong>的问题</p>
<p>　　　　　　　　基本类型：基本类型的值不能发生改变。</p>
<p>　　　　　　　　引用类型：引用类型的地址值不能发生改变，但是，该对象的堆内存的值是可以改变的。</p>
<p>　　f)   <strong>阻止类被继承有几种方法</strong>：1.用final修饰类。2.使用private修饰构造方法。</p>
<p>　　总结:</p>
<p>　　　　1).  非抽象类的子类可以为抽象类。</p>
<p>　　　　2).  下面的抽象类可以<strong>new</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Method</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Method</span>() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个类里面有抽象方法，那么这个类一定是抽象类。</li>
<li>抽象类中抽象方法必须被子类全部实现，如果子类不能全部实现，那么子类必须也是抽象类。</li>
</ul>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>　　a)  接口的作用：<strong>使JAVA实现多继承</strong>。</p>
<p>　　b)  接口的成员：</p>
<p>　　　　<strong>i.   常量：接口中的常量必须为public static final。声明后必须赋值。</strong></p>
<p>　　　　ii.  抽象方法：接口中的方法必须为public abstract的。<font color="red">Java 8 开始有变化： <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java8-default-methods.html">Java 8 默认方法 - 菜鸟</a></font> 、 <a href="/article/2020/06/Java%205~11%20%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/">Java 5~11 各个版本新特性总结</a> </p>
<p>　　c)  <strong>类与接口的关系：</strong></p>
<p>　　　　i.   <strong>类可以实现（implements）接口。</strong></p>
<p>　　　　ii.   <strong>当类实现接口时，类必须重写接口中所有的抽象方法。</strong></p>
<p>　　　　iii.  <strong>一个类可以实现多个接口。</strong></p>
<p>　　d)   <strong>接口不是类</strong>，接口中没有构造方法。</p>
<p>　　e)  接口不能实例化（<strong>不能new</strong>）。只能使用接口的<strong>实现类</strong> (其实也可以，使用匿名对象时)。</p>
<p>　　f)   接口与接口之间的关系：</p>
<p>　　　　i.   接口可以继承接口。</p>
<p>　　　　<strong>ii.  一个接口可以继承多个接口。</strong></p>
<ul>
<li><strong>Interface</strong>可以使用反射的代理方法，但<strong>Abstract</strong> <strong>Class</strong>无法实现反射代理。</li>
<li><strong>Interface</strong>里面的方法只能声明，不能有具体的实现。(但在<strong>Java 8</strong>中引入了<strong>default关键字</strong>，此关键字标注接口方法后，允许接口进行默认实现)。</li>
<li>接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。</li>
</ul>
<p>在实际编程中，建议将<em><strong>继承</strong></em>多用于<em><strong>is-a</strong></em>的关系；将<em><strong>接口</strong></em>看做是<em><strong>has-a</strong></em>关系。抽象类功能较之接口虽多，但扩展性不如接口，优先考虑使用接口来解决问题。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类中嵌套另一个类</p>
<ul>
<li>内部类可分为<strong>静态内部类</strong>、<strong>成员内部类</strong>、<strong>方法内部类</strong>、<strong>匿名内部类</strong></li>
<li>内部类提供了<strong>更好的封装</strong>，可以把内部类<strong>隐藏</strong>在外部类之内，<strong>不允许</strong>同一个包中的其他类访问该类。</li>
<li>内部类的方法可以<strong>直接访问外部类的所有成员</strong>，包括<strong>private</strong>。</li>
<li>内部类可以帮助实现多继承功能，但不建议使用；提倡<strong>使用Interface来实现多继承</strong>概念。</li>
</ul>
<h2 id="类、接口-关系"><a href="#类、接口-关系" class="headerlink" title="类、接口 关系"></a>类、接口 关系</h2><p>　　A:类与类</p>
<p>　　　　继承关系，只能单继承，可以多层继承</p>
<p>　　B:类与接口</p>
<p>　　　　实现关系，可以单实现，也可以多实现。</p>
<p>　　　　还可以在继承一个类的同时，实现多个接口</p>
<p>　　C:接口与接口</p>
<p>　　　　继承关系，可以单继承，也可以多继承</p>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>　　A:成员区别</p>
<p>　　　　抽象类：</p>
<p>　　　　　　成员变量：可以变量，也可以常量</p>
<p>　　　　　　构造方法：有</p>
<p>　　　　　　成员方法：可以抽象，也可以非抽象</p>
<p>　　　　接口：</p>
<p>　　　　　　成员变量：只可以常量</p>
<p>　　　　　　成员方法：只可以抽象</p>
<p>　　B:关系区别:</p>
<p>　　　　类与类：继承，单继承</p>
<p>　　　　类与接口：实现，单实现，多实现</p>
<p>　　　　接口与接口：继承，单继承，多继承</p>
<p>　　C:设计理念不同</p>
<p>　　　　抽象类：is a，定义的是共性功能。</p>
<p>　　　　接口： like a，定义的是扩展功能。</p>
<h1 id="形式参数和返回值的问题"><a href="#形式参数和返回值的问题" class="headerlink" title="形式参数和返回值的问题"></a>形式参数和返回值的问题</h1><h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><p>　　类名：需要该类的对象</p>
<p>　　抽象类名：需要该类的子类对象</p>
<p>　　接口名：需要该接口的实现类对象</p>
<p>案例一：</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174643150-86662574.png" alt="img"> </p>
<p>案例二： <img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174658183-1030194297.png" alt="img"> </p>
<p> 案例三：  <img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174711224-1319816506.png" alt="img"> </p>
<h2 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h2><p>　　类名：返回的是该类的对象</p>
<p>　　抽象类名：返回的是该类的子类对象</p>
<p>　　接口名：返回的是该接口的实现类的对象</p>
<p>案例一： <img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174754875-1419777129.png" alt="img"> </p>
<p> 案例二：  <img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174814677-1412793559.png" alt="img"> </p>
<p> 案例三：  <img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174829627-1501258452.png" alt="img"> </p>
<h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p>　　对象.方法1().方法2()…….方法n();</p>
<p>　　这种用法：其实在方法1()调用完毕后，应该一个对象；</p>
<p>　　　　方法2()调用完毕后，应该返回一个对象。</p>
<p>　　　　方法n()调用完毕后，可能是对象，也可以不是对象。</p>
<p>案例： <img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627174918514-517556769.png" alt="img"> </p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>​		就是文件夹</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>  A:区分同名的类</p>
<p>  B:对类进行分类管理</p>
<p>​    a:按照功能分</p>
<p>​    b:按照模块分</p>
<p>举例：</p>
<p>  学生：增加，删除，修改，查询</p>
<p>  老师：增加，删除，修改，查询</p>
<p>  …</p>
<p>  方案1：按照功能分</p>
<p>​    cn.itcast.add</p>
<p>​      AddStudent</p>
<p>​      AddTeacher</p>
<p>​    cn.itcast.delete</p>
<p>​      DeleteStudent</p>
<p>​      DeleteTeacher</p>
<p>​    cn.itcast.update</p>
<p>​      UpdateStudent</p>
<p>​      UpdateTeacher</p>
<p>​    cn.itcast.find</p>
<p>​      FindStudent</p>
<p>​      FindTeacher</p>
<p>  方案2：按照模块分</p>
<p>​    cn.itcast.teacher</p>
<p>​      AddTeacher</p>
<p>​      DeleteTeacher</p>
<p>​      UpdateTeacher</p>
<p>​      FindTeacher</p>
<p>​    cn.itcast.student</p>
<p>​      AddStudent</p>
<p>​      DeleteStudent</p>
<p>​      UpdateStudent</p>
<p>​      FindStudent</p>
<h2 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h2><p>​		package  包名;</p>
<p>​		多级包用.分开。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>  A:package语句必须在文件中的第一条有效语句</p>
<p>  B:在一个java文件中，只能有一个package</p>
<p>  C:如果没有package，默认就是无包名</p>
<h2 id="带包的编译和运行"><a href="#带包的编译和运行" class="headerlink" title="带包的编译和运行"></a>带包的编译和运行</h2><p>  A:手动式</p>
<p>​    a:编写一个带包的java文件。</p>
<p>​    b:通过javac命令编译该java文件。</p>
<p>​    c:手动创建包名。</p>
<p>​    d:把b步骤的class文件放到c步骤的最底层包</p>
<p>​    e:回到和包根目录在同一目录的地方，然后运行带包运行。</p>
<p>  B:自动式</p>
<p>​    a:编写一个带包的java文件。</p>
<p>​    b:javac编译的时候带上-d即可</p>
<p>​      javac -d . HelloWorld.java</p>
<p>​    c:回到和包根目录在同一目录的地方，然后运行带包运行。</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>1、我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。</p>
<p>2、格式：</p>
<p>  <strong>import</strong>包名…类名;</p>
<p>  另一种：</p>
<p>​    <strong>import</strong>包名…*;(不建议)</p>
<p>3、<strong>package</strong>,<strong>import</strong>,class的顺序</p>
<p>  <strong>package</strong> &gt; <strong>import</strong> &gt; <strong>class</strong></p>
<p>  Package:只能有一个</p>
<p>  <strong>import</strong>:可以有多个</p>
<p>  <strong>class</strong>:可以有多个，以后建议是一个</p>
<h1 id="常见的修饰符"><a href="#常见的修饰符" class="headerlink" title="常见的修饰符"></a>常见的修饰符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>​	权限修饰符：private,默认,protected,public</p>
<p>​	状态修饰符：static,final</p>
<p>​	抽象修饰符：abstract</p>
<h2 id="常见的修饰组成"><a href="#常见的修饰组成" class="headerlink" title="常见的修饰组成"></a>常见的修饰组成</h2><p>  类：</p>
<p>​    权限修饰符：默认修饰符，public</p>
<p>​    状态修饰符：final</p>
<p>​    抽象修饰符：abstract</p>
<p>​    　　常用的：public</p>
<p>  成员变量：</p>
<p>​    权限修饰符：private，默认的，protected，public</p>
<p>​    状态修饰符：static，final</p>
<p>​    　　常用的：private</p>
<p>  构造方法：</p>
<p>​    权限修饰符：private，默认的，protected，public</p>
<p>​    　　常用的：public</p>
<p>  成员方法：</p>
<p>​    权限修饰符：private，默认的，protected，public</p>
<p>​    状态修饰符：static，final</p>
<p>​    抽象修饰符：abstract</p>
<p>​    　　常用的：public</p>
<p>例：</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627183542800-405004801.png" alt="img"></p>
<h2 id="另外比较常见的"><a href="#另外比较常见的" class="headerlink" title="另外比较常见的"></a>另外比较常见的</h2><p>  public static final int X &#x3D; 10;</p>
<p>  public static void show() {}</p>
<p>  public final void show() {}</p>
<p>  public abstract void show();</p>
<h1 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h1><p>​		把类定义在另一个类的内部，该类就被称为内部类。</p>
<p>​		举例：把类B定义在类A中，类B就被称为内部类。</p>
<h2 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h2><p>　　A:可以直接访问外部类的成员，包括私有</p>
<p>　　B:外部类要想访问内部类成员，必须创建对象</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184045161-2097194752.png" alt="img"></p>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><p>　　A:成员内部类：在成员位置定义的类</p>
<p>　　B:局部内部类：在局部位置定义的类</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184045411-275941649.png" alt="img"></p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>　　A:private 为了数据的安全性</p>
<p>　　B:static 为了访问的方便性</p>
<p>　　<strong>成员内部类不是静态的：</strong></p>
<p>​				外部类名.内部类名 对象名 &#x3D; new 外部类名.new 内部类名();</p>
<p>  案例1</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184045755-192109891.png" alt="img"></p>
<p>  案例2</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184046137-1450698299.png" alt="img"></p>
<p>　　<strong>成员内部类是静态的：</strong></p>
<p>​				外部类名.内部类名 对象名 &#x3D; new 外部类名.内部类名();</p>
<p>  案例：</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184046482-798732375.png" alt="img"></p>
<p><strong>练习题：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// //结果：30,20,10</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.num);</span><br><span class="line">            <span class="comment">// System.out.println(new Outer().num); //10</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　注意：</p>
<p>　　　　1:内部类和外部类没有继承关系。</p>
<p>　　　　2:通过外部类名限定this对象</p>
<p>　　　　　　Outer.this</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>　　A:局部内部类访问局部变量必须加final修饰。</p>
<p>　　B:为什么呢?</p>
<p>　　　　因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。</p>
<p>　　　　所以，堆内存还是用该变量，而该变量已经没有了。</p>
<p>　　　　为了让该值还存在，就加final修饰。</p>
<p>　　　　通过反编译工具可以知道，加入final后，堆内存直接存储的是值，而不是变量名。</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184046912-1280691095.png" alt="img"></p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>　　A:是局部内部类的简化形式</p>
<p>　　B:前提</p>
<p>　　　　存在一个类或者接口</p>
<p>　　C:格式:</p>
<p>　　　　new 类名或者接口名() {</p>
<p>　　　　　　重写方法;</p>
<p>　　　　}</p>
<p>　　D:本质：</p>
<p>　　　　其实是继承该类或者实现接口的子类匿名对象</p>
<p><img src="/article/2015/10/05Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1118380-20180627184047264-1100962270.png" alt="img"></p>
<p><font color="red">匿名内部类在开发中的使用：</font></p>
<p>　　我们在开发的时候，会看到抽象类，或者接口作为参数。</p>
<p>　　而这个时候，我们知道实际需要的是一个子类对象。</p>
<p>　　如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        p.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PersonDemo</span> <span class="variable">pd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonDemo</span>();</span><br><span class="line">        pd.method(<span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red"> 匿名内部类的思考题（补齐代码）</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="comment">// public abstract void show();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="comment">/************************** 补齐代码 **************************/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Inter <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 子类对象 -- 子类匿名对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inter</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************** 补齐代码 **************************/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.method().show();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1:Outer.method()可以看出method()应该是Outer中的一个静态方法。</span></span><br><span class="line"><span class="comment">        2:Outer.method().show()可以看出method()方法的返回值是一个对象。</span></span><br><span class="line"><span class="comment">            又由于接口Inter中有一个show()方法,所以我认为method()方法的返回值类型是一个接口。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象分析题"><a href="#面向对象分析题" class="headerlink" title="面向对象分析题"></a>面向对象分析题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">分析程序看有没有问题，如果有，说出原因即可。</span><br><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isStupidName</span><span class="params">(String name)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">doSomething</span> <span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">3.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">abstract</span> String <span class="title function_">doSomething</span> <span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addOne</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ++x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Other</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Something</span>().addOne(o);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span> &#123;</span><br><span class="line">       o.i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">7.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">8.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Something</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Something</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;s.doSomething() returns &quot;</span> + doSomething());</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Do something ...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">9.</span></span><br><span class="line">此处，Something类的文件名叫OtherThing.java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] something_to_do)</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Do something ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">10</span>．</span><br><span class="line"><span class="keyword">interface</span>  <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pX</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">C</span>().pX();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="number">11.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Playable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bounceable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rollable</span> <span class="keyword">extends</span> <span class="title class_">Playable</span>, Bounceable &#123;</span><br><span class="line">    <span class="type">Ball</span> <span class="variable">ball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Rollable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ball</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;        </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        ball = <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;Football&quot;</span>);</span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1：局部变量和成员变量的区别?</strong></p>
<ul>
<li><p>在类中位置不同</p>
</li>
<li><p>在内存中位置不同</p>
</li>
<li><p>生命周期不同</p>
</li>
<li><p>初始化值不同</p>
</li>
</ul>
<p><strong>2：形式参数分别为基本类型和引用类型的问题?</strong></p>
<p>形式参数：基本类型 形参的改变不影响实际参数</p>
<p>形式参数：引用类型 形参的改变直接影响实际参数</p>
<p>如果一个方法的形式参数是一个类的名称，那么这里需要的是该类的对象。</p>
<p><strong>3：匿名对象是什么?应用场景是什么?</strong></p>
<p>没有名字的对象。</p>
<p>应用场景：</p>
<p>​	A:调用方法，仅仅调用一次的时候</p>
<p>​	B:作为实际参数传递</p>
<p><strong>4：封装是什么?java中封装的体现有哪些?请举例说明。</strong></p>
<p>封装：隐藏实现细节，提供公共的访问方式。</p>
<p>封装的体现： 类，方法，private修饰成员变量</p>
<p><strong>5：this关键字是什么?this关键字的应用场景?</strong></p>
<p>this:代表当前类的对象应用</p>
<p>应用场景：解决局部变量隐藏成员变量的问题</p>
<p><strong>6：构造方法的作用是什么?构造方法的特点是什么?</strong></p>
<p>构造方法的注意事项是什么?构造方法中可不可以写return语句呢?</p>
<p>作用：用于对对象的数据进行初始化</p>
<p>特点：</p>
<p>　　 A:方法名和类名相同</p>
<p>　　 B:没有返回值类型，连void都不能有</p>
<p>　　 C:没有返回值</p>
<p>注意事项：</p>
<p>　　 A:如果我们不给构造方法，系统就提供一个默认的无参构造方法</p>
<p>　　 B:如果我们给出了构造方法，系统就不再提供默认构造方法</p>
<p>　　 　　 这个时候我们想用，就要自己提供。建议自己提供无参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　 <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">　　 　　 <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">　　 　　 <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">　　 　　 <span class="comment">//getXxx/setXxx</span></span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure>

<p>构造方法可以有return语句，但是不能有明确的返回值。也就是说return;</p>
<p><strong>7：给成员变量赋值有几种方式?</strong></p>
<p>　　 A:setXxx()</p>
<p>　　 B:带参构造方法</p>
<p><strong>8：标准的代码编写及测试：</strong></p>
<p>　　 A:学生类的案例</p>
<p>　　 B:手机类的案例</p>
<p>　　 C:长方形类的案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">　　 <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">　　 　　 <span class="keyword">private</span> String name;</span><br><span class="line">　　 　　 <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">　　 　　 <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">　　 　　 </span><br><span class="line">　　 　　 <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">　　 　　 　　 <span class="keyword">return</span> name;</span><br><span class="line">　　 　　 &#125;</span><br><span class="line">　　 　　 </span><br><span class="line">　　 　　 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">　　 　　 　　 <span class="built_in">this</span>.name = name;</span><br><span class="line">　　 　　 &#125;</span><br><span class="line">　　 　　 </span><br><span class="line">　　 　　 <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">　　 　　 　　 <span class="keyword">return</span> age;</span><br><span class="line">　　 　　 &#125;</span><br><span class="line"></span><br><span class="line">　　 　　 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">　　 　　 　　 <span class="built_in">this</span>.age = age;</span><br><span class="line">　　 　　 &#125;</span><br><span class="line">　　 &#125;</span><br><span class="line"></span><br><span class="line">　　 <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">　　 　　 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">　　 　　 　　 <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">　　 　　 　　 s.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">　　 　　 　　 s.setAge(<span class="number">27</span>);</span><br><span class="line">　　 　　 　　 System.out.println(s.getName()+<span class="string">&quot;---&quot;</span>+s.getAge());</span><br><span class="line">　　 　　 &#125;</span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure>

<p><strong>9：一个类的成员变量初始化过程</strong></p>
<p>　　 Student s &#x3D; new Student();</p>
<p>　　 A:把Student.class文件加载到内存(类加载器)</p>
<p>　　 B:在栈内存为s开辟空间</p>
<p>　　 C:在堆内存为学生对象申请空间</p>
<p>　　 D:给学生对象的成员变量进行默认初始化</p>
<p>　　 E:给学生对象的成员变量进行显示初始化</p>
<p>　　 F:通过构造方法给学生对象的成员变量进行初始化</p>
<p>　　 G:把堆内存的地址赋值给s变量</p>
<p><strong>10：static关键字是什么?有什么特点?什么时候用呢?</strong></p>
<p>　　 static静态的意思，可以修饰成员变量和成员方法。</p>
<p>　　 特点：</p>
<p>　　 　　 A:随着类的加载而加载</p>
<p>　　 　　 B:优先与对象存在</p>
<p>　　 　　 C:被所有对象共享</p>
<p>　　 　　 D:可以通过类名调用</p>
<p>　　 什么时候用?</p>
<p>　　 　　 A:当一个成员被所有对象共享的时候。</p>
<p>　　 　　 B:工具类的时候。</p>
<p><strong>11：静态变量和成员变量的区别</strong></p>
<p>　　 A:所属不同</p>
<p>　　 B:内存位置不同</p>
<p>　　 C:生命周期不同</p>
<p>　　 D:调用不同</p>
<p><strong>12：main方法各种修饰符及参数的解释?</strong></p>
<p>　　 public:权限修饰符，权限最大</p>
<p>　　 static:可以不用创建对象</p>
<p>　　 void:返回值给jvm无意义</p>
<p>　　 main:一个方法名，大家都默认的</p>
<p>　　 String[] args:接收键盘录入对象</p>
<p><strong>13：Java里关于方法的重写(Override)和重载(Overload),下面说法正确的是 (多选)</strong> ABCD</p>
<p>A. 方法重写是指父类与子类之间多态性的一种表现</p>
<p>B. 方法重载是指同一个类中多态性的一种表现</p>
<p>C. 子类中定义的某方法与其父类中的某方法有相同的签名(名称、参数、返回值)，称之为方法重写</p>
<p>D. 一个类中定义了多个同名的方法，但方法签名(名称、参数、返回值)不相同，称之为方法重载</p>
<p><strong>14：以下对封装的描述正确的是</strong> D</p>
<p>A. 只能对一个类中的方法进行封装，不能对属性进行封装 </p>
<p>B. 如果子类继承了父类，对于父类中进行封装的方法，子类仍然可以直接调用 </p>
<p>C. 封装的意义不大，因此在编码时尽量不要使用 </p>
<p>D. 封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性</p>
<p><strong>15：下列关于继承的哪项叙述是正确的</strong> D</p>
<p>A. 在java中类允许多继承</p>
<p>B. 在java中一个类只能实现一个接口</p>
<p>C. 在java中一个类不能同时继承一个类和实现一个接口</p>
<p>D. java的单一继承使代码更可靠</p>
<h1 id="回顾1"><a href="#回顾1" class="headerlink" title="回顾1"></a>回顾1</h1><p><strong>1:代码块是什么?代码块的分类和各自特点?</strong></p>
<p><strong>2:静态代码块,构造代码块,构造方法的执行流程?</strong></p>
<p><strong>3:继承概述</strong></p>
<p><strong>4:继承的好处</strong></p>
<p><strong>5:Java中继承的特点</strong></p>
<p><strong>6:Java中继承的注意事项?以及我们什么时候使用继承?</strong></p>
<p><strong>7:继承中的成员访问特点</strong></p>
<p>　　 A:成员变量</p>
<p>　　 　　 在子类方法中访问一个变量</p>
<p>　　 B:成员方法</p>
<p>　　 　　 在测试类中通过子类对象去访问一个方法</p>
<p><strong>8:继承中构造方法的执行流程?假如父类没有无参构造方法，子类应该怎么办?</strong></p>
<p><strong>9:面试题</strong></p>
<p>方法重写和方法重载的区别?方法重载能改变返回值类型吗?</p>
<p>Overload</p>
<p>Override</p>
<p>this关键字和super关键字分别代表什么?以及他们各自的使用场景和作用。</p>
<p><strong>10:继承案例练习</strong></p>
<p><strong>11:猜数字小游戏练习。</strong></p>
<p>　　 通过API学习并使用Math类的random()方法。</p>
<h1 id="回顾2"><a href="#回顾2" class="headerlink" title="回顾2"></a>回顾2</h1><p><strong>1:final关键字可以干什么?有什么特点?</strong></p>
<p>　　 最终的意思。可以修饰类，方法，变量。</p>
<p>　　 它修饰类，类不能被继承</p>
<p>　　 它修饰方法，方法不能被重写</p>
<p>　　 它修饰变量，变量是常量</p>
<p><strong>2:final关键字的面试题?</strong></p>
<p>　　 A:修饰局部变量</p>
<p>　　 　　 基本类型：值不能改变</p>
<p>　　 　　 引用类型：地址值不能改变</p>
<p>　　 B:初始化时机</p>
<p>　　 　　 定义的时候</p>
<p>　　 　　 构造方法中</p>
<p><strong>3:多态是什么，前提是什么?</strong></p>
<p>　　 同一个对象在不同时刻表现出来的不同的状态</p>
<p>　　 A:有继承或者实现关系</p>
<p>　　 B:有方法的重写</p>
<p>　　 C:有父类或者父接口引用指向子类对象</p>
<p><strong>4:多态中成员访问的特点?</strong></p>
<p>　　 成员变量</p>
<p>　　 　　 编译看左边，运行看左边</p>
<p>　　 成员方法</p>
<p>　　 　　 编译看左边，运行看右边</p>
<p>　　 静态方法</p>
<p>　　 　　 编译看左边，运行看左边</p>
<p><strong>5:多态的好处及弊端？如何解决多态的弊端？</strong></p>
<p>　　 好处：维护性和扩展性</p>
<p>　　 弊端：父类不能使用子类特有功能</p>
<p>　　 如何解决呢?</p>
<p>　　 　　 A:创建子类对象。(在内存中会多了一个对象)</p>
<p>　　 　　 B:向下转型</p>
<p><strong>6:什么是向上转型？什么是向下转型？</strong></p>
<p>　　 子 - 父</p>
<p>　　 父 - 子</p>
<p><strong>7:多态练习</strong>　　</p>
<p>　　 自己做</p>
<p>8:抽象类概述及其特点?</p>
<p>　　 抽象类：继承的时候，提取了多个方法，而有些方法不是每个子类都是一模一样的实现，</p>
<p>　　 这个时候，就应该把这样的方法不提供具体实现，而不提供具体实现的方法是一个抽象方法。</p>
<p>　　 　　 　　 在一个类中，如果有抽象方法，该类必须定义为抽象类。</p>
<p>　　 特点：</p>
<p>　　 　　 A:抽象类或者抽象方法由abstract修饰</p>
<p>　　 　　 B:抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类</p>
<p>　　 　　 C:抽象类不能实例化</p>
<p>　　 　　 D:抽象类的子类</p>
<p>　　 　　 　　 a:是抽象类</p>
<p>　　 　　 　　 b:是具体类，就要重写所有抽象方法</p>
<p><strong>9:抽象类成员特点?</strong></p>
<p>　　 A:成员变量</p>
<p>　　 　　 有变量，有常量</p>
<p>　　 B:构造方法</p>
<p>　　 　　 有。用于子类访问父类数据的初始化</p>
<p>　　 C:成员方法</p>
<p>　　 　　 有抽象方法，有非抽象方法</p>
<p><strong>10:抽象类练习?</strong></p>
<p><strong>11:抽象类的小问题</strong></p>
<p>　　 A:一个类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义?</p>
<p>　　 B:abstract不能和哪些关键字共存</p>
<p>　　 　　 final</p>
<p>　　 　　 static</p>
<p>　　 　　 private</p>
<p><strong>12:接口的概述及其特点?</strong></p>
<p>　　 接口：某个继承体系需要扩展功能的时候，就应该实现接口。</p>
<p>　　 特点：</p>
<p>　　 　　 A:接口用interface修饰</p>
<p>　　 　　 B:类实现接口用implements修饰</p>
<p>　　 　　 C:接口不能实例化</p>
<p>　　 　　 D:接口的实现</p>
<p>　　 　　 　　 a:抽象类</p>
<p>　　 　　 　　 b:具体类，重写接口中的所有抽象方法</p>
<p><strong>13:接口的成员特点?</strong></p>
<p>　　 A:成员变量 静态常量</p>
<p>　　 B:成员方法 抽象的</p>
<p><strong>14:抽象类和接口的区别?</strong></p>
<p>　　 A:成员区别</p>
<p>　　 B:关系区别</p>
<p>　　 C:设计理念区别</p>
<p>　　 　　 “is a”</p>
<p>　　 　　 “like a”</p>
<h1 id="回顾3"><a href="#回顾3" class="headerlink" title="回顾3"></a>回顾3</h1><p><strong>1:形式参数和返回值问题</strong></p>
<p>　　 形式参数</p>
<p>　　 　　 基本类型</p>
<p>　　 　　 引用类型</p>
<p>　　 返回值类型</p>
<p>　　 　　 基本类型　　</p>
<p>　　 　　 引用类型</p>
<p><strong>2:包的定义及注意事项</strong></p>
<p>package</p>
<p>第一条有效语句</p>
<p>唯一</p>
<p><strong>3:导包及注意事项</strong></p>
<p>　　 import</p>
<p>java.lang不需要导入</p>
<p>　　 java.xxx.yyy.类名; 导入到类的级别</p>
<p>java.xxx.yyy.*; 这个也可以，但是不建议</p>
<p><strong>4:四种权限修饰符及其特点</strong></p>
<p><strong>5:常见的修饰符及组合</strong></p>
<p>　　 类：public</p>
<p>　　 成员变量：private</p>
<p>　　 构造方法：public</p>
<p>　　 成员方法：public</p>
<p><strong>6:内部类的概述及访问特点</strong></p>
<p>　　 把类定义在另一个类的内部，叫内部类。</p>
<p>　　 访问特点：</p>
<p>　　 　　 内部类可以直接访问外部类的成员，包括私有</p>
<p>　　 　　 外部类访问内部类的成员需要创建对象</p>
<p><strong>7:内部类的分类</strong></p>
<p>按照位置不同：成员内部类、局部内部类</p>
<p><strong>8:匿名内部类的格式和应用及面试题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　 new 类名或者接口名() &#123;</span><br><span class="line"></span><br><span class="line">　　 　　 重写方法;</span><br><span class="line"></span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"># Java基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2015/10/04Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/" rel="prev" title="04Java修饰符">
                  <i class="fa fa-angle-left"></i> 04Java修饰符
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2015/10/06Java%E5%B8%B8%E7%94%A8%E7%B1%BB1/" rel="next" title="06Java常用类1">
                  06Java常用类1 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
