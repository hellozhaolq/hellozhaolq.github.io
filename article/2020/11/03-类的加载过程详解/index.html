<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="类的加载过程详解">
<meta property="og:type" content="article">
<meta property="og:title" content="03-类的加载过程详解">
<meta property="og:url" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="类的加载过程详解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/format,jpg.jpeg">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826901-1.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-2.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-3.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-4.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-5.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-6.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-7.png">
<meta property="article:published_time" content="2020-11-03T01:00:00.000Z">
<meta property="article:modified_time" content="2020-11-03T01:00:00.000Z">
<meta property="article:author" content="zhaolq">
<meta property="article:tag" content="JVM中篇：字节码与类的加载篇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit.png">


<link rel="canonical" href="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","path":"article/2020/11/03-类的加载过程详解/","title":"03-类的加载过程详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>03-类的加载过程详解 | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">耳不闻人是非，目不视人之短，口不言人之过。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">大厂面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%80%EF%BC%9ALoading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">2.</span> <span class="nav-text">过程一：Loading（加载）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.</span> <span class="nav-text">加载完成的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">二进制流的获取方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B8%8EClass%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.3.</span> <span class="nav-text">类模型与Class实例的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.4.</span> <span class="nav-text">数组类的加载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E4%BA%8C%EF%BC%9ALinking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">3.</span> <span class="nav-text">过程二：Linking（链接）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E8%8A%821%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8BVerification%EF%BC%88%E9%AA%8C%E8%AF%81%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">环节1：链接阶段之Verification（验证）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E8%8A%822%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8BPreparation%EF%BC%88%E5%87%86%E5%A4%87%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">环节2：链接阶段之Preparation（准备）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E8%8A%823%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8BResolution%EF%BC%88%E8%A7%A3%E6%9E%90%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">环节3：链接阶段之Resolution（解析）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%89%EF%BC%9AInitialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">4.</span> <span class="nav-text">过程三：Initialization（初始化）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E4%B8%8Efinal%E7%9A%84%E6%90%AD%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.</span> <span class="nav-text">static与final的搭配问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">4.2.</span> <span class="nav-text">&lt;clinit&gt;()的线程安全性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">类的初始化情况：主动使用vs被动使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">I 主动使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#II-%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">II 被动使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%9B%9B%EF%BC%9A%E7%B1%BB%E7%9A%84Using%EF%BC%88%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">过程四：类的Using（使用）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E4%BA%94%EF%BC%9A%E7%B1%BB%E7%9A%84Unloading%EF%BC%88%E5%8D%B8%E8%BD%BD%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">过程五：类的Unloading（卸载）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">6.1.</span> <span class="nav-text">类、类的加载器、类的实例之间的引用关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.2.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90"><span class="nav-number">6.3.</span> <span class="nav-text">具体例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="nav-number">6.4.</span> <span class="nav-text">类的卸载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">6.5.</span> <span class="nav-text">回顾：方法区的垃圾回收</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">555</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="03-类的加载过程详解 | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          03-类的加载过程详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-03 09:00:00" itemprop="dateCreated datePublished" datetime="2020-11-03T09:00:00+08:00">2020-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>类的加载过程详解</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</p>
<p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段：</p>
<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit.png" alt="类的生命周期">类的生命周期</p>
<p>其中，验证、准备、解析3个部分统称为链接（Linking）</p>
<p>从程序中类的使用过程看</p>
<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/format,jpg.jpeg" alt="类的使用">类的使用</p>
<blockquote>
<p>[!NOTE]</p>
<p>我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</p>
</blockquote>
<h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><p><strong>蚂蚁金服：</strong></p>
<ul>
<li>描述一下JVM加载Class文件的原理机制？</li>
<li>一面：类加载过程</li>
</ul>
<p><strong>百度：</strong></p>
<ul>
<li>类加载的时机</li>
<li>Java类加载过程？</li>
<li>简述Java类加载机制？</li>
</ul>
<p><strong>腾讯：</strong></p>
<ul>
<li>JVM中类加载机制，类加载过程？</li>
</ul>
<p><strong>滴滴：</strong></p>
<ul>
<li>JVM类加载机制</li>
</ul>
<p><strong>美团：</strong></p>
<ul>
<li>Java类加载过程</li>
<li>描述一下jvm加载class文件的原理机制</li>
</ul>
<p><strong>京东：</strong></p>
<ul>
<li>什么是类的加载？</li>
<li>哪些情况会触发类的加载？</li>
<li>讲一下JVM加载一个类的过程JVM的类加载机制是什么？</li>
</ul>
<h1 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h1><h2 id="加载完成的操作"><a href="#加载完成的操作" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h2><p><strong>加载的理解</strong></p>
<p><strong>所谓加载，简而言之就是将]ava类的字节码文件加载到机器内存中，并在内存中构建出]ava类的原型–类模板对象</strong>。所谓类模板对象，其实就是]ava类在IVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取]ava类中的任意信息，能够对]ava类的成员变量进行遍历，也能进行Java方法的调用。</p>
<p>反射的机制即基于这一基础。如果JVM没有将]ava类的声明信息存储起来，则JVM在运行期也无法反射,</p>
<p><strong>加载完成的操作</strong></p>
<p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成class的实例。</strong></p>
<p>在加载类时，Java虚拟机必须完成以下3件事情:</p>
<ul>
<li>通过类的全名，获取类的二进制数据流。</li>
<li>解析类的二进制数据流为方法区内的数据结构(Java类模型)</li>
<li>创建<code>java.lang.Class</code>类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<h2 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h2><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（<strong>只要所读取的字节码符合JVM规范即可</strong>）</p>
<ul>
<li>虚拟机可能通过文件系统读入一个class后缀的文件<font color="red">（最常见）</font></li>
<li>读入jar、zip等归档数据包，提取类文件。</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于HTTP之类的协议通过网络进行加载</li>
<li>在运行时生成一段class的二进制信息等</li>
<li>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个<code>java.lang.Class</code>的实例。</li>
</ul>
<p>如果输入数据不是<code>ClassFile</code>的结构，则会抛出<code>ClassFormatError</code>。</p>
<h2 id="类模型与Class实例的位置"><a href="#类模型与Class实例的位置" class="headerlink" title="类模型与Class实例的位置"></a>类模型与Class实例的位置</h2><p><strong>1. 类模型的位置</strong></p>
<p>加载的类在JVM中创建相应的类结构，类结构会存储在方法区（JDKl.8之前：永久代；J0Kl.8及之后：元空间）。</p>
<p><strong>2. Class实例的位置</strong></p>
<p>类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。</p>
<p><strong>3. 图示</strong></p>
<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826901-1.png" alt="Class实例">Class实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前运行时类声明的所有方法</span></span><br><span class="line">Method[] ms = clazz.getDecla#FF0000Methods();</span><br><span class="line"><span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">    <span class="comment">//获取方法的修饰符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mod</span> <span class="operator">=</span> Modifier.toString(m.getModifiers());</span><br><span class="line">    System.out.print(mod + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> (m.getReturnType()).getSimpleName();</span><br><span class="line">    System.out.print(returnType + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//获取方法名</span></span><br><span class="line">    System.out.print(m.getName() + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">    <span class="comment">//获取方法的参数列表</span></span><br><span class="line">    Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (ps.length == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ps.length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">end</span> <span class="operator">=</span> (i == ps.length - <span class="number">1</span>) ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="comment">//获取参教的类型</span></span><br><span class="line">        System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h2><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称A）的过程：</p>
<ol>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；</li>
<li>JVM使用指定的元素类型和数组维度来创建新的数组类。</li>
</ol>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</p>
<h1 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h1><h2 id="环节1：链接阶段之Verification（验证）"><a href="#环节1：链接阶段之Verification（验证）" class="headerlink" title="环节1：链接阶段之Verification（验证）"></a>环节1：链接阶段之Verification（验证）</h2><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p><strong>它的目的是保证加载的字节码是合法、合理并符合规范的。</strong></p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示。</p>
<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-2.png" alt="验证阶段的检查">验证阶段的检查</p>
<p>整体说明：</p>
<p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p>
<ul>
<li>其中<strong>格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li>
</ul>
<p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p>
<p><strong>具体说明：</strong></p>
<ol>
<li><p><strong>格式验证</strong>：是否以魔数<code>0XCAFEBABE</code>开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p>
</li>
<li><p><strong>语义检查</strong>：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p>
<ul>
<li>是否所有的类都有父类的存在（在Java里，除了<code>object</code>外，其他类都应该有父类）</li>
<li>是否一些被定义为final的方法或者类被重写或继承了</li>
<li>非抽象类是否实现了所有抽象方法或者接口方法</li>
</ul>
</li>
<li><p><strong>字节码验证</strong>：Java虚拟机还会进行字节码验证，<strong>字节码验证也是验证过程中最为复杂的一个过程</strong>。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p>
<p><strong>在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p>
</li>
<li><p>符号引用的验证：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出<code>NoClassDefFoundError</code>，如果一个方法无法被找到，则会抛出<code>NoSuchMethodError</code>。此阶段在解析环节才会执行。</p>
</li>
</ol>
<h2 id="环节2：链接阶段之Preparation（准备）"><a href="#环节2：链接阶段之Preparation（准备）" class="headerlink" title="环节2：链接阶段之Preparation（准备）"></a>环节2：链接阶段之Preparation（准备）</h2><p><strong>准备阶段(Preparation)，简言之，为类的静态变量分配内存，并将其初始化为默认值。</strong></p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值Java虚拟机为各类型变量默认的初始值如表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>注意：Java并不支持boolean类型，对于boolean类型，内部实现是in，由于int的默认值是0，故对应的boolean默认值就是false。</p>
<blockquote>
<p>[!CAUTION]</p>
<ol>
<li><strong>这里不包含基本数据类型的字段用<code>static final</code>修饰的情况，因为<code>final</code>在编译的时候就会分配了，准备阶段会显式赋值。</strong></li>
<li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。</li>
<li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</li>
</ol>
</blockquote>
<blockquote>
<p>[!NOTE]</p>
<p>对 Caution 中的第1点分析：</p>
<p>注意：以下前3点的前提都是字段已经完成显示赋值（定义的后面已经赋了值）的前提下进行的</p>
<ol>
<li>非final修饰的静态变量会在准备阶段赋初始值，然后在初始化中的<code>&lt;client&gt;</code>方法中显示赋值</li>
<li>静态常量（基本数据类型、String类型字面量（”XXX”这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值</li>
<li>引用数据类型的静态常量，尤其是<code>new String(&quot;XXX&quot;)</code>这种形式，都是在初始化中的<code>&lt;client&gt;</code>中进行显示赋值的</li>
<li>如果在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在初始化中的<code>&lt;client&gt;</code>方法中显示赋值</li>
</ol>
</blockquote>
<h2 id="环节3：链接阶段之Resolution（解析）"><a href="#环节3：链接阶段之Resolution（解析）" class="headerlink" title="环节3：链接阶段之Resolution（解析）"></a>环节3：链接阶段之Resolution（解析）</h2><p>在准备阶段完成后，就进入了解析阶段。<br><strong>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p>
<p><strong>具体描述：</strong></p>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p>
<p>举例：</p>
<p>输出操作<code>System.out.println()</code>对应的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual #<span class="number">24</span> &lt;java/io/PrintStream.println&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-3.png" alt="img"></p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用</strong>。</p>
<h1 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h1><p><strong>初始化阶段，简言之，为类的静态变量赋予正确的初始值。</strong></p>
<p><strong>1.具体描述</strong></p>
<p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即:到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。)</p>
<p><strong>初始化阶段的重要工作是执行类的初始化方法:<code>&lt;clinit&gt;()</code>方法。</strong></p>
<ul>
<li>该方法仅能由]ava编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是由类静态成员的赋值语句以及<code>static</code>语句块合并产生的。</li>
</ul>
<p><strong>2.说明</strong></p>
<p>2.1 在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<code>&lt;c1init&gt;</code>总是在子类<code>&lt;clinit&gt;</code>之前被调用。也就是说，父类的static块优先级高于子类。</p>
<p>2.2 Java编译器并不会为所有的类都产生<code>&lt;cinit&gt;()</code>初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<code>&lt;clinit&gt;()</code>方法?</p>
<ul>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li>
<li>一个类中包含<code>static final</code>修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</li>
</ul>
<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-4.png" alt="img"></p>
<h2 id="static与final的搭配问题"><a href="#static与final的搭配问题" class="headerlink" title="static与final的搭配问题"></a>static与final的搭配问题</h2><p><strong>说明:</strong><br>使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值?</p>
<ul>
<li>情况1:在链接阶段的准备环节赋值</li>
<li>情况2:在初始化阶段<code>&lt;clinit&gt;()</code>中赋值</li>
</ul>
<p><strong>结论:</strong></p>
<p>在链接阶段的准备环节赋值的情况:</p>
<ol>
<li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法)通常是在链接阶段的准备环节进行</li>
<li>对于string米说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</li>
</ol>
<hr>
<p>在初始化阶段<code>&lt;clinit&gt;()</code>中赋值的情况:<br>排除上述的在准备环节赋值的情况之外的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> a=<span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.value0f(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.value0f(<span class="number">1888</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">string</span> <span class="variable">s0</span> <span class="operator">=</span><span class="string">&quot;helloworld&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> string s1= <span class="keyword">new</span> <span class="title class_">string</span>( original: <span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">string</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt( bound: <span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终结论：</strong></p>
<p>使用<code>static+final</code>修饰，并且进行显示赋值（定义的时候后面就已经附了初始值），还不涉及到方法或者构造器调用的基本数据类型或者<code>String</code>类型字面量(<code>XXX</code>这种形式，而不是<code>new String(&quot;XXX&quot;)</code>这种形式)的字段，将在准备中的链接阶段进行显示赋值，其他已经进行显示赋值的静态常量（包括引用类型，尤其是<code>new String(&quot;XXX&quot;)</code>这种类型的，还有调用其他方法获得的值，比如<code>new Random().nextInt(10)</code>等）或者静态变量（这是肯定在初始化<code>&lt;client&gt;</code>方法中显示赋值）都将在初始化中的<code>&lt;client&gt;</code>方法中进行显示赋值</p>
<p>对于准备阶段就完成赋值的，其字段下面的有属性<code>ConstantValue</code>，否则是没有属性<code>ConstantValue</code>的，如下：</p>
<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-5.png" alt="img"></p>
<p>在初始化中的<code>&lt;client&gt;</code>方法中完成赋值的，引用类型静态常量的例子我就不举了，我举一个静态变量的例子吧，如下：</p>
<p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-6.png" alt="img"></p>
<h2 id="的线程安全性"><a href="#的线程安全性" class="headerlink" title="&lt;clinit&gt;()的线程安全性"></a><code>&lt;clinit&gt;()</code>的线程安全性</h2><p>对于<code>&lt;clinit&gt;()</code>方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p>
<p>正是<strong>因为函数<code>&lt;clinit&gt;()</code>带锁线程安全的</strong>，因此，如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<code>&lt;clinit&gt;()</code>方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
<h2 id="类的初始化情况：主动使用vs被动使用"><a href="#类的初始化情况：主动使用vs被动使用" class="headerlink" title="类的初始化情况：主动使用vs被动使用"></a>类的初始化情况：主动使用vs被动使用</h2><p>Java程序对类的使用分为两种：主动使用和被动使用。</p>
<h3 id="I-主动使用"><a href="#I-主动使用" class="headerlink" title="I 主动使用"></a>I 主动使用</h3><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p>
<ol>
<li>实例化：当创建一个类的实例时，比如使用<code>new</code>关键字，或者通过反射、克隆、反序列化。</li>
<li>静态方法：当调用类的静态方法时，即当使用了字节码<code>invokestatic</code>指令。</li>
<li>静态字段：当使用类、接口的静态字段时（<code>final</code>修饰特殊考虑），比如，使用<code>getstatic</code>或者<code>putstatic</code>指令。（对应访问变量、赋值变量操作）</li>
<li>当使用<code>java.lang.reflect</code>包中的方法反射类的方法时。比如:<code>Class.forName(&quot;com.atguigu.java.Test”)</code></li>
<li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>如果一个接口定义了<code>default</code>方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含<code>main()</code>方法的那个类)，虚拟机会先初始化这个主类。</li>
<li>当初次调用 <code>MethodHandle</code>实例时，初始化该 <code>MethodHandle</code> 指向的方法所在的类。(涉及解析<code>REF_getstatic</code>、<code>REF_putstatic</code>、<code>REF_invokestatic</code>方法句柄对应的类)</li>
</ol>
<blockquote>
<p>[!TIP]</p>
<p><strong>针对5，补充说明:</strong></p>
<p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
</ul>
<p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</p>
</blockquote>
<blockquote>
<p>[!TIP]</p>
<p><strong>针对7，说明:</strong></p>
<p>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用<code>public static void main(string[])</code>方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
</blockquote>
<h3 id="II-被动使用"><a href="#II-被动使用" class="headerlink" title="II 被动使用"></a>II 被动使用</h3><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化。</strong></p>
<p>也就是说:<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</strong></p>
<ol>
<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。<ul>
<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul>
</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</li>
<li>调用classLoader类的loadclass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li>
</ol>
<hr>
<p>如果针对代码，设置参数<code>-XX:+TraceClassLoading</code>，可以追踪类的加载信息并打印出来。</p>
<h1 id="过程四：类的Using（使用）"><a href="#过程四：类的Using（使用）" class="headerlink" title="过程四：类的Using（使用）"></a>过程四：类的Using（使用）</h1><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</p>
<h1 id="过程五：类的Unloading（卸载）"><a href="#过程五：类的Unloading（卸载）" class="headerlink" title="过程五：类的Unloading（卸载）"></a>过程五：类的Unloading（卸载）</h1><h2 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h2><p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的java类都有一个静态属性class，它引用代表这个类的Class对象。</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p>
<p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</strong></p>
<h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p><img src="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/resize,l_1200,m_lfit-1733380826902-7.png" alt="类的卸载具体例子.png">类的卸载具体例子.png</p>
<p><code>loader1</code>变量和<code>obj</code>变量间接应用代表<code>Sample</code>类的Class对象，而<code>objClass</code>变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为<code>null</code>，此时<code>Sample</code>对象结束生命周期，<code>MyClassLoader</code>对象结束生命周期，代表<code>Sample</code>类的Class对象也结束生命周期，<code>Sample</code>类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查<code>Sample</code>类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在<code>Sample</code>类会被重新加载，在Java虚拟机的堆区会生成一个新的代表<code>Sample</code>类的Class实例（可以通过哈希码查看是否是同一个实例）</p>
<h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><ul>
<li>（1）启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm和jls规范）</li>
<li>（2）被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</li>
<li>（3）被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</li>
</ul>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>
<h2 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h2><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等,否则通常是很难达成的。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/" rel="tag"># JVM中篇：字节码与类的加载篇</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/" rel="prev" title="02-字节码指令集与解析举例">
                  <i class="fa fa-angle-left"></i> 02-字节码指令集与解析举例
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2020/11/04-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" rel="next" title="04-再谈类的加载器">
                  04-再谈类的加载器 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
