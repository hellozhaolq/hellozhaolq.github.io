<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="本文对JVM中的字节码指令做了详细的介绍，包括加载与存储指令、算数指令、对象创建与访问指令、方法调用与返回指令、操作数栈管理指令、控制转义指令等。">
<meta property="og:type" content="article">
<meta property="og:title" content="02-字节码指令集与解析举例">
<meta property="og:url" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="本文对JVM中的字节码指令做了详细的介绍，包括加载与存储指令、算数指令、对象创建与访问指令、方法调用与返回指令、操作数栈管理指令、控制转义指令等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-1.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-2.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-3.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-4.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-5.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-6.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-7.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-8.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-9.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-10.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-11.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/db0c0a6c23cb4fcbb5241191a1ed4989.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/dde6520419cd4723b6bbfd1044705240.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-12.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-13.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-14.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-15.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-16.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-17.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-18.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-19.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-20.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-21.png">
<meta property="article:published_time" content="2020-11-02T01:00:00.000Z">
<meta property="article:modified_time" content="2020-11-02T01:00:00.000Z">
<meta property="article:author" content="zhaolq">
<meta property="article:tag" content="JVM中篇：字节码与类的加载篇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit.png">


<link rel="canonical" href="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/","path":"article/2020/11/02-字节码指令集与解析举例/","title":"02-字节码指令集与解析举例"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>02-字节码指令集与解析举例 | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">贪婪，找不到比这更好的词了，是件好事。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">执行模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">字节码与数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">指令分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">加载与存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">再谈操作数栈与局部变量表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">局部变量压栈指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">2.3.</span> <span class="nav-text">常用入栈指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BA%E6%A0%88%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">出栈入局部变量表指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">算术指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.</span> <span class="nav-text">所有算术指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">3.2.</span> <span class="nav-text">比较指令的说明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">类型转换指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%BD%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.1.</span> <span class="nav-text">宽化类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.2.</span> <span class="nav-text">窄化类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">对象的创建与访问指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="nav-number">5.1.</span> <span class="nav-text">创建指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">5.2.</span> <span class="nav-text">字段访问指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">5.3.</span> <span class="nav-text">数组操作指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.</span> <span class="nav-text">类型检查指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">6.</span> <span class="nav-text">方法调用与返回指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">6.1.</span> <span class="nav-text">方法调用指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">6.2.</span> <span class="nav-text">方法返回指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">7.</span> <span class="nav-text">操作数栈管理指令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">8.</span> <span class="nav-text">控制转义指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">8.1.</span> <span class="nav-text">条件跳转指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">8.2.</span> <span class="nav-text">比较条件跳转指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC"><span class="nav-number">8.3.</span> <span class="nav-text">多条件分支跳转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="nav-number">8.4.</span> <span class="nav-text">无条件跳转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">异常处理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="nav-number">9.1.</span> <span class="nav-text">抛出异常指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="nav-number">9.2.</span> <span class="nav-text">异常处理与异常表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">10.</span> <span class="nav-text">同步控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">10.1.</span> <span class="nav-text">方法级的同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E6%8C%87%E4%BB%A4%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">10.2.</span> <span class="nav-text">方法内指令指令序列的同步</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">554</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="02-字节码指令集与解析举例 | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          02-字节码指令集与解析举例
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-02 09:00:00" itemprop="dateCreated datePublished" datetime="2020-11-02T09:00:00+08:00">2020-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文对JVM中的字节码指令做了详细的介绍，包括加载与存储指令、算数指令、对象创建与访问指令、方法调用与返回指令、操作数栈管理指令、控制转义指令等。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</li>
<li>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands)而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li>
<li>由于限制了Java虚拟机操作码的长度为一个字节(即0～255)，这意味着指令集的操作码总数不可能超过256 条。</li>
<li>熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础技能，需要熟练掌握常见指令。</li>
</ul>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></p>
<h2 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h2><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    自动计算PC寄存器的值加1;</span><br><span class="line">    根据PC寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">    if(字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">    执行操作码所定义的操作;</span><br><span class="line">&#125;while(字节码长度&gt;0)；</span><br></pre></td></tr></table></figure>

<h2 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h2><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p>
<ul>
<li>i代表对int类型的数据操作，</li>
<li>l代表long</li>
<li>s代表short</li>
<li>b代表byte</li>
<li>c代表char</li>
<li>f代表float</li>
<li>d代表double</li>
</ul>
<p>也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</p>
<p>还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。</p>
<p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</p>
<h2 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h2><p>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。</p>
<ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令</li>
<li>操作数栈管理指令</li>
<li>比较控制指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
<p>（说在前面）在做值相关操作时：</p>
<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。</li>
</ul>
<h1 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h1><p><strong>作用</strong></p>
<p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p>
<p><strong>常用指令</strong></p>
<ol>
<li>【局部变量压栈指令】将一个局部变量加载到操作数栈：<code>xload、xload_&lt;n&gt;</code>（其中x为i、l、f、d、a，n为0到3）</li>
<li>【常量入栈指令】将一个常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、lconst_&lt;l&gt;）、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code></li>
<li>【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：<code>xstore、xstore_&lt;n&gt;</code>（其中x为i、l、f、d、a，n为0到3）；<code>xastore</code>（其中x为i、l、f、d、a、b、c、s）</li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code>。</li>
</ol>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>）。这些指令助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>代表了<code>iload_0、iload_1、iload_2</code>和<code>iload_3</code>这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式，对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</p>
<p>除此之外，它们的语义与原生的通用指令完全一致（例如<code>iload_0</code>的语义与操作数为0时的<code>iload</code>指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code> 代表是<code>int</code>类型数据，<code>&lt;l&gt;</code>代表<code>long</code>类型，<code>&lt;f&gt;</code>代表<code>float</code>类型，<code>&lt;d&gt;</code>代表<code>double</code>类型。</p>
<p>操作<code>byte、char、short</code>和<code>boolean</code>类型数据时，经常用<code>int</code>类型的指令来表示。</p>
<h2 id="再谈操作数栈与局部变量表"><a href="#再谈操作数栈与局部变量表" class="headerlink" title="再谈操作数栈与局部变量表"></a>再谈操作数栈与局部变量表</h2><p><strong>操作数栈（Operand Stacks）</strong></p>
<p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>具体来说便是：执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit.png" alt="img"></p>
<p>以加法指令iadd为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int，并将求得的和int值3压入栈中。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-1.png" alt="img"></p>
<p>由于iadd指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<p><strong>局部变量表（Local Variables）</strong></p>
<p>Java方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p>
<p>实际上，Java虚拟机将局部变量区当成一个数组，依次存放this指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p>
<p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-2.png" alt="img"></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">long</span> l, <span class="type">float</span> f)</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的图示：</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-3.png" alt="img"></p>
<p>this表示当前类的引用，l和f的类型的值占两个槽位，i和s变量由于分别在各自代码块中，没有共同的生命周期，所以占同一个槽位（即槽位复用）</p>
<p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h2 id="局部变量压栈指令"><a href="#局部变量压栈指令" class="headerlink" title="局部变量压栈指令"></a>局部变量压栈指令</h2><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。</p>
<p>这类指令大体可以分为：</p>
<ul>
<li><code>xload_&lt;n&gt;</code>（x为i、l、f、d、a，n为0到3）</li>
<li><code>xload</code>（x为i、l、f、d、a）</li>
</ul>
<p>说明：在这里，x的取值表示数据类型。</p>
<p>指令 <code>xload_n</code> 表示将第 <code>n</code> 个局部变量压入操作数栈，比如 <code>iload_1、fload_0、aload_0</code> 等指令。其中 <code>aload_n</code> 表示将一个对象引用压栈。</p>
<p>指令 <code>xload</code> 通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令 <code>iload、fload</code> 等。</p>
<p>举例分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num, Object obj, <span class="type">long</span> count, <span class="type">boolean</span> flag, <span class="type">short</span>[] arr)</span> &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-4.png" alt="img"></p>
<h2 id="常用入栈指令"><a href="#常用入栈指令" class="headerlink" title="常用入栈指令"></a>常用入栈指令</h2><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列、push系列和ldc指令。</p>
<p>指令const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code>iconst_&lt;i&gt;（i从-1到5）、lconst_&lt;l&gt;（1从0到1）、fconst_&lt;f&gt;（f从0到2）、dconst_&lt;d&gt;（d从0到1）、aconst_null</code>。比如，</p>
<ul>
<li><code>iconst_m1</code>将-1压入操作数栈；</li>
<li><code>iconst_x</code>（x为0到5）将x压入栈；</li>
<li><code>lconst_0、lconst_1</code> 分别将长整数0和1压入栈；</li>
<li><code>fconst_0、fconst_1、fconst_2</code> 分别将浮点数0、1、2压入栈；</li>
<li><code>dconst_0</code> 和 <code>dconst_1</code> 分别将 <code>double</code> 型0和1压入栈；</li>
<li><code>aconst_null </code>将 <code>null</code> 压入操作数栈；</li>
</ul>
<p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，l表示长整数，f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p>
<p>指令push系列：主要包括bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p>
<p>指令ldc系列：如果以上指令都不能满足需求，那么可以使用万能的</p>
<ul>
<li><code>ldc</code>指令，它可以接收一个8位的参数，该参数指向常量池中的 <code>int</code> 、 <code>float</code> 或者 <code>String</code> 的索引，将指定的内容压入堆栈。</li>
<li>类似的还有 <code>ldc_w</code> ，它接收两个8位参数，能支持的索引范围大于 <code>ldc</code>。</li>
<li>如果要压入的元素是 <code>long</code> 或者 <code>double</code> 类型的，则使用 <code>ldc2_w</code> 指令，使用方式都是类似的</li>
</ul>
<p>总结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>常数指令</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>int(boolean,byte,char,short)</td>
<td>iconst</td>
<td>[-1, 5]</td>
</tr>
<tr>
<td>bipush</td>
<td>[-128, 127]</td>
<td></td>
</tr>
<tr>
<td>sipush</td>
<td>[-32768, 32767]</td>
<td></td>
</tr>
<tr>
<td>ldc</td>
<td>any int value</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>lconst</td>
<td>0, 1</td>
</tr>
<tr>
<td>ldc</td>
<td>any long value</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>fconst</td>
<td>0, 1, 2</td>
</tr>
<tr>
<td>ldc</td>
<td>any float value</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>dconst</td>
<td>0, 1</td>
</tr>
<tr>
<td>ldc</td>
<td>any double value</td>
<td></td>
</tr>
<tr>
<td>reference</td>
<td>aconst</td>
<td>null</td>
</tr>
<tr>
<td>ldc</td>
<td>String literal, Class literal</td>
<td></td>
</tr>
</tbody></table>
<p><strong>举例解释如下：</strong></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-5.png" alt="img"></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-6.png" alt="img"></p>
<p>注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，本次的n代表数值或者对象，而不是局部变量表中的下标</p>
<h2 id="出栈入局部变量表指令"><a href="#出栈入局部变量表指令" class="headerlink" title="出栈入局部变量表指令"></a>出栈入局部变量表指令</h2><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以store的形式存在，比如<code>xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0至3）</code>。</p>
<ul>
<li>其中，指令<code>istore_n</code>将从操作数栈中弹出一个整数，并把它值给局部变量索引n位置。</li>
<li>指令<code>xstore</code>由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。</li>
</ul>
<p>说明：一般说来，类似像<code>store</code>这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的<code>istore_1</code>指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有<code>istore_0</code>、<code>istore_2</code>、<code>istore_3</code>，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<p><strong>举例分析如下：</strong></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-7.png" alt="img"></p>
<blockquote>
<p>[!NOTE]</p>
<p>里面有代码，也有字节码，所以可以根据老师给的图展开分析，首先该方法被调用的时候，形式参数k和d都是有确定的值，由于该方法不是静态方法，所以局部变量表中的第一个位置（槽位）存储this，</p>
<p>而第二个位置存储k具体的值，由于老师只是分析，没有调用这个方法，所以老师全部使用的变量名称来代替具体的值，所以明白就好，继续来分析，然后第三个和第四个位置储存d具体的值，由于d是double类型，所以需要占据两个槽位，</p>
<p>数据已经准备好了，那就来看字节码，首先iload_1是将局部变量表中下标为1的k值取出来压入操作数栈中，然后iconst_2是将常量池中的整型值2压入操作数栈，iadd让操作数栈弹出的k值和整型值2执行相加操作，之后将相加的结果值m压入操作数栈中，请注意老师的画法，在执行弹栈和压栈操作之后，老师并没有删除操作数栈中的k值和2，这是因为老师让我们知道具体的操作过程，所以故意为之，不过真正的操作是弹栈之后k值和2就会从操作数栈中弹出，之后操作数栈中就没有k值和2了，只有m值了，然后istore_4是将操作数栈中的m值弹出栈，然后放在局部变量表中下标为4的位置，<code>idc2_w #13&lt;12&gt;</code>代表将long型值12压入操作数栈，istore5是将值12弹栈之后放入局部变量表中下标为5的位置，由于12是long型，所以占据两个位置（槽位），<code>ldc #15&lt;atguigu&gt;</code>代表将字符串atguigu压入操作数栈，astore 7代表将字符串atguigu弹栈之后放入局部变量表中下标为7的位置，<code>idc #16&lt;10.0&gt;</code>代表将float类型数据10.0压入操作数栈，fstore 8代表将10.0弹出栈，然后放入局部变量表中下标为8的位置，<code>idc2_w #17&lt;10.0&gt;</code>代表将10.0压入操作数栈，dstore2代表将10.0弹出栈，之后将10.0放入下标为2和3的操作，毕竟这是double类型数据</p>
<p><strong>槽位复用：</strong></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-8.png" alt="img"></p>
<p>注意：在方法没有运行的时候，根据字节码文件就可以计算出需要几个槽位</p>
</blockquote>
<h1 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h1><p><strong>1. 作用</strong></p>
<p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p>
<p><strong>2. 分类</strong></p>
<p>大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点类型数据进行运算的指令。</p>
<p><strong>3. byte、short、char和boolean类型说明</strong></p>
<p>在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535717-9.png" alt="img"></p>
<p><strong>4. 运算时的溢出</strong></p>
<p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常ArithmeticException。</p>
<p><strong>5. 运算模式</strong></p>
<p>向最接近数舍入模式：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p>
<p>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p>
<p><strong>6. NaN值使用</strong></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-10.png" alt="img"></p>
<h2 id="所有算术指令"><a href="#所有算术指令" class="headerlink" title="所有算术指令"></a>所有算术指令</h2><ul>
<li>加法指令：<code>iadd</code>、<code>ladd</code>、<code>fadd</code>、<code>dadd</code></li>
<li>减法指令：<code>isub</code>、<code>lsub</code>、<code>fsub</code>、<code>dsub</code></li>
<li>乘法指令：<code>imul</code>、<code>lmul</code>、<code>fmul</code>、<code>dmul</code></li>
<li>除法指令：<code>idiv</code>、<code>ldiv</code>、<code>fdiv</code>、<code>ddiv</code></li>
<li>求余指令：<code>irem</code>、<code>lrem</code>、<code>frem</code>、<code>drem</code> <code>//remainder：余数</code></li>
<li>取反指令：<code>ineg</code>、<code>lneg</code>、<code>fneg</code>、<code>dneg</code> <code>//negation：取反</code></li>
<li>自增指令：<code>iinc</code></li>
<li>位运算指令，又可分为：<ul>
<li>位移指令：<code>ishl</code>、<code>ishr</code>、<code>iushr</code>、<code>lshl</code>、<code>lshr</code>、<code>lushr</code></li>
<li>按位或指令：<code>ior</code>、<code>lor</code></li>
<li>按位与指令：<code>iand</code>、<code>land</code></li>
<li>按位异或指令：<code>ixor</code>、<code>lxor</code></li>
</ul>
</li>
<li>比较指令：<code>lcmp</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>dcmpg</code>、<code>dcmpl</code></li>
</ul>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-11.png" alt="img"></p>
<p><strong>一个曾经的案例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>; </span><br><span class="line">		Code:</span><br><span class="line">	<span class="number">0</span>: bipush <span class="number">15</span> </span><br><span class="line">	<span class="number">2</span>: istore_1 </span><br><span class="line">	<span class="number">3</span>: bipush <span class="number">8</span></span><br><span class="line">	<span class="number">5</span>: istore_2</span><br><span class="line">	<span class="number">6</span>: iload_1</span><br><span class="line">	<span class="number">7</span>: iload_2</span><br><span class="line">	<span class="number">8</span>: iadd</span><br><span class="line">	<span class="number">9</span>: istore_3</span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/db0c0a6c23cb4fcbb5241191a1ed4989.png" alt="img"></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/dde6520419cd4723b6bbfd1044705240.png" alt="img"></p>
<p><strong>一个曾经的案例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">	System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-12.png" alt="img"></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-13.png" alt="img"></p>
<p>注意：<code>println()</code>方法的本地变量表中会放55，这样该方法就可以使用了</p>
<h2 id="比较指令的说明"><a href="#比较指令的说明" class="headerlink" title="比较指令的说明"></a>比较指令的说明</h2><p>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。<br>比较指令有: <code>dcmpg</code>, <code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code> lcmp</code>。</p>
<ul>
<li>与前面讲解的指令类似，首字符<code>d</code>表示<code>double</code>类型，<code>f</code>表示<code>float</code>,<code>l</code>表示<code>long</code></li>
</ul>
<p>对于<code>double</code>和<code>float</code>类型的数字，由于<code>NaN</code>的存在，各有两个版本的比较指令。以<code>float</code>为例，有<code>fcmpg</code>和<code>fcmpl</code>两个指令，它们的区别在于在数字比较时，若遇到<code>NaN</code>值，处理结果不同。</p>
<p>指令<code>dcmpl</code>和<code>dcmpg</code>也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
<p>指令<code>lcmp</code>针对<code>long</code>型整数，由于<code>long</code>型整数没有<code>NaN</code>值，故无需准备两套指令。</p>
<p><strong>举例:</strong></p>
<p>指令<code>fcmpg</code>和<code>fcmpl</code>都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为<code>v2</code>,栈顶顺位第2位的元素为<code>v1</code>,若<code>v1=v2</code>,则压入0;若<code>v1&gt;v2</code>则压入1;若<code>v1&lt;v2</code>则压入-1。</p>
<p>两个指令的不同之处在于，如果遇到<code>NaN</code>值，<code>fcmpg</code>会压入1,而<code>fcmpl</code>会压入-1。</p>
<hr>
<ul>
<li>数值类型的数据，才可以谈大小</li>
<li><code>boolean</code>、引用数据类型不能比较大小</li>
</ul>
<blockquote>
<p>[!CAUTION]</p>
<p>NaN(Not a Number)表示不是一个数字，比如0.0&#x2F;0.0得到的可能是1.0（两个数相等），也可能是0.0（0.0是分子），也可能是无穷大（0.0是分母），所以老师给出的解释是NaN代表无法确定是什么数字，只有<code>double</code>和<code>float</code>类型中可能出现<code>NaN</code>的情况，而<code>long</code>类型不会出现<code>NaN</code>，所以只有<code>lcmp</code>，而没有<code>lcml</code></p>
</blockquote>
<h1 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h1><p><strong>类型转换指令说明</strong></p>
<ul>
<li>类型转换指令可以将两种不同的数值类型进行相互转换。</li>
<li>这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</li>
</ul>
<h2 id="宽化类型转换"><a href="#宽化类型转换" class="headerlink" title="宽化类型转换"></a>宽化类型转换</h2><p><strong>1.转换规则:</strong></p>
<p>Java虚拟机直接支持以下数值的宽化类型转换（widening numeric conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括:</p>
<ul>
<li>从<code>int</code>类型到<code>long</code>、<code>float</code>或者<code>double</code>类型。对应的指令为:<code>i21、i2f、i2d</code></li>
<li>从<code>long</code>类型到<code>float</code>、<code>double</code>类型。对应的指令为:<code>12f、12d</code></li>
<li>从<code>float</code>类型到<code>double</code>类型。对应的指令为:<code>f2d</code></li>
</ul>
<p><strong>2.精度损失问题</strong></p>
<ul>
<li>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从<code>int</code>转换到 <code>long</code>，或者从<code>int</code>转换到<code>double</code>，都不会丢失任何信息,转换前后的值是精确相等的。</li>
<li>从<code>int</code>、<code>long</code>类型数值转换到<code>float</code>，或者<code>long</code>类型数值转换到<code>double</code>时，将可能发生精度丢失—一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据<code>IEEE754</code>最接近舍入模式所得到的正确整数值。</li>
</ul>
<p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upCast2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123123123</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> i;</span><br><span class="line">    System.out.println(f);<span class="comment">//123123120</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">123123123123L</span>;</span><br><span class="line">    l = <span class="number">123123123123123123L</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> l;</span><br><span class="line">    System.out.println(d);<span class="comment">//123123123123123120</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.补充说明</strong></p>
<p>从<code>byte</code>、<code>char</code>和<code>short</code>类型到<code>int</code>类型的宽化类型转换实际上是不存在的。对于<code>byte</code>类型转为<code>int</code>,虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将<code>byte</code>转为<code>long</code>时，使用的是<code>i2l</code>,可以看到在内部<code>byte</code>在这里已经等同于<code>int</code>类型处理，类似的还有<code>short</code>类型，这种处理方式有两个特点:</p>
<p>一方面可以减少实际的数据类型，如果为<code>short</code>和<code>byte</code>都准备一套指令，那么指令的数量就会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源、将<code>short</code>和<code>lbyte</code>当做<code>int</code>处理也在情理之中。</p>
<p>另一方面，由于局部变量表中的槽位固定为32位，无论是<code>byte</code>或者<code>short</code>存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p>
<h2 id="窄化类型转换"><a href="#窄化类型转换" class="headerlink" title="窄化类型转换"></a>窄化类型转换</h2><p><strong>窄化类型转换（Narrowing Numeric Conversion）</strong></p>
<p><strong>1.转换规则</strong></p>
<p>Java虚拟机也直接支持以下窄化类型（Narrowing Numeric Conversion)转换:</p>
<ul>
<li>从int类型至byte、short或者char类型。对应的指令有: i2b、i2s、i2c</li>
<li>从long类型到int类型。对应的指令有:12i</li>
<li>从float类型到int或者long类型。对应的指令有:f2i、f21</li>
<li>从double类型到int、long或者float类型。对应的指令有:d2i、d21、d2f</li>
</ul>
<p><strong>2.精度损失问题</strong></p>
<p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p>
<p><strong>3.补充说明</strong></p>
<p>当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一）的时候，将遵循以下转换规则:</p>
<ul>
<li>如果浮点值是NaN，那转换结果就是int或long类型的0。</li>
<li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</li>
</ul>
<p>当将一个double 类型窄化转换为 float类型时，通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。将遵循以下转换规则:</p>
<ul>
<li>如果转换结果的绝对值太小而无法使用 float来表示，将返回 float类型的正负零。</li>
<li>如果转换结果的绝对值太大而无法使用 float来表示，将返回 float类型的正负无穷大。</li>
<li>对于double 类型的 NaN值将按规定转换为float类型的NaN值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试NaN,无穷大的情况</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downCast5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Double.NaN; <span class="comment">//0.0 / 0.0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) d1;</span><br><span class="line">    System.out.println(d1);</span><br><span class="line">    System.out.println(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Double.POSITIVE_INFINITY;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> (<span class="type">long</span>) d2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) d2;</span><br><span class="line">    System.out.println(l);</span><br><span class="line">    System.out.println(Long.MAX_VALUE);</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    System.out.println(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> (<span class="type">float</span>) d2;</span><br><span class="line">    System.out.println(f);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> (<span class="type">float</span>) d1;</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NaN</span><br><span class="line">0</span><br><span class="line">9223372036854775807</span><br><span class="line">9223372036854775807</span><br><span class="line">2147483647</span><br><span class="line">2147483647</span><br><span class="line">Infinity</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>

<h1 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h1><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p>
<h2 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h2><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令:</p>
<p><strong>1.创建类实例的指令:<code>new</code></strong></p>
<ul>
<li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</li>
</ul>
<p><strong>2.创建数组的指令:</strong></p>
<ul>
<li><code>newarray</code>:创建基本类型数组</li>
<li><code>anewarray</code>:创建引用类型数组</li>
<li><code>multianewarray</code>:创建多维数组</li>
</ul>
<p>上述创建指令可以用于创建对象或数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率非常高。</p>
<h2 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h2><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p>
<ul>
<li>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</li>
<li>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield</li>
</ul>
<p>举例：以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hel1o&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">9</span> &lt;hello&gt;</span><br><span class="line"><span class="number">5</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-14.png" alt="img"></p>
<blockquote>
<p>[!NOTE]</p>
<p>注意：<code>get***</code>是入栈，而<code>put***</code>是出栈</p>
</blockquote>
<h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><p>数组操作指令主要有：xastore和xaload指令。具体为：</p>
<ul>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th align="center">加载指令</th>
<th align="center">存储指令</th>
</tr>
</thead>
<tbody><tr>
<td>byte(boolean)</td>
<td align="center">baload</td>
<td align="center">bastore</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>数组指令</th>
<th>byte(boolean)</th>
<th>char</th>
<th>short</th>
<th>long</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xaload</strong></td>
<td>baload</td>
<td>caload</td>
<td>saload</td>
<td>iaload</td>
<td>laload</td>
<td>faload</td>
<td>daload</td>
<td>aaload</td>
</tr>
<tr>
<td><strong>xastore</strong></td>
<td>bastore</td>
<td>castore</td>
<td>sastore</td>
<td>iastore</td>
<td>lastore</td>
<td>fastore</td>
<td>dastore</td>
<td>aastore</td>
</tr>
</tbody></table>
<ul>
<li>取数组长度的指令：arraylength。<ul>
<li>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈。</li>
</ul>
</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i，栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶这两个元素，并将<code>a[i]</code>重新压入栈。</li>
<li>xastore则专门针对数组操作，以iastore为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</li>
</ul>
<h2 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h2><p>检查类实例或数组类型的指令：instanceof、checkcast。</p>
<ul>
<li>指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li>
<li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li>
</ul>
<table>
<thead>
<tr>
<th>类型检查指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>instanceof</td>
<td>判断给定对象是否是某一个类的实例</td>
</tr>
<tr>
<td>checkcast</td>
<td>检查类型强制转换是否可以进行</td>
</tr>
</tbody></table>
<h1 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h1><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>方法调用指令：<code>invokevirtual</code>, <code>invokeinterface</code> , <code>invokespecial</code> , <code>invokestatic</code>, <code>invokedynamic</code></p>
<ul>
<li><code>invokevirtual</code>: 用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是]ava语言中最常见的方法分派方式。</li>
<li><code>invokeinterface</code>: 用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法并找出适合的方法进行调用。</li>
<li><code>invokespecial</code>: 用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</li>
<li><code>invokestatic</code>: 用于调用命名类中的类方法（<code>static</code>方法）。这是静态绑定的。</li>
<li><code>invokedynamic</code>: 调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在java 虚拟机内部，而<code>invokedynamic</code>指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p><strong>注意：</strong></p>
<ol>
<li><code>invokedynamic</code>老师不讲，估计是很少遇到吧</li>
<li><code>invokeinterface</code>是对接口而言的，用属于接口类型的对象调用方法的时候就是这个</li>
<li><code>invokespecial</code>只有构造器、私有方法、super.方法名()调用父类方法这几种情况，其中调用父类方法这种情况可能出现其直接父类没有该方法，那就可以调用其父类继承的父类中的该方法，最终找到一个方法调用就是了</li>
<li><code>invokestatic</code>是调用static静态方法，无论是使用对象.静态方法名()还是类名.静态方法名()都是<code>invokestatic</code>，也不难理解</li>
<li><code>invokevirtual</code>是调用类中的非静态普通方法，而这种实例方法可能调用的是子类重写的非静态普通方法，比如<code>A a = new B();a.hello()</code>，其中B类继承A类，并且B类重写了A类中的<code>hello()</code>方法，这种情况下就是<code>invokevirtual</code>了，但是有可能该类没有子类，调用的就是本类中的非静态普通方法，这种情况也是<code>invokevirtual</code>了</li>
</ol>
</blockquote>
<h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p>
<ul>
<li>包括ineturn(当返回值是boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn和areturn</li>
<li>return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</li>
</ul>
<table>
<thead>
<tr>
<th>返回类型</th>
<th align="center">返回指令</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td align="center">return</td>
</tr>
<tr>
<td>int (boolean, byte, char, short)</td>
<td align="center">ireturn</td>
</tr>
<tr>
<td>long</td>
<td align="center">lreturn</td>
</tr>
<tr>
<td>float</td>
<td align="center">freturn</td>
</tr>
<tr>
<td>double</td>
<td align="center">dreturn</td>
</tr>
<tr>
<td>reference</td>
<td align="center">areturn</td>
</tr>
</tbody></table>
<p><strong>举例:</strong></p>
<p>通过ireturn指令,将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
<p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p>
<p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-15.png" alt="img"></p>
<p>对应的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodReturn</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (i + j) / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h1><p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li>将一个或两个元素从栈顶弹出，并且直接废弃：<code>pop，pop2</code></li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：<code>dup，dup2，dup_x1，dup2_×1，dup_×2，dup2_×2</code></li>
<li>将栈最顶端的两个Slot数值位置交换：<code>swap</code>。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令。</li>
<li>指令<code>nop</code>，是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等。</li>
</ul>
<p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p>
<blockquote>
<p>[!TIP]</p>
<p>说明</p>
<ul>
<li>不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，<code>dup，dup2</code>。dup的系数代表要复制的Slot个数。<ul>
<li>dup开头的指令用于复制1个Slot的数据。例如1个int或1个reference类型数据</li>
<li>dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个float类型数据</li>
</ul>
</li>
<li>带_x的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令，<code>dup_×1，dup2_×1，dup_×2，dup2×2</code>。对于带_x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此<ul>
<li><code>dup_×1</code>插入位置：1+1&#x3D;2，即栈顶2个slot下面</li>
<li><code>dup_×2</code>插入位置：1+2&#x3D;3，即栈顶3个slot下面；</li>
<li><code>dup2_×1</code>插入位置：2+1&#x3D;3，即栈顶3个Slot下面</li>
<li><code>dup2_×2</code>插入位置：2+2&#x3D;4，即栈顶4个Slot下面</li>
</ul>
</li>
<li>pop：将栈顶的1个Slot数值出栈。例如1个short类型数值</li>
<li>pop2：将栈顶的2个slot数值出栈。例如1个double类型数值，或者2个int类型数值</li>
</ul>
</blockquote>
<h1 id="控制转义指令"><a href="#控制转义指令" class="headerlink" title="控制转义指令"></a>控制转义指令</h1><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为</p>
<ul>
<li>1）比较指令、</li>
<li>2）条件跳转指令、</li>
<li>3）比较条件跳转指令、</li>
<li>4）多条件分支跳转指令、</li>
<li>5）无条件跳转指令等。</li>
</ul>
<h2 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h2><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有：<code>ifeq，iflt，ifle，ifne，ifgt，ifge，ifnull，ifnonnull</code>。这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p>
<p>它们的统一含义为：<strong>弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</strong></p>
<p>具体说明：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ifeq</td>
<td>当栈顶int类型数值等于0时跳转</td>
</tr>
<tr>
<td align="center">ifne</td>
<td>当栈顶int类型数值不等于0时跳转</td>
</tr>
<tr>
<td align="center">iflt</td>
<td>当栈顶int类型数值小于0时跳转</td>
</tr>
<tr>
<td align="center">ifle</td>
<td>当栈顶int类型数值小于等于0时跳转</td>
</tr>
<tr>
<td align="center">ifgt</td>
<td>当栈顶int类型数组大于0时跳转</td>
</tr>
<tr>
<td align="center">ifge</td>
<td>当栈顶int类型数值大于等于0时跳转</td>
</tr>
<tr>
<td align="center">ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td align="center">ifnonnull</td>
<td>不为nu时跳转</td>
</tr>
</tbody></table>
<blockquote>
<p>更多指令参考：<a target="_blank" rel="noopener" href="https://jdocs.wiki/docs/jvm/bytecode/jvm_instructions_guide#%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4">条件分支指令</a></p>
</blockquote>
<blockquote>
<p>[!CAUTION]</p>
<ol>
<li>与前面运算规则一致：<ul>
<li>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成</li>
<li>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转</li>
</ul>
</li>
<li>由于各类型的比较最终都会转为int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</li>
</ol>
</blockquote>
<blockquote>
<p>[!NOTE]</p>
<p><strong>注意：</strong></p>
<p>1、对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用比较指令和条件跳转指令来完成，虽然得到的是int类型的值，但是System.out.println(XXX)中的值是布尔类型，你可以在jclasslib中的常量池信息中看到写的是Z，代表布尔值类型<br>2、int类型值（包含byte、char、short）比较 和 对象类型值比较需要使用比较条件跳转指令</p>
</blockquote>
<h2 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h2><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有：<code>if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</code>。其中指令助记符加上“<code>if_</code>”后，以字符“<code>i</code>”开头的指令针对<code>int</code>型整数操作（也包括<code>short</code>和<code>byte</code>类型），以字符“a”开头的指令表示对象引用的比较。</p>
<p><strong>具体说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">if_icmpeq</td>
<td>比较栈顶两int类型数值大小，当前者等于后者时跳转</td>
</tr>
<tr>
<td align="center">if_icmpne</td>
<td>比较栈顶两int类型数值大小，当前者不等于后者时跳转</td>
</tr>
<tr>
<td align="center">if_icmplt</td>
<td>比较栈顶两int类型数值大小，当前者小于后者时跳转</td>
</tr>
<tr>
<td align="center">if icmple</td>
<td>比较栈顶两int类型数值大小，当前者小于等于后者时跳转</td>
</tr>
<tr>
<td align="center">if_icmpgt</td>
<td>比较栈顶两int类型数值大小，当前者大于后者时跳转</td>
</tr>
<tr>
<td align="center">if_icmpge</td>
<td>比较栈顶两int类型数值大小，当前者大于等于后者时跳转</td>
</tr>
<tr>
<td align="center">if_acmpeq</td>
<td>比较栈顶两引用类型数值，当结果相等时跳转</td>
</tr>
<tr>
<td align="center">if acmpne</td>
<td>比较栈顶两引用类型数值，当结果不相等时跳转</td>
</tr>
</tbody></table>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。<strong>如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</strong></p>
<blockquote>
<p>[!NOTE]</p>
<p><strong>注意：</strong></p>
<p>1、上面所说的后者是栈顶元素，而前者是栈顶下面的元素<br>2、对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用比较指令和条件跳转指令来完成<br>而 int类型值（包含byte、char、short）比较 和 对象类型值比较需要使用比较条件跳转指令，其中对象类型值不是比较的地址，就是比较对象中的某些字段值，这又归咎到float、double、long、int类型的比较中了<br>3、无论哪种比较，也不管两个比较值的中间是什么符号（<code>&gt;、&lt;、&gt;=、&lt;=</code>等等），始终都是栈顶下部元素 比较符 栈顶元素，这是不会改变的，然后结合比较符得出结果，如果是true，那就跳转，否则不跳转继续往下执行</p>
</blockquote>
<h2 id="多条件分支跳转"><a href="#多条件分支跳转" class="headerlink" title="多条件分支跳转"></a>多条件分支跳转</h2><p>多条件分支跳转指令是专为<code>switch-case</code>语句设计的，主要有<code>tableswitch</code>和<code>lookupswitch</code>。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tableswitch</td>
<td>用于switch条件跳转，case值连续</td>
</tr>
<tr>
<td>lookupswitch</td>
<td>用于switch条件跳转，case值不连续</td>
</tr>
</tbody></table>
<p>从助记符上看，两者都是switch语句的实现，它们的区别：</p>
<ul>
<li><code>tableswitch</code>要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高。</li>
<li><code>lookupswitch</code>内部存放着各个离散的<code>case-offset</code>对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率较低。</li>
</ul>
<p>指令<code>tableswitch</code>的示意图如下图所示。由于<code>tableswitch</code>的<code>case</code>值是连续的，因此只需要记录最低值和最高值，以及每一项对应的<code>offset</code>偏移量，根据给定的<code>index</code>值通过简单的计算即可直接定位到<code>offset</code>。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-16.png" alt="img"></p>
<p>指令<code>lookupswitch</code>处理的是离散的case值，但是出于效率考虑，<strong>将case-offset对按照case值大小排序</strong>，给定index时，需要查找与index相等的case，获得其offset，如果找不到则跳转到default。指令lookupswitch如下图所示。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-17.png" alt="img"></p>
<h2 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h2><p>目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，<strong>用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</strong></p>
<p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令<code>goto_w</code>，它和<code>goto</code>有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。</p>
<p>指令<code>jsr、jsr_w、ret</code>虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>goto</code></td>
<td>无条件跳转</td>
</tr>
<tr>
<td><code>goto_w</code></td>
<td>无条件跳转（宽索引）</td>
</tr>
<tr>
<td><code>jsr</code></td>
<td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶</td>
</tr>
<tr>
<td><code>jsr_w</code></td>
<td>跳转至指定32位offer位置，并将jsr_w下一条指令地址压入栈顶</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用）</td>
</tr>
</tbody></table>
<h1 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h1><h2 id="抛出异常指令"><a href="#抛出异常指令" class="headerlink" title="抛出异常指令"></a>抛出异常指令</h2><p><strong>(1) <code>athrow</code>指令</strong></p>
<p>在Java程序中显示抛出异常的操作（<code>throw</code>语句）都是由<code>athrow</code>指令来实现。</p>
<p>除了使用<code>throw</code>语句显示抛出异常情况之外，<strong>JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出</strong>。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在<code>idiv</code>或<code>1div</code>指令中抛出<code>ArithmeticException</code>异常。</p>
<p><strong>(2) 注意</strong></p>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p>
<blockquote>
<p>[!NOTE]</p>
<p>如果使用<code>throw new 异常名称()</code>这种形式来抛出异常，那就会在代码中出现<code>athrow</code>指令，而在方法上面添加<code>throw 异常名称</code>这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性<code>Exceptions</code>，如下图所示：</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-18.png" alt="img"></p>
</blockquote>
<h2 id="异常处理与异常表"><a href="#异常处理与异常表" class="headerlink" title="异常处理与异常表"></a>异常处理与异常表</h2><p><strong>处理异常</strong></p>
<p>在Java虚拟机中，<strong>处理异常</strong>（catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是<strong>采用异常表来完成的</strong>。</p>
<p><strong>异常表</strong></p>
<p>如果一个方法定义了一个try-catch 或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：</p>
<ul>
<li>起始位置</li>
<li>结束位置</li>
<li>程序计数器记录的代码处理的偏移地址</li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
<p><strong>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p>
<p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行</strong>。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标</p>
<blockquote>
<p>[!NOTE]</p>
<p><strong>异常表如下所示：</strong></p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-19.png" alt="img"></p>
<p>异常表的含义是如果在Start PC和End PC之间（大于等于Start PC，小于End PC）出现对应的Catch Type异常问题（出现异常就匹配对应的异常），将会在操作数栈中压入相应的异常类对象，之后跳转到Handler PC的位置去执行对应的字节码指令</p>
<p>Warning</p>
<p>当异常出现的时候也会压入操作数栈，之后还会存储局部变量表中</p>
</blockquote>
<h1 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h1><p><strong>组成</strong></p>
<p>Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的</p>
<h2 id="方法级的同步"><a href="#方法级的同步" class="headerlink" title="方法级的同步"></a>方法级的同步</h2><p>方法级的同步：是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的<code>ACC_SYNCHRONIZED</code>访问标志得知一个方法是否声明为同步方法；</p>
<p>当调用方法时，调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否设置。</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</li>
<li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>  aload_0</span><br><span class="line"> <span class="number">1</span>  dup</span><br><span class="line"> <span class="number">2</span>  getfield #<span class="number">2</span> &lt;com/atguigu/java1/SynchronizedTest.i&gt;</span><br><span class="line"> <span class="number">5</span>  iconst_1 </span><br><span class="line"> <span class="number">6</span>  iadd</span><br><span class="line"> <span class="number">7</span>  putfield #<span class="number">2</span> &lt;com/atguigu/java1/SynchronizedTest.i&gt;</span><br><span class="line"><span class="number">10</span>  <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!TIP]</p>
<p>这段代码和普通的无同步操作的代码没有什么不同，没有使用<code>monitorenter</code>和<code>monitorexit</code>进行同步区控制。这是因为，对于同步方法而言，<strong>当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁</strong>，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，<code>monitorenter</code>和<code>monitorexit</code>指令是<strong>隐式存在的，并未直接出现在字节码中</strong>。</p>
</blockquote>
<h2 id="方法内指令指令序列的同步"><a href="#方法内指令指令序列的同步" class="headerlink" title="方法内指令指令序列的同步"></a>方法内指令指令序列的同步</h2><p>同步一段指令集序列：通常是由java中的<code>synchronized</code>语句块来表示的。jvm的指令集有<code>monitorenter</code>和<code>monitorexit</code> 两条指令来支持<code>synchronized</code>关键字的语义。</p>
<p>当一个线程进入同步代码块时，它使用<code>monitorenter</code>指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p>
<p>当线程退出同步块时，需要使用<code>monitorexit</code>声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
<p>指令<code>monitorenter</code>和<code>monitorexit</code>在执行时，都需要在操作数栈顶压入对象，之后<code>monitorenter</code>和<code>monitorexit</code>的锁定和释放都是针对这个对象的监视器进行的。</p>
<p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入。</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-20.png" alt="img"></p>
<p>对应的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: aloade</span><br><span class="line"> <span class="number">1</span>: dup</span><br><span class="line"> <span class="number">2</span>: astore_1</span><br><span class="line"> <span class="number">3</span>: monitorenter</span><br><span class="line"> <span class="number">4</span>: aload_0</span><br><span class="line"> <span class="number">5</span>: dup</span><br><span class="line"> <span class="number">6</span>: getfield          #<span class="number">2</span>                <span class="comment">//Field i:I</span></span><br><span class="line"> <span class="number">9</span>: iconst_1</span><br><span class="line"><span class="number">10</span>: isub</span><br><span class="line"><span class="number">11</span>: putfield          #<span class="number">2</span>                <span class="comment">//Field i:I</span></span><br><span class="line"><span class="number">14</span>: aload_1</span><br><span class="line"><span class="number">15</span>: monitorexit</span><br><span class="line"><span class="number">16</span>: <span class="keyword">goto</span>              <span class="number">24</span></span><br><span class="line"><span class="number">19</span>: astore_2</span><br><span class="line"><span class="number">26</span>: aload_1</span><br><span class="line"><span class="number">21</span>: monitorexit</span><br><span class="line"><span class="number">22</span>: aload_2</span><br><span class="line"><span class="number">23</span>: athrow</span><br><span class="line"><span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">Exception table:</span><br><span class="line">    from    to  target   type</span><br><span class="line">       <span class="number">4</span>    <span class="number">16</span>      <span class="number">19</span>    any</span><br><span class="line">      <span class="number">19</span>    <span class="number">22</span>      <span class="number">19</span>    any</span><br></pre></td></tr></table></figure>

<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条<code>monitorenter</code>指令都必须执行其对应的<code>monitorexit</code>指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时<code>monitorenter</code>和<code>monitorexit</code>指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行<code>monitorexit</code>指令</p>
<blockquote>
<p>[!NOTE]</p>
<p><img src="/article/2020/11/02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/resize,l_1200,m_lfit-1733379535718-21.png" alt="img"></p>
<p>操作数栈中的对象和<code>monitorenter</code>结合起来可以让线程获取锁，做法就是让对象的监视器标记从0变成1，这就代表该线程上锁了，然后在操作数栈的<code>aload_1</code>和<code>monitorexit</code>结合起来就可以让线程解锁，做法就是让对象的监视器标记从1变成0，这个解锁需要在方法退出之前完成，如果方法执行过程中出现了任何异常，将会跳到异常处理的字节码处执行相关代码，如果异常处理的字节码部分出现了问题，那就重新执行异常处理的字节码，这些内容都在异常表中写的很明确，其中异常表也在上面截图中</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/" rel="tag"># JVM中篇：字节码与类的加载篇</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2020/11/01-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" rel="prev" title="01-Class文件结构">
                  <i class="fa fa-angle-left"></i> 01-Class文件结构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2020/11/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" rel="next" title="03-类的加载过程详解">
                  03-类的加载过程详解 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
