<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.zhaolq.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"androidstudio","dark":"androidstudio"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="推荐：   操作系统层虚拟化 - 维基百科   Docker - 维基百科">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker教程">
<meta property="og:url" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="洋蔥">
<meta property="og:description" content="推荐：   操作系统层虚拟化 - 维基百科   Docker - 维基百科">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210329113910157.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210402145935031.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210402153201618.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210402154047211.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210406135103964.png">
<meta property="og:image" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/network.png">
<meta property="article:published_time" content="2020-01-15T06:30:51.000Z">
<meta property="article:modified_time" content="2020-01-15T06:30:51.000Z">
<meta property="article:author" content="zhaolq">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210329113910157.png">


<link rel="canonical" href="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/","path":"article/2020/01/Docker教程/","title":"Docker教程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Docker教程 | 洋蔥</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">洋蔥</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">耳不闻人是非，目不视人之短，口不言人之过。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker"><span class="nav-number">1.</span> <span class="nav-text">Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Docker%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Docker？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">Docker概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Engine"><span class="nav-number">2.</span> <span class="nav-text">Docker Engine</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ubuntu%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.</span> <span class="nav-text">Ubuntu安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC"><span class="nav-number">2.2.1.</span> <span class="nav-text">卸载旧版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8apt%E5%AD%98%E5%82%A8%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用apt存储库进行安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.3.</span> <span class="nav-text">从软件包安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD-Docker-Engine"><span class="nav-number">2.2.4.</span> <span class="nav-text">卸载 Docker Engine</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Hub"><span class="nav-number">3.</span> <span class="nav-text">Docker Hub</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">3.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="nav-number">3.2.</span> <span class="nav-text">镜像加速</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E5%90%91-Registry-Mirrors"><span class="nav-number">3.2.1.</span> <span class="nav-text">镜像仓库地址重定向 (Registry Mirrors)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="nav-number">3.2.2.</span> <span class="nav-text">Docker 外部网络代理配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-systemd-%E6%B3%A8%E5%85%A5%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">通过 systemd 注入变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-daemon-json-%E9%85%8D%E7%BD%AE"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">通过 daemon.json 配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F"><span class="nav-number">5.</span> <span class="nav-text">使用镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F"><span class="nav-number">5.1.</span> <span class="nav-text">查找镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="nav-number">5.2.</span> <span class="nav-text">拉取镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="nav-number">5.3.</span> <span class="nav-text">列出镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF"><span class="nav-number">5.3.1.</span> <span class="nav-text">镜像体积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F"><span class="nav-number">5.3.2.</span> <span class="nav-text">虚悬镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E5%B1%82%E9%95%9C%E5%83%8F"><span class="nav-number">5.3.3.</span> <span class="nav-text">中间层镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="nav-number">5.4.</span> <span class="nav-text">运行容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="nav-number">5.5.</span> <span class="nav-text">删除镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Untagged-%E5%92%8C-Deleted"><span class="nav-number">5.5.1.</span> <span class="nav-text">Untagged 和 Deleted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4"><span class="nav-number">5.5.2.</span> <span class="nav-text">批量删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">5.6.</span> <span class="nav-text">构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-commit-%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E6%9E%84%E6%88%90"><span class="nav-number">5.6.1.</span> <span class="nav-text">利用 commit 理解镜像构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Dockerfile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">5.6.2.</span> <span class="nav-text">使用 Dockerfile 构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99Dockerfile"><span class="nav-number">5.6.2.1.</span> <span class="nav-text">编写Dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ubuntu%E7%9A%84Dockerfile"><span class="nav-number">5.6.2.1.1.</span> <span class="nav-text">Ubuntu的Dockerfile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FROM-%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="nav-number">5.6.2.1.2.</span> <span class="nav-text">FROM 指定基础镜像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RUN-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.2.1.3.</span> <span class="nav-text">RUN 执行命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F-1"><span class="nav-number">5.6.2.2.</span> <span class="nav-text">构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#docker-build-%E6%9E%84%E5%BB%BA"><span class="nav-number">5.6.2.2.1.</span> <span class="nav-text">docker build 构建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89"><span class="nav-number">5.6.2.2.2.</span> <span class="nav-text">镜像构建上下文（Context）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%B1%82%E6%95%B0"><span class="nav-number">5.6.2.2.3.</span> <span class="nav-text">镜像层数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8EURL%E6%9E%84%E5%BB%BA"><span class="nav-number">5.6.2.2.4.</span> <span class="nav-text">从URL构建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%9E%84%E5%BB%BA"><span class="nav-number">5.6.2.2.5.</span> <span class="nav-text">从标准输入构建</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.6.3.</span> <span class="nav-text">Dockerfile 指令详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#COPY-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">5.6.3.1.</span> <span class="nav-text">COPY 复制文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ADD-%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">5.6.3.2.</span> <span class="nav-text">ADD 更高级的复制文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.3.3.</span> <span class="nav-text">CMD 容器启动命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENTRYPOINT-%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="nav-number">5.6.3.4.</span> <span class="nav-text">ENTRYPOINT 入口点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENV-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">5.6.3.5.</span> <span class="nav-text">ENV 设置环境变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARG-%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><span class="nav-number">5.6.3.6.</span> <span class="nav-text">ARG 构建参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VOLUME-%E6%8C%82%E8%BD%BD%E4%B8%BA%E5%8C%BF%E5%90%8D%E5%8D%B7"><span class="nav-number">5.6.3.7.</span> <span class="nav-text">VOLUME 挂载为匿名卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%93%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E6%97%B6%E6%8C%82%E8%BD%BD%E2%80%93"><span class="nav-number">5.6.3.8.</span> <span class="nav-text">–运行容器时挂载–</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPOSE-%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3"><span class="nav-number">5.6.3.9.</span> <span class="nav-text">EXPOSE 暴露端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WORKDIR-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">5.6.3.10.</span> <span class="nav-text">WORKDIR 指定工作目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USER-%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7"><span class="nav-number">5.6.3.11.</span> <span class="nav-text">USER 指定当前用户</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HEALTHCHECK-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="nav-number">5.6.3.12.</span> <span class="nav-text">HEALTHCHECK 健康检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ONBUILD-%E4%B8%BA%E4%BB%96%E4%BA%BA%E4%BD%9C%E5%AB%81%E8%A1%A3%E8%A3%B3"><span class="nav-number">5.6.3.13.</span> <span class="nav-text">ONBUILD 为他人作嫁衣裳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LABEL-%E4%B8%BA%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">5.6.3.14.</span> <span class="nav-text">LABEL 为镜像添加元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHELL-%E6%8C%87%E4%BB%A4"><span class="nav-number">5.6.3.15.</span> <span class="nav-text">SHELL 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">5.6.3.16.</span> <span class="nav-text">参考文档</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="nav-number">5.7.</span> <span class="nav-text">多阶段构建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">5.8.</span> <span class="nav-text">构建多种系统架构支持的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">5.9.</span> <span class="nav-text">其它制作镜像的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E-rootfs-%E8%B7%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%BC%E5%85%A5"><span class="nav-number">5.9.1.</span> <span class="nav-text">从 rootfs(跟文件系统) 压缩包导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E9%95%9C%E5%83%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA"><span class="nav-number">5.9.2.</span> <span class="nav-text">Docker 镜像的导入和导出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">操作容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">6.1.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="nav-number">6.2.</span> <span class="nav-text">终止容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="nav-number">6.3.</span> <span class="nav-text">后台运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">6.4.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">6.5.</span> <span class="nav-text">导出和导入容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="nav-number">6.6.</span> <span class="nav-text">删除容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93"><span class="nav-number">7.</span> <span class="nav-text">访问仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Hub-1"><span class="nav-number">7.1.</span> <span class="nav-text">Docker Hub</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E7%99%BB%E5%87%BA"><span class="nav-number">7.1.1.</span> <span class="nav-text">登录登出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F"><span class="nav-number">7.1.2.</span> <span class="nav-text">推送镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA"><span class="nav-number">7.1.3.</span> <span class="nav-text">自动构建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93-docker-registry"><span class="nav-number">7.2.</span> <span class="nav-text">私有仓库 docker-registry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C"><span class="nav-number">7.2.1.</span> <span class="nav-text">安装运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><span class="nav-number">7.2.2.</span> <span class="nav-text">推送镜像到本地仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F"><span class="nav-number">7.2.3.</span> <span class="nav-text">搜索本地仓库镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%89%E5%8F%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F"><span class="nav-number">7.2.4.</span> <span class="nav-text">拉取本地仓库镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%9D%9E-https-%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="nav-number">7.2.5.</span> <span class="nav-text">配置非 https 仓库地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">7.3.</span> <span class="nav-text">私有仓库高级配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nexus3-x-%E7%9A%84%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="nav-number">7.4.</span> <span class="nav-text">Nexus3.x 的私有仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-Nexus-%E5%AE%B9%E5%99%A8"><span class="nav-number">7.4.1.</span> <span class="nav-text">启动 Nexus 容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93"><span class="nav-number">7.4.2.</span> <span class="nav-text">创建仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">7.4.3.</span> <span class="nav-text">添加访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%A7%92%E8%89%B2"><span class="nav-number">7.4.4.</span> <span class="nav-text">添加角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7"><span class="nav-number">7.4.5.</span> <span class="nav-text">添加用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NGINX-%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%90%86"><span class="nav-number">7.4.6.</span> <span class="nav-text">NGINX 加密代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="nav-number">7.4.7.</span> <span class="nav-text">访问镜像仓库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">8.1.</span> <span class="nav-text">数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">8.1.1.</span> <span class="nav-text">创建一个数据卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">8.1.2.</span> <span class="nav-text">启动一个挂载数据卷的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF"><span class="nav-number">8.1.3.</span> <span class="nav-text">查看数据卷的具体信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">8.1.4.</span> <span class="nav-text">删除数据卷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95"><span class="nav-number">8.2.</span> <span class="nav-text">挂载主机目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">8.2.1.</span> <span class="nav-text">挂载一个主机目录作为数据卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF-1"><span class="nav-number">8.2.2.</span> <span class="nav-text">查看数据卷的具体信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">8.2.3.</span> <span class="nav-text">挂载一个本地主机文件作为数据卷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C"><span class="nav-number">9.</span> <span class="nav-text">使用网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8"><span class="nav-number">9.1.</span> <span class="nav-text">外部访问容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="nav-number">9.1.1.</span> <span class="nav-text">映射所有接口地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="nav-number">9.1.2.</span> <span class="nav-text">映射到指定地址的指定端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="nav-number">9.1.3.</span> <span class="nav-text">查看映射端口配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="nav-number">9.2.</span> <span class="nav-text">容器互联</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">9.2.1.</span> <span class="nav-text">新建网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">9.2.2.</span> <span class="nav-text">连接容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-Compose"><span class="nav-number">9.2.3.</span> <span class="nav-text">Docker Compose</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-DNS"><span class="nav-number">9.3.</span> <span class="nav-text">配置 DNS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="nav-number">10.</span> <span class="nav-text">高级网络配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97"><span class="nav-number">10.1.</span> <span class="nav-text">快速配置指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">10.2.</span> <span class="nav-text">容器访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C"><span class="nav-number">10.2.1.</span> <span class="nav-text">容器访问外部网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BF%E9%97%AE"><span class="nav-number">10.2.2.</span> <span class="nav-text">容器之间访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%AB%AF%E5%8F%A3"><span class="nav-number">10.2.2.1.</span> <span class="nav-text">访问所有端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="nav-number">10.2.2.2.</span> <span class="nav-text">访问指定端口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.3.</span> <span class="nav-text">映射容器端口到宿主主机的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.3.1.</span> <span class="nav-text">容器访问外部实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.3.2.</span> <span class="nav-text">外部访问容器实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-docker0-%E7%BD%91%E6%A1%A5"><span class="nav-number">10.4.</span> <span class="nav-text">配置 docker0 网桥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A1%A5"><span class="nav-number">10.5.</span> <span class="nav-text">自定义网桥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">10.5.1.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">10.6.</span> <span class="nav-text">编辑网络配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%82%B9%E5%88%B0%E7%82%B9%E8%BF%9E%E6%8E%A5"><span class="nav-number">10.7.</span> <span class="nav-text">创建一个点到点连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Buildx"><span class="nav-number">11.</span> <span class="nav-text">Docker Buildx</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Compose-1"><span class="nav-number">12.</span> <span class="nav-text">Docker Compose</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Compose-%E7%AE%80%E4%BB%8B"><span class="nav-number">12.1.</span> <span class="nav-text">Compose 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC"><span class="nav-number">12.2.</span> <span class="nav-text">版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="nav-number">12.3.</span> <span class="nav-text">安装与卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85"><span class="nav-number">12.3.1.</span> <span class="nav-text">二进制包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PIP-%E5%AE%89%E8%A3%85"><span class="nav-number">12.3.2.</span> <span class="nav-text">PIP 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bash-%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">12.3.3.</span> <span class="nav-text">bash 补全命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD"><span class="nav-number">12.3.4.</span> <span class="nav-text">卸载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">12.4.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">12.4.1.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF"><span class="nav-number">12.4.2.</span> <span class="nav-text">场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#web-%E5%BA%94%E7%94%A8"><span class="nav-number">12.4.2.1.</span> <span class="nav-text">web 应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dockerfile"><span class="nav-number">12.4.2.2.</span> <span class="nav-text">Dockerfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-compose-yml"><span class="nav-number">12.4.2.3.</span> <span class="nav-text">docker-compose.yml</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-compose-%E9%A1%B9%E7%9B%AE"><span class="nav-number">12.4.2.4.</span> <span class="nav-text">运行 compose 项目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compose-%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="nav-number">12.5.</span> <span class="nav-text">Compose 命令说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A0%BC%E5%BC%8F"><span class="nav-number">12.5.1.</span> <span class="nav-text">命令对象与格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="nav-number">12.5.2.</span> <span class="nav-text">命令选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">12.5.3.</span> <span class="nav-text">命令使用说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#help"><span class="nav-number">12.5.3.1.</span> <span class="nav-text">help</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#version"><span class="nav-number">12.5.3.2.</span> <span class="nav-text">version</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#config"><span class="nav-number">12.5.3.3.</span> <span class="nav-text">config</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#build"><span class="nav-number">12.5.3.4.</span> <span class="nav-text">build</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#up"><span class="nav-number">12.5.3.5.</span> <span class="nav-text">up</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#down"><span class="nav-number">12.5.3.6.</span> <span class="nav-text">down</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#run"><span class="nav-number">12.5.3.7.</span> <span class="nav-text">run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rm"><span class="nav-number">12.5.3.8.</span> <span class="nav-text">rm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#start"><span class="nav-number">12.5.3.9.</span> <span class="nav-text">start</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop"><span class="nav-number">12.5.3.10.</span> <span class="nav-text">stop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#restart"><span class="nav-number">12.5.3.11.</span> <span class="nav-text">restart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kill"><span class="nav-number">12.5.3.12.</span> <span class="nav-text">kill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pause"><span class="nav-number">12.5.3.13.</span> <span class="nav-text">pause</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unpause"><span class="nav-number">12.5.3.14.</span> <span class="nav-text">unpause</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pull"><span class="nav-number">12.5.3.15.</span> <span class="nav-text">pull</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#push"><span class="nav-number">12.5.3.16.</span> <span class="nav-text">push</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ps"><span class="nav-number">12.5.3.17.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#images"><span class="nav-number">12.5.3.18.</span> <span class="nav-text">images</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logs"><span class="nav-number">12.5.3.19.</span> <span class="nav-text">logs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#port"><span class="nav-number">12.5.3.20.</span> <span class="nav-text">port</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scale"><span class="nav-number">12.5.3.21.</span> <span class="nav-text">scale</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#top"><span class="nav-number">12.5.3.22.</span> <span class="nav-text">top</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec"><span class="nav-number">12.5.3.23.</span> <span class="nav-text">exec</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">12.5.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compose-%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6"><span class="nav-number">12.6.</span> <span class="nav-text">Compose 模板文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#build-1"><span class="nav-number">12.6.1.</span> <span class="nav-text">build</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cap-add-cap-drop"><span class="nav-number">12.6.2.</span> <span class="nav-text">cap_add, cap_drop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#command"><span class="nav-number">12.6.3.</span> <span class="nav-text">command</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#configs"><span class="nav-number">12.6.4.</span> <span class="nav-text">configs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cgroup-parent"><span class="nav-number">12.6.5.</span> <span class="nav-text">cgroup_parent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#container-name"><span class="nav-number">12.6.6.</span> <span class="nav-text">container_name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deploy"><span class="nav-number">12.6.7.</span> <span class="nav-text">deploy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#devices"><span class="nav-number">12.6.8.</span> <span class="nav-text">devices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#depends-on"><span class="nav-number">12.6.9.</span> <span class="nav-text">depends_on</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns"><span class="nav-number">12.6.10.</span> <span class="nav-text">dns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns-search"><span class="nav-number">12.6.11.</span> <span class="nav-text">dns_search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tmpfs"><span class="nav-number">12.6.12.</span> <span class="nav-text">tmpfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-file"><span class="nav-number">12.6.13.</span> <span class="nav-text">env_file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#environment"><span class="nav-number">12.6.14.</span> <span class="nav-text">environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expose"><span class="nav-number">12.6.15.</span> <span class="nav-text">expose</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#external-links"><span class="nav-number">12.6.16.</span> <span class="nav-text">external_links</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extra-hosts"><span class="nav-number">12.6.17.</span> <span class="nav-text">extra_hosts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#healthcheck"><span class="nav-number">12.6.18.</span> <span class="nav-text">healthcheck</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#image"><span class="nav-number">12.6.19.</span> <span class="nav-text">image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#labels"><span class="nav-number">12.6.20.</span> <span class="nav-text">labels</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#links"><span class="nav-number">12.6.21.</span> <span class="nav-text">links</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logging"><span class="nav-number">12.6.22.</span> <span class="nav-text">logging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#network-mode"><span class="nav-number">12.6.23.</span> <span class="nav-text">network_mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#networks"><span class="nav-number">12.6.24.</span> <span class="nav-text">networks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pid"><span class="nav-number">12.6.25.</span> <span class="nav-text">pid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ports"><span class="nav-number">12.6.26.</span> <span class="nav-text">ports</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#secrets"><span class="nav-number">12.6.27.</span> <span class="nav-text">secrets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#security-opt"><span class="nav-number">12.6.28.</span> <span class="nav-text">security_opt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stop-signal"><span class="nav-number">12.6.29.</span> <span class="nav-text">stop_signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysctls"><span class="nav-number">12.6.30.</span> <span class="nav-text">sysctls</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ulimits"><span class="nav-number">12.6.31.</span> <span class="nav-text">ulimits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volumes"><span class="nav-number">12.6.32.</span> <span class="nav-text">volumes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%8C%87%E4%BB%A4"><span class="nav-number">12.6.33.</span> <span class="nav-text">其它指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%8F%98%E9%87%8F"><span class="nav-number">12.6.34.</span> <span class="nav-text">读取变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-1"><span class="nav-number">12.6.35.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Compose%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">13.</span> <span class="nav-text">Docker Compose环境变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Compose%E5%AE%9E%E6%88%98"><span class="nav-number">14.</span> <span class="nav-text">Docker Compose实战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Machine"><span class="nav-number">15.</span> <span class="nav-text">Docker Machine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Swarm-mode"><span class="nav-number">16.</span> <span class="nav-text">Swarm mode</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaolq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">zhaolq</p>
  <div class="site-description" itemprop="description">有用、有趣、有情义！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">555</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hellozhaolq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hellozhaolq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hello.zhaolq@qq.com" title="E-Mail → mailto:hello.zhaolq@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhaolq.com/article/2020/01/Docker%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaolq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋蔥">
      <meta itemprop="description" content="有用、有趣、有情义！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Docker教程 | 洋蔥">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker教程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-15 14:30:51" itemprop="dateCreated datePublished" datetime="2020-01-15T14:30:51+08:00">2020-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">操作系统层虚拟化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><font color="blue"><strong>推荐：</strong></font> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96">操作系统层虚拟化 - 维基百科</a> </p>
<p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Docker">Docker - 维基百科</a> </p>
<span id="more"></span>

<p><strong>教程：</strong> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice">Docker — 从入门到实践</a> </p>
<p><a target="_blank" rel="noopener" href="https://doc.yonyoucloud.com/doc/chinese_docker/index.html">Docker中文指南</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程 | 菜鸟教程</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 - 菜鸟教程</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">阮一峰 Docker 入门教程</a> </p>
<p>“纯洁的微笑” Docker 入门教程： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/8520296.html">Docker 一</a> 、 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/8588725.html">Docker 二</a> 、 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/8595384.html">Docker 三</a> </p>
<p><strong>博文：</strong> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dongdong9223/article/details/71425077">docker中宿主机与容器（container）互相拷贝传递文件的方法</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yjk13703623757/article/details/80283729">Docker容器日志查看与清理</a> </p>
<p><font size="4"><strong>习惯使用 <font color="red">–help</font> 及 <font color="red">tab 补全命令</font></strong></font> </p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>        如果您是 Docker 新手，本节将指导您了解入门所需的基本资源。</p>
<h2 id="什么是-Docker？"><a href="#什么是-Docker？" class="headerlink" title="什么是 Docker？"></a>什么是 Docker？</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/docker-overview/">https://docs.docker.com/get-started/docker-overview/</a>        <strong>右侧目录包括：Docker 架构、底层技术</strong></p>
<h2 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-a-container/">https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-a-container/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-an-image/">https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-an-image/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-a-registry/">https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-a-registry/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-docker-compose/">https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-docker-compose/</a></p>
<h1 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h1><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/">https://docs.docker.com/engine/</a>        </p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a>        包含Docker平台各类API、命令行界面、驱动程序、规范及文件格式的参考文档。	</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/">https://docs.docker.com/engine/</a></p>
<p><strong>Docker Engine</strong>（Docker 引擎）是整个 Docker 平台的核心软件，它是用来<strong>构建和运行容器</strong>的底层技术。</p>
<p>主要由以下三个部分组成：</p>
<ul>
<li><strong>服务器（Daemon &#x2F; <code>dockerd</code>）：</strong><ul>
<li>这是一个长期运行的后台程序（守护进程）。</li>
<li>它负责创建、管理、监控所有的 Docker 对象，包括<strong>镜像（Images）</strong>、<strong>容器（Containers）</strong>、网络和数据卷（Volumes）。</li>
<li>它会监听来自客户端的请求。</li>
</ul>
</li>
<li><strong>REST API：</strong><ul>
<li>这是一个应用程序接口，用于定义客户端如何与服务器进行通信和交互。</li>
</ul>
</li>
<li><strong>客户端（CLI &#x2F; <code>docker</code>）：</strong><ul>
<li>这是您在终端使用的<strong>命令行工具</strong>。</li>
<li>您输入的 <code>docker run</code>、<code>docker pull</code>、<code>docker ps</code> 等命令，都是通过客户端发送给守护进程，然后由守护进程执行具体操作。</li>
</ul>
</li>
</ul>
<h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/#uninstall-old-versions">https://docs.docker.com/engine/install/ubuntu/#uninstall-old-versions</a></p>
<h3 id="使用apt存储库进行安装"><a href="#使用apt存储库进行安装" class="headerlink" title="使用apt存储库进行安装"></a>使用apt存储库进行安装</h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</a></p>
<p><strong>官  网  Docker Engine软件仓库：</strong> <a target="_blank" rel="noopener" href="https://download.docker.com/linux/ubuntu/dists/noble/pool/stable/amd64/">https://download.docker.com/linux/ubuntu/dists/noble/pool/stable/amd64/</a></p>
<p><strong>阿里云Docker Engine软件仓库：</strong> <a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/docker-ce/linux/ubuntu/dists/noble/pool/stable/amd64/">https://mirrors.aliyun.com/docker-ce/linux/ubuntu/dists/noble/pool/stable/amd64/</a></p>
<h3 id="从软件包安装"><a href="#从软件包安装" class="headerlink" title="从软件包安装"></a>从软件包安装</h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/#install-from-a-package">https://docs.docker.com/engine/install/ubuntu/#install-from-a-package</a></p>
<h3 id="卸载-Docker-Engine"><a href="#卸载-Docker-Engine" class="headerlink" title="卸载 Docker Engine"></a>卸载 Docker Engine</h3><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/#uninstall-docker-engine">https://docs.docker.com/engine/install/ubuntu/#uninstall-docker-engine</a></p>
<h1 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h1><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-hub">https://docs.docker.com/docker-hub</a></p>
<p><strong>Docker Hub</strong> 是 Docker 生态系统的<strong>核心组件</strong>之一，它是一个基于云计算的 <strong>公共容器镜像注册中心（Container Image Registry）</strong>。</p>
<p>Docker Hub 拥有全球最大的容器镜像仓库，用于存储、管理和共享 Docker 镜像，从而简化了开发流程。它与您的工具无缝集成，提高了开发效率，并确保容器化应用程序的可靠部署、分发和访问。此外，它还为开发人员提供预构建的镜像和资源，以加快开发工作流程。</p>
<p>Docker Hub 的主要特性：</p>
<ul>
<li>无限公共存储库</li>
<li>私有仓库</li>
<li>利用 Webhooks 实现工作流程自动化</li>
<li>GitHub 和 Bitbucket 集成</li>
<li>并行和自动化构建</li>
</ul>
<p>除了图形界面外，您还可以使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/reference/api/hub/latest/">Docker Hub API</a> 或实验性的 <a target="_blank" rel="noopener" href="https://github.com/docker/hub-tool#readme">Docker Hub CLI tool</a> 与 Docker Hub 进行交互。</p>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>介绍两种解决 Docker 镜像拉取速度慢或网络受限问题的方案：<strong>修改镜像源</strong> 和 <strong>代理配置</strong>。</p>
<h3 id="镜像仓库地址重定向-Registry-Mirrors"><a href="#镜像仓库地址重定向-Registry-Mirrors" class="headerlink" title="镜像仓库地址重定向 (Registry Mirrors)"></a>镜像仓库地址重定向 (Registry Mirrors)</h3><p>这是解决 Docker Hub（<code>docker.io</code>）在中国大陆访问慢或超时问题的<strong>首选方案</strong>。它通过将请求地址重定向到国内高速镜像站点来实现加速。（拉取镜像时，无需指定完整的 Docker 镜像仓库地址。）</p>
<p>1、**编辑 Docker 主配置文件：**启动 Docker 服务后，编辑 <code>vim /etc/docker/daemon.json</code></p>
<p>2、<strong>添加镜像加速地址：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://registry-1.docker.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockerproxy.net&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>💡 提示：</strong> <code>daemon.json</code> 文件内容不能为空白，最少应包含一对大括号 <code>{}</code>，否则 Docker Daemon 启动会失败。</p>
<p>3、<strong>重新加载并重启服务：</strong> 使配置生效。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>4、<strong>检查加速器是否生效：</strong></p>
<p>运行 <code>docker info</code> 命令，如果看到如下内容（列出您配置的加速地址），则说明配置成功：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors<span class="punctuation">:</span></span><br><span class="line"> https<span class="punctuation">:</span><span class="comment">//dockerproxy.net/</span></span><br><span class="line"> https<span class="punctuation">:</span><span class="comment">//mirror.ccs.tencentyun.com</span></span><br></pre></td></tr></table></figure>

<h3 id="Docker-外部网络代理配置"><a href="#Docker-外部网络代理配置" class="headerlink" title="Docker 外部网络代理配置"></a>Docker 外部网络代理配置</h3><p>当您需要通过 SOCKS 或 HTTP 代理服务器才能访问所有外部网络时，需要使用本方案。</p>
<h4 id="通过-systemd-注入变量"><a href="#通过-systemd-注入变量" class="headerlink" title="通过 systemd 注入变量"></a>通过 <code>systemd</code> 注入变量</h4><p><strong>机制：<strong>通过 <code>systemd</code> 将 <code>HTTP_PROXY</code> 等</strong>环境变量</strong>注入 Docker Daemon 进程。</p>
<p><strong>作用：控制 Docker 进程的所有外部网络流量走向。</strong> 影响 <code>docker pull</code> 和 <code>docker build</code> 中所有连接外网的命令。</p>
<p>**适用场景：**主机环境严格要求所有流量必须通过代理服务器访问外网。</p>
<p>1、<strong>编辑代理配置文件：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">vim /etc/systemd/system/docker.service.d/proxy.conf</span><br></pre></td></tr></table></figure>

<p>2、<strong>配置内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=socks5://192.168.0.3:1080&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=socks5://192.168.0.3:1080&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.0.0.0/8        10.0.0.0 到 10.255.255.255        完整的 A 类私有地址，用于大型内网。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">172.16.0.0/12     172.16.0.0 到 172.31.255.255      完整的 B 类私有地址范围。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.0.0/16    192.168.0.0 到 192.168.255.255    完整的 C 类私有地址范围。</span></span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16&quot;</span><br></pre></td></tr></table></figure>

<p>3、<strong>重启并查看环境变量：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show docker --property Environment</span><br></pre></td></tr></table></figure>

<h4 id="通过-daemon-json-配置"><a href="#通过-daemon-json-配置" class="headerlink" title="通过 daemon.json 配置"></a>通过 <code>daemon.json</code> 配置</h4><p>此方法适用于 <strong>Docker Engine 23.0 及更高版本</strong>，允许在主配置文件中直接设置代理，优先级较高。</p>
<p>1、**编辑 Docker 主配置文件：**启动 Docker 服务后，编辑 <code>vim /etc/docker/daemon.json</code></p>
<p>2、<strong>添加 <code>proxies</code> 字段：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://registry-1.docker.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockerproxy.net&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;proxies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;http-proxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;socks5://192.168.0.3:1080&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;https-proxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;socks5://192.168.0.3:1080&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;no-proxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost,127.0.0.1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>3、<strong>重启服务</strong>使其生效。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>Docker</strong> 包括三个基本概念</p>
<ul>
<li><strong>镜像</strong>（<code>Image</code>）<a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/basic_concept/image.md">https://github.com/yeasy/docker_practice/blob/master/basic_concept/image.md</a> </li>
<li><strong>容器</strong>（<code>Container</code>）<a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/basic_concept/container.md">https://github.com/yeasy/docker_practice/blob/master/basic_concept/container.md</a> </li>
<li><strong>仓库</strong>（<code>Repository</code>）<a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/basic_concept/repository.md">https://github.com/yeasy/docker_practice/blob/master/basic_concept/repository.md</a></li>
</ul>
<p>理解了这三个概念，就理解了 <strong>Docker</strong> 的整个生命周期。</p>
<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <strong><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></strong> </p>
<p>也可以使用 docker search 命令来搜索镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker search ubuntu</span></span><br></pre></td></tr></table></figure>

<p><img src="/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210329113910157.png" alt="image-20210329113910157"></p>
<p><strong>NAME:</strong> 镜像仓库源的名称。</p>
<p>​    名为 <code>ubuntu</code> 的镜像，是由 Docker 公司创建、验证、支持、提供的基础镜像 (又叫根镜像)。往往使用单个单词作为名字。</p>
<p>​    名为 <code>dorowu/ubuntu-desktop-lxde-vnc</code> 的镜像，是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。比如 ansible 用户。</p>
<p><strong>DESCRIPTION:</strong> 镜像的描述</p>
<p><strong>STARS:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思</p>
<p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p>
<p><strong>AUTOMATED:</strong> 自动构建</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull --<span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull ubuntu <span class="comment"># 未指定版本，默认使用ubuntu:latest镜像</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull docker.io/library/ubuntu</span></span><br></pre></td></tr></table></figure>

<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04 <span class="comment"># 没有给出Docker镜像仓库地址和仓库名，默认docker.io/library/</span></span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">f22ccc0b8772: Pull complete <span class="comment"># 镜像是由多层存储所构成，会一层层下载，并给出每一层ID的前12位</span></span><br><span class="line">3cf8fb62ba5f: Pull complete</span><br><span class="line">e80c964ece6a: Pull complete</span><br><span class="line">Digest: sha256:fd25e706f3dea2a5ff705dbc3353cf37f08307798f3e360a13e9385840f73fb3 <span class="comment"># 镜像完整的sha256摘要</span></span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">docker.io/library/ubuntu:18.04 <span class="comment"># 最后一行输出镜像的完整名称</span></span><br><span class="line"></span><br><span class="line">$ docker pull ubuntu:bionic</span><br><span class="line">$ docker pull ubuntu:21.04</span><br></pre></td></tr></table></figure>

<p><font color="red">按照上述命令操作时，你看到的层 ID 以及 <code>sha256</code> 摘要和这里的不一样。</font>因为官方镜像一直在维护更新，修复后再以原来的标签发布，确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:  docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  ls, list</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">  -q, --quiet           Only show image IDs</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker images <span class="comment"># 列出所有顶层镜像</span></span><br><span class="line">$ docker images -a <span class="comment"># 列出所有镜像。包括其它镜像所依赖的无标签的&quot;中间层镜像&quot;和&quot;虚悬镜像&quot;</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> <span class="comment"># 等于 docker images</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> -a <span class="comment"># 等于 docker images -a</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> ubuntu <span class="comment"># 根据仓库名列出镜像</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> ubuntu:18.04 <span class="comment"># 列出特定仓库名和标签的镜像</span></span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">ls</span> -f since=ubuntu:18.04 <span class="comment"># 使用过滤器，显示ubuntu:18.04之后建立的镜像。since可换成before</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> -q <span class="comment"># 只列出镜像ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Go的模板语法：自己组织列和标题</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span> <span class="comment"># 直接列出镜像结果，并且只包含镜像ID和仓库名</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span> <span class="comment"># 以表格等距显示，并且有标题行</span></span><br></pre></td></tr></table></figure>

<p><code>--filter</code> 配合 <code>-q</code> 将产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而对这组实体批量进行某种操作。<font color="red">这种做法非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> -a --digests <span class="comment"># 显示摘要</span></span></span><br><span class="line">REPOSITORY  TAG     DIGEST                                                                   IMAGE ID      CREATED       SIZE</span><br><span class="line">ubuntu      21.04   sha256:b6dc45a852dc83fa0e7504e9d68b9b0084eefb8aeb5f295f276bf99f5c033490  de35fa744ddc  4 months ago  79.6MB</span><br><span class="line">ubuntu      18.04   sha256:fd25e706f3dea2a5ff705dbc3353cf37f08307798f3e360a13e9385840f73fb3  2c047404e52d  4 months ago  63.3MB</span><br><span class="line">ubuntu      bionic  sha256:fd25e706f3dea2a5ff705dbc3353cf37f08307798f3e360a13e9385840f73fb3  2c047404e52d  4 months ago  63.3MB</span><br></pre></td></tr></table></figure>

<p>各个选项说明:</p>
<ul>
<li>**REPOSITORY：**镜像的仓库名</li>
<li>**TAG：**镜像的标签</li>
<li>**IMAGE ID：**镜像ID</li>
<li>**CREATED：**镜像创建时间</li>
<li>**SIZE：**镜像大小</li>
</ul>
<p>同一仓库名可以有多个 TAG，代表这个仓库源的不同个版本，使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p><strong>镜像 ID</strong> 是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>，<code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>1、本地标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。因为 Docker Hub 中显示的体积是压缩后的体积，而 <code>docker image ls</code> 显示的是镜像下载到本地后展开的大小，准确说，是<font color="red">展开后各层所占空间的总和</font>。</p>
<p>2、<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此<font color="red">实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多</font>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker system <span class="built_in">df</span> <span class="comment"># 查看镜像、容器、数据卷所占用的空间</span></span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          2         0         142.8MB   142.8MB (100%)</span><br><span class="line">Containers      0         0         0B        0B</span><br><span class="line">Local Volumes   0         0         0B        0B</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure>

<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>

<p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护更新，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。<code>docker build</code> 也同样可以导致这种现象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> -f dangling=<span class="literal">true</span> <span class="comment"># 列出虚悬镜像(dangling image)</span></span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image prune <span class="comment"># 删除虚悬镜像(已无价值)</span></span></span><br></pre></td></tr></table></figure>

<p><font color="red">既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code> 的镜像，不一定是虚悬镜像，也有可能是中间层镜像。</font> </p>
<h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。</p>
<p>与虚悬镜像不同，这些无标签的镜像是中间层镜像，是其它镜像所依赖的镜像。不应该删除，否则会导致上层镜像因为依赖丢失而出错。也没必要删除，相同的层只会存一遍。</p>
<p>只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>使用版本为18.04的ubuntu系统镜像来运行容器，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash <span class="comment"># 指定版本标签。当在本地主机上使用一个不存在的镜像时Docker就会自动下载这个镜像。</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/os-release <span class="comment">#  Linux 常用的查看当前系统版本的命令</span></span></span><br></pre></td></tr></table></figure>

<p><code>docker run</code> 就是运行容器的命令，这里简要的说明一下上面用到的参数：</p>
<p>参数说明：</p>
<ul>
<li><strong>-i</strong>: 交互式操作，让容器的标准输入保持打开。</li>
<li><strong>-t</strong>: 让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上。</li>
<li><strong>–rm</strong>: 容器退出或停止运行后随之将其删除。默认情况下，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</li>
<li><strong>ubuntu:18.04</strong>: 这是指用 ubuntu 18.04 版本镜像为基础来启动容器。</li>
<li><strong>&#x2F;bin&#x2F;bash</strong>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>退出终端或容器，<code>ctrl+d</code> 或 输入<code>exit</code> 。</p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker image rm --help</span><br><span class="line"></span><br><span class="line">Usage:  docker image rm [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Remove one or more images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  rm, rmi, remove</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --force      Force removal of the image</span><br><span class="line">      --no-prune   Do not delete untagged parents</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi ubuntu:15.10 <span class="comment"># 根据标签删除</span></span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">rm</span> -f 镜像短ID/镜像长ID/镜像名/镜像摘要</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               4e5021d210f6        12 days ago         64.2MB</span><br><span class="line">ubuntu              latest              4e5021d210f6        12 days ago         64.2MB</span><br><span class="line">ubuntu              16.04               77be327e4b63        5 weeks ago         124MB</span><br><span class="line">$ docker image <span class="built_in">rm</span> 4e5021d210f6 <span class="comment"># 根据镜像ID删除</span></span><br><span class="line">Error response from daemon: conflict: unable to delete 4e5021d210f6 (must be forced) - image is referenced <span class="keyword">in</span> multiple repositories</span><br><span class="line">$ docker image <span class="built_in">rm</span> ubuntu:18.04 <span class="comment"># 根据标签删除</span></span><br><span class="line">Untagged: ubuntu:18.04</span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              4e5021d210f6        12 days ago         64.2MB</span><br><span class="line">ubuntu              16.04               77be327e4b63        5 weeks ago         124MB</span><br><span class="line">$ docker image <span class="built_in">rm</span> 4e5021d210f6 <span class="comment"># 根据镜像ID删除</span></span><br><span class="line">Untagged: ubuntu:latest</span><br><span class="line">Untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d</span><br><span class="line">Deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd</span><br><span class="line">Deleted: sha256:1d9112746e9d86157c23e426ce87cc2d7bced0ba2ec8ddbdfbcc3093e0769472</span><br><span class="line">Deleted: sha256:efcf4a93c18b5d01aa8e10a2e3b7e2b2eef0378336456d8653e2d123d6232c1e</span><br><span class="line">Deleted: sha256:1e1aa31289fdca521c403edd6b37317bf0a349a941c7f19b6d9d311f59347502</span><br><span class="line">Deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853</span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               77be327e4b63        5 weeks ago         124MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更精确的是使用 &quot;镜像摘要&quot; 删除镜像</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> --digests</span><br><span class="line">REPOSITORY   TAG      DIGEST                                                                    IMAGE ID       CREATED       SIZE</span><br><span class="line">ubuntu       16.04    sha256:e9938f45e51d9ff46e2b05a62e0546d0f07489b7f22fbc5288defe760599e38a   77be327e4b63   5 weeks ago   124MB</span><br><span class="line">$ docker image <span class="built_in">rm</span> ubuntu@sha256:e9938f45e51d9ff46e2b05a62e0546d0f07489b7f22fbc5288defe760599e38a</span><br><span class="line">Untagged: ubuntu@sha256:e9938f45e51d9ff46e2b05a62e0546d0f07489b7f22fbc5288defe760599e38a</span><br><span class="line">$ docker image <span class="built_in">ls</span> --digests <span class="comment"># 删除后发现，镜像还在，但摘要信息没有了</span></span><br><span class="line">REPOSITORY   TAG       DIGEST    IMAGE ID          CREATED          SIZE</span><br><span class="line">ubuntu       16.04     &lt;none&gt;    77be327e4b63      5 weeks ago      124MB</span><br></pre></td></tr></table></figure>

<h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。</p>
<p>镜像的唯一标识是其 ID (或摘要)。当一个镜像 ID 对应多个标签时，根据 ID 删除镜像不会成功，需要先取消镜像的标签，这就是看到的 <code>Untagged</code> 的信息。只要还有其他标签指向这个镜像，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当镜像的所有标签都被取消了，它也就失去了存在的意义，便会出发删除行为。镜像是多层存储结构，因此在删除的时候也是<strong>从上层向基础层方向</strong>依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。<strong>直到没有任何层依赖当前层时，才会真实的删除当前层</strong>。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。<strong>容器是以镜像为基础，再加一层容器存储层</strong>，组成多层存储结构运行。如果该镜像被容器所依赖，那么删除该镜像必然会导致故障。<font color="red"><strong>应该先删除容器，再删除镜像。</strong></font></p>
<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>使用 <code>docker image ls -q</code> 配合使用 <code>docker image rm</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q redis) <span class="comment"># 删除所有仓库名为 redis 的镜像</span></span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q -f before=ubuntu:16.04) <span class="comment"># 删除所有在ubuntu:16.04之前的镜像</span></span><br></pre></td></tr></table></figure>

<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。<font color="red">当来自于 Docker Hub 的镜像无法满足需求时，就需要定制镜像。</font> </p>
<p>两种方式：</p>
<ul>
<li>修改已创建的容器（修改容器的存储层），并提交。</li>
<li>使用 Dockerfile 指令来创建一个新的镜像。</li>
</ul>
<h3 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h3><blockquote>
<p>注意：如果您是初学者，您可以暂时跳过后面的内容，直接学习 <strong>容器</strong> 一节。</p>
</blockquote>
<p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。如果想要定制镜像请查看下一小节。</p>
<p><font color="red">镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</font> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 80:80 nginx <span class="comment"># 用nginx镜像启动一个容器，命名为webserver</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it webserver bash <span class="comment"># 进入容器</span></span><br><span class="line"><span class="comment"># 修改主页内容，修改了容器的文件，也就是改动了容器的存储层</span></span><br><span class="line">root@ff8700bb348f:/# <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@ff8700bb348f:/# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ docker diff webserver <span class="comment"># 查看具体改动</span></span><br><span class="line">C /usr</span><br><span class="line">C /usr/share</span><br><span class="line">C /usr/share/nginx</span><br><span class="line">C /usr/share/nginx/html</span><br><span class="line">C /usr/share/nginx/html/index.html</span><br><span class="line">C /var</span><br><span class="line">C /var/cache</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/client_temp</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br><span class="line">C /run</span><br><span class="line">A /run/nginx.pid</span><br></pre></td></tr></table></figure>

<p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p>
<p>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。</p>
<p>Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code> 的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure>

<p>将容器保存为镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker commit --<span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker commit \</span></span><br><span class="line"><span class="language-bash">    --message <span class="string">&quot;修改了默认网页&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --author <span class="string">&quot;zhaolq &lt;hello@zhaolq.com&gt;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    webserver \</span></span><br><span class="line"><span class="language-bash">    nginx:v2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker commit -m=<span class="string">&quot;修改了默认网页&quot;</span> -a=<span class="string">&quot;zhaolq &lt;hello@zhaolq.com&gt;&quot;</span> ff8700bb348f zhaolq/nginx:v2</span></span><br></pre></td></tr></table></figure>

<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li><strong>ff8700bb348f:</strong> 容器 ID，指定要提交的容器。也可以使用容器的名称webserver。</li>
<li><strong>zhaolq&#x2F;nginx:v2:</strong> 指定要创建的目标镜像的 repository 和 tag。</li>
</ul>
<p>查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> nginx <span class="comment"># 列出新定制的镜像</span></span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">nginx        v2        57e58770b1dc   12 seconds ago   133MB</span><br><span class="line">nginx        latest    f6d0b4767a6c   2 months ago     133MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">history</span> nginx:v2 <span class="comment"># 查看镜像内的历史记录</span></span></span><br><span class="line">IMAGE          CREATED              CREATED BY                                      SIZE      COMMENT</span><br><span class="line">57e58770b1dc   About a minute ago   nginx -g daemon off;                            1.3kB     修改了默认网页</span><br><span class="line">f6d0b4767a6c   2 months ago         /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  STOPSIGNAL SIGQUIT           0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  EXPOSE 80                    0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  ENTRYPOINT [&quot;/docker-entr…   0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop) COPY file:e7e183879c35719c…   1.2kB</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c set -x     &amp;&amp; addgroup --system -…   63.7MB</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  ENV PKG_RELEASE=1~buster     0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  ENV NJS_VERSION=0.5.0        0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  ENV NGINX_VERSION=1.19.6     0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line">&lt;missing&gt;      2 months ago         /bin/sh -c #(nop) ADD file:422aca8901ae3d869…   69.2MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name web2 -d -p 81:80 zhaolq/nginx:v2 <span class="comment"># 使用新定制的镜像运行一个容器</span></span></span><br></pre></td></tr></table></figure>

<p>至此，我们完成了定制镜像，使用 <code>docker commit</code> 命令手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储有了更直观的感觉。</p>
<p><font color="red" size="5"><strong>慎用 <code>docker commit</code></strong> </font></p>
<p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有<strong>很多文件被改动或添加</strong>了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的<strong>无关内容被添加进来</strong>，将会导致镜像极为<strong>臃肿</strong>。</p>
<p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p>
<p>镜像使用的是分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
<h3 id="使用-Dockerfile-构建镜像"><a href="#使用-Dockerfile-构建镜像" class="headerlink" title="使用 Dockerfile 构建镜像"></a>使用 Dockerfile 构建镜像</h3><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<h4 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h4><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>还以定制 <code>nginx</code> 镜像为例，这次使用 Dockerfile 定制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ <span class="built_in">touch</span> Dockerfile</span><br><span class="line">$ vim Dockerfile</span><br><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<h5 id="Ubuntu的Dockerfile"><a href="#Ubuntu的Dockerfile" class="headerlink" title="Ubuntu的Dockerfile"></a>Ubuntu的Dockerfile</h5><p> <a target="_blank" rel="noopener" href="https://hub.docker.com/_/ubuntu">https://hub.docker.com/_/ubuntu</a> </p>
<h5 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h5><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。</p>
<p><code>FROM</code> 指定 <strong>基础镜像</strong>，一个 <code>Dockerfile</code> 中 <code>FROM</code> 是<font color="red"><strong>必备指令</strong></font>，并且必须是第一条指令（有异议，因为<code>ARG</code>指令可以放到<code>FROM</code>前面）。</p>
<p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/php/"><code>php</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/node"><code>node</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/python/"><code>python</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/ubuntu/"><code>ubuntu</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/debian/"><code>debian</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/centos/"><code>centos</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/fedora/"><code>fedora</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/alpine/"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p><font color="red">Docker 还存在一个特殊的镜像，名为 <code>scratch</code> </font>。这个镜像是虚拟的概念，并不实际存在，<font color="red">它表示一个空白的镜像</font>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch <span class="comment"># 表示一个空白的镜像，不以任何镜像为基，接下来所写的指令将作为镜像第一层开始存在。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a target="_blank" rel="noopener" href="https://golang.google.cn/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h5 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h5><p><code>RUN</code> 指令是用来执行命令行命令的，其格式有两种：</p>
<ul>
<li><font color="red"><em>shell</em> 格式</font>：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="red"><em>exec</em> 格式</font>：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>

<p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。</p>
<p>每一个 <code>RUN</code> 的行为：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生<font color="red"><strong>非常臃肿</strong>、<strong>非常多层</strong></font>的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p><font color="red"><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></font> </p>
<p> <code>Dockerfile</code> 正确的写法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure>

<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这应该是一层的事情。</p>
<p>这不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。</p>
<p><font color="red">每一层构建的最后一定要清理掉无关文件，避免镜像臃肿</font> 。这是很重要的一步，因为镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保<font color="red">每一层只添加</font> 真正需要添加的东西，任何无关的东西都应该<font color="red">在每一层构建的最后清理掉</font> 。</p>
<h4 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h4><h5 id="docker-build-构建"><a href="#docker-build-构建" class="headerlink" title="docker build 构建"></a>docker build 构建</h5><p>格式：<code>docker build [选项] &lt;上下文路径/URL/-&gt;</code> </p>
<p><font color="red">在 <code>Dockerfile</code> 文件所在目录执行</font>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">$ docker build -t nginx:v3 . <span class="comment"># 注意这里的&quot;.&quot;表示上下文路径。未指定Dockerfile文件时，默认将上下文路径下名为Dockerfile的文件作为Dockerfile</span></span><br><span class="line">$ docker build -t nginx:v3 -f /home/mynginx/Dockerfile /home/mynginx/ <span class="comment"># 指定Dockerfile</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  2.048kB <span class="comment"># 发送上下文内容</span></span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"> ---&gt; f6d0b4767a6c <span class="comment"># nginx:latest镜像ID</span></span><br><span class="line">Step 2/2 : RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 12e58f75c0a9 <span class="comment"># 启动一个容器执行所要求的命令(echo命令)</span></span><br><span class="line">Removing intermediate container 12e58f75c0a9 <span class="comment"># 移除中间容器。疑问：感觉应该先提交再删除，不咋清楚为啥会这样？</span></span><br><span class="line"> ---&gt; 24a53bbd421a <span class="comment"># 提交这一层，最后的镜像ID为24a53bbd421a </span></span><br><span class="line">Successfully built 24a53bbd421a </span><br><span class="line">Successfully tagged nginx:v3</span><br><span class="line"></span><br><span class="line">$ docker run --name web3 -d -p 80:80 nginx:v3</span><br></pre></td></tr></table></figure>

<h5 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h5><p> <code>docker build</code> 命令最后有一个 <code>.</code> 表示当前目录。并不是指定 Dockerfile 路径，而是指定<strong>上下文路径</strong>，其中包括构建镜像所需的一切文件。<font color="red"><code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</font> </p>
<p> <code>docker build</code> 的工作原理：Docker 在运行时分为 <strong>Docker 引擎</strong>（也就是服务端守护进程）和<strong>客户端工具</strong>。Docker 的引擎提供了一组 REST API，被称为 <a target="_blank" rel="noopener" href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，<font color="red">一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</font> </p>
<p> <code>docker build</code> 命令构建镜像，其实是在 Docker 引擎中构建（服务端）。引入上下文概念，在构建时，用户会指定构建镜像上下文的路径， <code>docker build</code> 命令得知这个路径，会将路径下的所有内容打包，上传给 Docker 引擎，Docker 引擎展开这个上下文包就会获得构建镜像所需的一切文件。这样我们就可以通过 <code>COPY</code> 指令、<code>ADD</code> 指令将这些本地文件复制进镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /app/ <span class="comment"># 复制 上下文（context） 目录下的 package.json 文件到 /app 目录</span></span><br></pre></td></tr></table></figure>

<p><font color="red" size="4"><strong>注意：</strong></font></p>
<p>​		千万不要将硬盘根目录用做上下文路径，如果那样，会让 <code>docker build</code> 打包整个硬盘，发送一个几十 GB 的东西给 Docker 引擎，极为缓慢而且很容易构建失败，这显然是错误使用。如果目录下有些东西确实不希望构建时传给 Docker 引擎，可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>​		<font color="red">默认情况下</font>，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。可以用 <code>-f ../MyDockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。当然，<font color="red">一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</font> </p>
<h5 id="镜像层数"><a href="#镜像层数" class="headerlink" title="镜像层数"></a>镜像层数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim Dockerfile</span><br><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line">COPY ./package.json /app/ <span class="comment"># 复制 上下文（context） 目录下的 package.json</span></span><br></pre></td></tr></table></figure>

<p>利用上述 Dockerfile 构建镜像会建立三层（三个）镜像：</p>
<p>​		1、官方的 nginx 镜像。<br>​		2、RUN 指令镜像。<br>​		3、COPY 指令镜像。</p>
<p>3层镜像依赖2层镜像，2层镜像依赖1层镜像。</p>
<p>删除3层镜像时，会触发依赖镜像的删除（1、2层镜像），但是实际上1层镜像并没有删除，因为还有标签指向该镜像，那就是官方的标签 <code>nginx:latest</code> 。如果先取消官方镜像的标签，再删除3层镜像，1、2层镜像（依赖镜像）就会跟随一起删除。</p>
<h5 id="从URL构建"><a href="#从URL构建" class="headerlink" title="从URL构建"></a><font color="red">从URL构建</font></h5><p><strong>1、用 Git repo 构建</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</span><br></pre></td></tr></table></figure>

<p>这行命令指定了构建所需的 Git repo、分支 <code>master</code>，构建目录 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<p><strong>2、用给定的 tar 压缩包构建</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>

<p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h5 id="从标准输入构建"><a href="#从标准输入构建" class="headerlink" title="从标准输入构建"></a><font color="red">从标准输入构建</font></h5><p><strong>1、从标准输入中读取 Dockerfile 进行构建</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure>

<p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它<font color="red">没有上下文</font>，因此<font color="red">不可以</font>像其他方法那样可以<font color="red">将本地文件 <code>COPY</code> 进镜像</font>之类的事情。</p>
<p><strong>2、从标准输入中读取上下文压缩包进行构建</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>

<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，<font color="red">将里面视为上下文</font>，并开始构建。</p>
<h3 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h3><p>我们已经介绍了 <code>FROM</code>，<code>RUN</code>，还提及了 <code>COPY</code>, <code>ADD</code>，其实 <code>Dockerfile</code> 功能很强大，它提供了十多个指令。</p>
<h4 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/copy.md">COPY 复制文件</a></h4><p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件或目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure>

<p><font color="red"><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符</font>，其通配符规则要满足 Go 的 <a target="_blank" rel="noopener" href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line">COPY a.txt b.txt c.txt /mydir/ # 将前三个文件复制到/mydir/目录下</span><br><span class="line">COPY nginx-1.18.0.tar.gz /mydir/ # 不会自动解压，ADD指定可以自动解压部分格式</span><br></pre></td></tr></table></figure>

<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。<font color="red">目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</font> </p>
<p>此外，还需要注意一点，<font color="red">使用 <code>COPY</code> 指令，源文件的各种元数据都会保留，比如读、写、执行权限、文件变更时间等</font>。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来<font color="red">改变文件的所属用户及所属组。</font> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPY --chown=55:mygroup files* /mydir/</span><br><span class="line">COPY --chown=bin files* /mydir/</span><br><span class="line">COPY --chown=1 files* /mydir/</span><br><span class="line">COPY --chown=10:11 files* /mydir/</span><br></pre></td></tr></table></figure>

<p><font color="red">如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</font> </p>
<h4 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/add.md">ADD 更高级的复制文件</a></h4><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如<font color="red"> <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code></font>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。<font color="red">下载后的文件权限自动设置为 <code>600</code></font>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。<font color="red">因此，这个功能其实并不实用，而且不推荐使用。</font> </p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<font color="red"><code>ADD</code> 指令会自动解压缩</font>这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/appendix/best_practices.md">Dockerfile 最佳实践文档</a> 中要求，<font color="red">尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确</font>，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。<font color="red">最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</font> </p>
<p>另外需要注意的是，<font color="red"><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</font> </p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的<font color="red">原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</font> </p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来<font color="red">改变文件的所属用户及所属组。</font> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD --chown=55:mygroup files* /mydir/</span><br><span class="line">ADD --chown=bin files* /mydir/</span><br><span class="line">ADD --chown=1 files* /mydir/</span><br><span class="line">ADD --chown=10:11 files* /mydir/</span><br></pre></td></tr></table></figure>

<h4 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/cmd.md">CMD 容器启动命令</a></h4><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p><font color="red"><code>CMD</code> 指令如果写了多次，只有最后一个生效。</font> </p>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要<font color="red">指定所运行的程序及参数</font>。<code>CMD</code> 指令就是用于<font color="red">指定容器主进程的启动命令</font>。</p>
<p><font color="red">在运行时可以指定新的命令来替代镜像中设置的默认命令</font>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it ubuntu <span class="comment"># ubuntu镜像默认的CMD是/bin/bash，所以会直接进入bash</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it ubuntu <span class="built_in">cat</span> /etc/os-release <span class="comment"># 用`cat /etc/os-release`命令替换默认的`/bin/bash`命令，输出系统版本信息</span></span></span><br></pre></td></tr></table></figure>

<p>在指令格式上，一般<font color="red">推荐使用 <code>exec</code> 格式</font>，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p>
<p>如果<font color="red">使用 <code>shell</code> 格式</font>的话，实际的命令会<font color="red">被包装为 <code>sh -c</code> 的参数的形式</font>进行执行。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure>

<p>在实际执行中，会将其变更为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="https://man.linuxde.net/sh">sh命令</a> </p>
<p><font color="red">环境变量会被 shell 进行解析处理</font> </p>
<p><font color="blue" size="4"><strong>前台执行和后台执行的问题</strong></font> </p>
<p>Docker 不是虚拟机，<font color="red">容器中的应用都应该以前台执行</font>。而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，<font color="red">容器内没有后台服务的概念</font>。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>

<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。</p>
<p>对于容器而言，其启动程序就是容器主进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p><font color="red">正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行</font>。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/entrypoint.md">ENTRYPOINT 入口点</a></h4><p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A5%E5%8F%A3%E7%82%B9">入口点</a> </p>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。</p>
<p><code>ENTRYPOINT</code> <font color="red">在运行时也可以替代</font>，通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p><font color="red">当指定 <code>ENTRYPOINT</code> 后</font>，<code>CMD</code> 不再直接运行其命令，<font color="red"><code>CMD</code> 的内容将作为参数传给 <code>ENTRYPOINT</code> 指令</font>。换句话说实际执行时，将变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>

<p><font color="red"><code>CMD</code> 指令如果写了多次，只有最后一个生效。</font> </p>
<p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p>
<p><strong>场景一：让镜像变成像命令一样使用</strong> </p>
<p>假设需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://myip.ipip.net&quot; ]</span><br></pre></td></tr></table></figure>

<p>假如使用 <code>docker build -t myip:v1 .</code> 来构建镜像的话，如果需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> myip:v1</span></span><br><span class="line">当前 IP：8.129.8.11  来自于：中国 广东 深圳  阿里云/电信/联通/移动/教育网</span><br></pre></td></tr></table></figure>

<p><font color="red"> <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。</font> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> myip:v1 -i</span></span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:367: starting container process caused: exec: &quot;-i&quot;: executable file not found in $PATH: unknown.</span><br></pre></td></tr></table></figure>

<p>可以看到可执行文件找不到的报错。 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/cmd.md">CMD 容器启动命令</a> 说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run myip curl -s http://myip.ipip.net -i <span class="comment"># 这显然不是很好的解决方案</span></span></span><br></pre></td></tr></table></figure>

<p><font color="red">使用 <code>ENTRYPOINT</code> 可以解决这个问题</font>，重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://myip.ipip.net&quot; ]</span><br></pre></td></tr></table></figure>

<p>再次使用 <code>docker run --rm myip:v1 -i</code> 就成功了。<font color="red">因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</font> </p>
<p><strong>场景二：应用运行前的准备工作</strong></p>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure>

<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。进入redis容器可查看全部 docker-entrypoint.sh 脚本内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">set -e</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or first arg is `something.conf`</span></span><br><span class="line">if [ &quot;$&#123;1#-&#125;&quot; != &quot;$1&quot; ] || [ &quot;$&#123;1%.conf&#125;&quot; != &quot;$1&quot; ]; then</span><br><span class="line">        set -- redis-server &quot;$@&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allow the container to be started with `--user`</span></span><br><span class="line">if [ &quot;$1&quot; = &#x27;redis-server&#x27; -a &quot;$(id -u)&quot; = &#x27;0&#x27; ]; then</span><br><span class="line">        find . \! -user redis -exec chown redis &#x27;&#123;&#125;&#x27; +</span><br><span class="line">        exec gosu redis &quot;$0&quot; &quot;$@&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="https://man.linuxde.net/sub/shell%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4">Shell内建命令</a> </p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/boling_cavalry/article/details/93380447">docker与gosu</a> </p>
<p> <a target="_blank" rel="noopener" href="https://github.com/tianon/gosu">https://github.com/tianon/gosu</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-set.html">Linux set命令 - 菜鸟教程</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-shell-passing-arguments.html">Shell 传递参数 - 菜鸟教程</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-shell-basic-operators.html">Shell 基本运算符 - 菜鸟教程</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-id.html">Linux id命令 - 菜鸟教程</a> </p>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it redis <span class="built_in">id</span></span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure>

<h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/env.md">ENV 设置环境变量</a></h4><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure>

<h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/arg.md">ARG 构建参数</a></h4><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，<font color="red">在将来容器运行时不会存在这些环境变量</font>。但是<font color="red">不要因此就使用 <code>ARG</code> 保存密码</font>之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p>
<p><font color="red">ARG 指令有生效范围</font>，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只在 FROM 中生效</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line">RUN set -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后面的 FROM 指令可以使用<span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br></pre></td></tr></table></figure>

<h4 id="VOLUME-挂载为匿名卷"><a href="#VOLUME-挂载为匿名卷" class="headerlink" title="VOLUME 挂载为匿名卷"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/volume.md">VOLUME 挂载为匿名卷</a></h4><p> <a target="_blank" rel="noopener" href="https://einverne.github.io/post/2018/03/docker-v-and-mount.html">docker volumes 中 -v 和 -mount 区别</a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/storage/volumes/">https://docs.docker.com/storage/volumes/</a> </p>
<p>格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。</p>
<p><strong>为了防止运行时用户忘记将动态文件所保存目录挂载为卷</strong>，<font color="blue"><strong>在 <code>Dockerfile</code> 中</strong></font>，可以<font color="red">事先指定某些目录挂载为<strong>匿名卷</strong></font>，这样在运行时如果用户不指定挂载也<font color="red">不会向容器存储层写入大量数据</font>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data # 容器内数据卷的路径</span><br></pre></td></tr></table></figure>

<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为<font color="red">匿名卷</font>，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。</p>
<p>由于匿名挂载的时候只指定了 <code>容器内数据卷的路径</code>，那么<font color="red">到底挂载到 <code>宿主机</code> 的哪个路径</font>，可以使用以下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                    NAMES</span><br><span class="line">d9ec1b9f548f   b29265c0674f   &quot;docker-entrypoint.s…&quot;   2 minutes ago   Up 2 minutes   0.0.0.0:8889-&gt;6379/tcp   magical_kepler</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect d9ec1b9f548f</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        ...... # 省略</span><br><span class="line">        # 注意：Mounts是一个数组，因为可以挂载多个匿名卷</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;45e207ba329fbd2f7d09ced2bc474c9204a5a6747a72560a4faf7783761a936a&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/45e207ba329fbd2f7d09ced2bc474c9204a5a6747a72560a4faf7783761a936a/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/data&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">        ...... #省略</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Mounts</strong> 中可以看到 <strong>Destination</strong> 和 <strong>Source</strong> 分别就是 容器内数据卷路径 和 宿主机容器卷路径。</p>
<h4 id="–运行容器时挂载–"><a href="#–运行容器时挂载–" class="headerlink" title="–运行容器时挂载–"></a>–运行容器时挂载–</h4><p>匿名挂载（<font color="red">匿名卷</font>）：在进行数据卷挂载的时候<strong>不指定</strong> <code>宿主机数据卷的路径</code>，<code>-v</code> 命令之后直接跟上 <code>容器内数据卷的路径</code>。<font color="red">会覆盖 <strong>VOLUME</strong> 定义的匿名卷。</font> </p>
<p>具名挂载（<font color="red">命名卷</font>）：在进行数据卷挂载的时候<strong>既指定</strong> <code>宿主机数据卷的路径</code>，又指定 <code>容器内数据卷的路径</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载（匿名卷），会覆盖 VOLUME 定义的匿名卷。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v /data IMAGE_ID</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载（命名卷）, -v 宿主机数据卷的路径:容器内数据卷的路径</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -v /home/mydata:/data IMAGE_ID</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 6379:6379 -v /home/mydata:/data IMAGE_ID</span></span><br></pre></td></tr></table></figure>

<p>在这行命令中，就使用了 <code>/home/mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷挂载配置。</p>
<h4 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/expose.md">EXPOSE 暴露端口</a></h4><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，<font color="red">这只是一个声明</font>，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。</p>
<p>在 Dockerfile 中写入这样的声明有两个好处：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；</li>
<li>在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时（<font color="red">P 大写</font>），会<font color="red">自动随机映射</font> <code>EXPOSE</code> 的端口。</li>
</ul>
<p><font color="blue" size="4"> <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 的<font color="red">区别</font>：</font> </p>
<p> <code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问。而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<p><font size="4">下面使用随机宿主端口映射到 <code>EXPOSE</code> 暴露的端口：</font> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">redis        6.2.1     b29265c0674f   3 days ago     105MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P --name=redis redis:6.2.1</span></span><br><span class="line">02873235266e4f0574c5a1376f92ca0afe8ac7c1065c975d21ab4e8ebab1793f</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS         PORTS                     NAMES</span><br><span class="line">02873235266e   redis:6.2.1   &quot;docker-entrypoint.s…&quot;   4 seconds ago   Up 3 seconds   0.0.0.0:49154-&gt;6379/tcp   redis</span><br></pre></td></tr></table></figure>

<h4 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/workdir.md">WORKDIR 指定工作目录</a></h4><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来<font color="red">指定工作目录做为以后各层的当前目录</font>，如该目录不存在，<code>WORKDIR</code> 会帮助建立目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd /app</span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure>

<p>以上 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件。原因很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。</p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>改变以后各层的工作目录的位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure>

<p>如果 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line"></span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p>
<h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/user.md">USER 指定当前用户</a></h4><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是<font color="red">改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</font> </p>
<p>注意，<code>USER</code> <font color="red">只是帮助切换到指定用户而已，这个用户必须是事先建立好的</font>，否则无法切换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure>

<p>如果以 <code>root</code> 执行的脚本，在<font color="red">执行期间希望改变身份</font>，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。<font color="red">建议使用 <a target="_blank" rel="noopener" href="https://github.com/tianon/gosu"><code>gosu</code></a>，阅读本文 <code>ENTRYPOINT 入口点</code> - <code>场景二</code> 以更好的了解gosu。</font> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"># 下载 gosu</span><br><span class="line">RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot; \</span><br><span class="line">    &amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">    &amp;&amp; gosu nobody true</span><br><span class="line"># 设置 CMD，并以另外的用户执行</span><br><span class="line">CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure>

<h4 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/healthcheck.md">HEALTHCHECK 健康检查</a></h4><p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令。<strong>命令</strong>格式分为 <code>shell</code> 格式和 <code>exec</code> 格式。<strong>命令的返回值</strong>决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> <font color="red">如果写了多个，只有最后一个生效。</font> </p>
<p><code>HEALTHCHECK</code> 指令是<font color="red">告诉 Docker 怎样判断容器状态是否正常</font>。这是 Docker 1.12 引入的新指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否正常，从而真实的反应容器实际状态。</p>
<p>三种状态：</p>
<ul>
<li>starting：初始状态</li>
<li>healthy：检查成功</li>
<li>unhealthy：连续失败指定次数后视为失败</li>
</ul>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;检查间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;检查命令运行时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;重试次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，<font color="red">默认 3 次</font>。</li>
</ul>
<p>假设有个最简单的 Web 服务镜像，希望增加健康检查来判断其 Web 服务是否在正常工作，可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 写法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s \</span><br><span class="line">  CMD curl -fs http://localhost/ || exit 1</span><br></pre></td></tr></table></figure>

<p>这里设置了使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令，每 5 秒检查一次，健康检查命令超过 3 秒没响应就视为失败。</p>
<p>构建镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t myweb:v1 .</span></span><br></pre></td></tr></table></figure>

<p>启动容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --name web -p 80:80 myweb:v1</span></span><br></pre></td></tr></table></figure>

<p>查看状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始状态为 (health: starting)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS                           PORTS                  NAMES</span><br><span class="line">ba6fc1e74956   myweb:v1   &quot;/docker-entrypoint.…&quot;   2 seconds ago   Up 1 second (health: starting)   0.0.0.0:8080-&gt;80/tcp   web</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待几秒钟后，再次查看，健康状态变为 (healthy)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS                   PORTS                  NAMES</span><br><span class="line">ba6fc1e74956   myweb:v1   &quot;/docker-entrypoint.…&quot;   8 seconds ago   Up 7 seconds (healthy)   0.0.0.0:8080-&gt;80/tcp   web</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。</span></span><br></pre></td></tr></table></figure>

<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect --format <span class="string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> web | python -m json.tool</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;FailingStreak&quot;: 0,</span><br><span class="line">    &quot;Log&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;End&quot;: &quot;2021-03-31T14:56:59.605914326+08:00&quot;,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\&quot;http://nginx.org/\&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\&quot;http://nginx.com/\&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;,</span><br><span class="line">            &quot;Start&quot;: &quot;2021-03-31T14:56:59.532338081+08:00&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Status&quot;: &quot;healthy&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ONBUILD-为他人作嫁衣裳"><a href="#ONBUILD-为他人作嫁衣裳" class="headerlink" title="ONBUILD 为他人作嫁衣裳"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/onbuild.md">ONBUILD 为他人作嫁衣裳</a></h4><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，<font color="red">后面跟其它指令</font>，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有<font color="red">当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</font> </p>
<p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p>
<p>示例：<a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/onbuild.md">https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/onbuild.md</a> </p>
<h4 id="LABEL-为镜像添加元数据"><a href="#LABEL-为镜像添加元数据" class="headerlink" title="LABEL 为镜像添加元数据"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/label.md">LABEL 为镜像添加元数据</a></h4><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL org.opencontainers.image.authors=&quot;zhaolq&quot;</span><br><span class="line"></span><br><span class="line">LABEL org.opencontainers.image.documentation=&quot;https://blog.zhaolq.com/&quot;</span><br></pre></td></tr></table></figure>

<p>具体可以参考 <a target="_blank" rel="noopener" href="https://github.com/opencontainers/image-spec/blob/master/annotations.md">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p>
<h4 id="SHELL-指令"><a href="#SHELL-指令" class="headerlink" title="SHELL 指令"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/shell.md">SHELL 指令</a></h4><p>格式：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SHELL` 指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `[&quot;/bin/sh&quot;, &quot;-c&quot;]</span><br><span class="line">SHELL [&quot;/bin/sh&quot;, &quot;-c&quot;]</span><br><span class="line"></span><br><span class="line">RUN lll ; ls</span><br><span class="line"></span><br><span class="line">SHELL [&quot;/bin/sh&quot;, &quot;-cex&quot;]</span><br><span class="line"></span><br><span class="line">RUN lll ; ls</span><br></pre></td></tr></table></figure>

<p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p>
<p>当 <code>ENTRYPOINT</code> <code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;/bin/sh&quot;, &quot;-cex&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/sh -cex <span class="string">&quot;nginx&quot;</span></span></span><br><span class="line">ENTRYPOINT nginx</span><br><span class="line">SHELL [&quot;/bin/sh&quot;, &quot;-cex&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/sh -cex <span class="string">&quot;nginx&quot;</span></span></span><br><span class="line">CMD nginx</span><br></pre></td></tr></table></figure>

<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/dockerfile/references.md">参考文档</a></h4><ul>
<li><code>Dockerfie</code> 官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
<li><code>Dockerfile</code> 最佳实践文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></li>
<li><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a target="_blank" rel="noopener" href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></li>
</ul>
<h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/multistage-builds/README.md">多阶段构建</a></h2><p>…</p>
<h2 id="构建多种系统架构支持的镜像"><a href="#构建多种系统架构支持的镜像" class="headerlink" title="构建多种系统架构支持的镜像"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/manifest.md">构建多种系统架构支持的镜像</a></h2><p>…</p>
<h2 id="其它制作镜像的方式"><a href="#其它制作镜像的方式" class="headerlink" title="其它制作镜像的方式"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/image/other.md">其它制作镜像的方式</a></h2><p>除了标准的使用 <code>Dockerfile</code> 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p>
<h3 id="从-rootfs-跟文件系统-压缩包导入"><a href="#从-rootfs-跟文件系统-压缩包导入" class="headerlink" title="从 rootfs(跟文件系统) 压缩包导入"></a>从 rootfs(跟文件系统) 压缩包导入</h3><p>请阅读下文中 <code>导出和导入容器</code> 小节。</p>
<h3 id="Docker-镜像的导入和导出"><a href="#Docker-镜像的导入和导出" class="headerlink" title="Docker 镜像的导入和导出"></a>Docker 镜像的导入和导出</h3><p> <code>docker save</code> 和 <code>docker load</code> 命令，用以将镜像保存为归档文件，然后传输到另一个服务器上，再加载进来。这是在没有 Docker Registry 时的做法，现在<font color="red">已经不推荐</font>，镜像迁移<font color="red">应该使用 Docker Registry</font>，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<p><font color="red"> <code>docker save</code> 导出镜像存储文件（将镜像保存为归档文件）：</font> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images ubuntu</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu       21.04     de35fa744ddc   4 months ago   79.6MB</span><br><span class="line">ubuntu       18.04     2c047404e52d   4 months ago   63.3MB</span><br><span class="line">ubuntu       bionic    2c047404e52d   4 months ago   63.3MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save ubuntu:21.04 -o ubuntu-21.04.tar <span class="comment"># 可以是任意后缀名，但文件的本质都是归档文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save ubuntu:21.04 | gzip &gt; ubuntu-21.04.tar <span class="comment"># 使用 gzip 压缩，大大节省了占用空间</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注意：如果同名则会覆盖（没有警告）</strong> </p>
<p><font color="red"> <code>docker load</code> 导入镜像存储文件到本地镜像库</font> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker load -i ubuntu-21.04.tar</span></span><br><span class="line">Loaded image: ubuntu:21.04</span><br></pre></td></tr></table></figure>

<p>如果我们结合这两个命令以及 <code>ssh</code> 甚至 <code>pv</code> 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; <span class="string">&#x27;cat | docker load&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p><font color size="5"><strong>新建并启动</strong></font> </p>
<p>阅读上文 <code>使用镜像</code> - <code>运行容器</code> 。</p>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/repository/README.md">registry</a> 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p><font color size="5"><strong>启动已终止的容器</strong></font> </p>
<p> <code>docker container start</code> </p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p> <code>docker container stop</code> </p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p> <code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>如果<font color="red">不使用 <code>-d</code> 参数</font>运行容器，容器会把输出的结果 (STDOUT) 打印到宿主机上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name helloworld --<span class="built_in">rm</span> ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果<font color="red">使用 <code>-d</code> 参数</font>运行容器，容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上(<font color="red">输出结果可以用 <code>docker logs</code> 查看</font>)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name helloworld -d --<span class="built_in">rm</span> ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span></span><br><span class="line">21d72e9bc931a4565a29c2490d1f6ba621bbc9fad6585fbe72b69638ac582138</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                NAMES</span><br><span class="line">21d72e9bc931   ubuntu:18.04   &quot;/bin/sh -c &#x27;while t…&quot;   17 seconds ago   Up 16 seconds                        helloworld</span><br></pre></td></tr></table></figure>

<p>通过 <code>docker container logs</code> 命令获取容器的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container logs [container ID or NAMES]</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>有些时候需要<font color="red">进入正在后台运行的容器</font>进行操作，可以使用 <code>docker attach</code> 或 <code>docker exec</code> 命令。</p>
<p>推荐使用 <code>docker exec</code> ，因为从这个 stdin 中 exit，不会导致容器停止。</p>
<p><font color size="5"><strong><code>attach</code> 命令</strong></font> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -dit ubuntu:18.04</span></span><br><span class="line">5a8e0c1b1bc28abe0f6067872abb19af9c86418e0836facd486e190904c2275f</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                NAMES</span><br><span class="line">5a8e0c1b1bc2   ubuntu:18.04   &quot;/bin/bash&quot;              5 seconds ago   Up 5 seconds                        elated_lederberg</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker attach 5a8e</span></span><br><span class="line">root@5a8e0c1b1bc2:/# exit</span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                     PORTS                NAMES</span><br><span class="line">5a8e0c1b1bc2   ubuntu:18.04   &quot;/bin/bash&quot;              50 seconds ago   Exited (0) 7 seconds ago                        elated_lederberg</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>注意：</strong></font> 如果从这个 stdin 中 exit，会导致容器停止。</p>
<p><font color size="5"><strong><code>exec</code> 命令</strong></font> </p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有 Linux 命令提示符，但命令执行结果仍然可以返回。<code>Tab</code> 键不会自动填充。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，界面<font color="red">有 Linux 命令提示符</font>。<code>Tab</code> 键<font color="red">会自动填充</font>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -dit ubuntu:18.04</span></span><br><span class="line">5a8e0c1b1bc28abe0f6067872abb19af9c86418e0836facd486e190904c2275f</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                NAMES</span><br><span class="line">5a8e0c1b1bc2   ubuntu:18.04   &quot;/bin/bash&quot;              5 seconds ago   Up 5 seconds                        elated_lederberg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -i 5a8e bash</span></span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it 5a8e bash</span></span><br><span class="line">root@5a8e0c1b1bc2:/#</span><br></pre></td></tr></table></figure>

<h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><p><font color size="5"><strong>导出容器快照</strong></font> </p>
<p> <code>docker export</code> 将容器的文件系统<strong>导出</strong>为 tar 存档<strong>到当前目录</strong>，<strong>无论容器是否运行</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED      STATUS      PORTS                NAMES</span><br><span class="line">ff8700bb348f   nginx     &quot;/docker-entrypoint.…&quot;   2 days ago   Up 2 days   0.0.0.0:80-&gt;80/tcp   webserver</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">export</span> ff8700bb348f &gt; nginx.tar</span></span><br></pre></td></tr></table></figure>

<p><font color size="5"><strong>导入容器快照</strong></font> </p>
<p> <code>docker import</code> 导入容器快照<font color="red">到本地镜像库</font>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker import nginx.tar <span class="built_in">test</span>/nginx:v1.0 <span class="comment"># 从本地获取文件并导入</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker import http://IP地址/nginx.tar.gz <span class="built_in">test</span>/nginx:v1.0 <span class="comment"># 从远程Web获取文件并导入</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> nginx.tar | docker import - <span class="built_in">test</span>/nginx:v1.0 <span class="comment"># 从标准输入中获取文件并导入</span></span></span><br><span class="line"></span><br><span class="line">sha256:ab49349d50dc20f3ded114a8242ab94a283c9c5f93c84c049b60bc5b6afaa3aa</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">test/nginx   v1.0      ab49349d50dc   9 seconds ago   131MB</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color="red" style="background-color:#FFF333;"><em>注：</em></font> </p>
<p><font color="red" style="background-color:#FFF333;"><em>用户既可以使用 <code>docker load</code> 来<font color="green">导入镜像存储文件到本地镜像库</font>，也可以使用 <code>docker import</code> 来<font color="green">导入容器快照到本地镜像库</font>。</em></font> </p>
<p><font color="red" style="background-color:#FFF333;"><em>两者区别在于：</em></font> </p>
<p>1、归档文件不同。<code>docker load</code> 用来导入由 <code>docker save</code> 导出的<strong>镜像存储文件</strong>；<code>docker import</code> 用来导入由 <code>docker export</code> 导出的<strong>容器快照</strong>。</p>
<p>2、文件大小不同。容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态）；镜像存储文件将保存完整记录，体积也要大。</p>
<p>3、从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p><font color="red" style="background-color:#FFF333;"><em>相同点：</em></font> </p>
<p>​    都是导入到本地镜像库。</p>
<p>​    即便原来的镜像有依赖，导出再导入后，都只有一个镜像。</p>
</blockquote>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">rm</span> [container ID or NAMES] <span class="comment"># 删除一个处于终止状态的容器</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> [container ID or NAMES] <span class="comment"># 简写</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -f [container ID or NAMES] <span class="comment"># 删除一个运行中的容器</span></span></span><br></pre></td></tr></table></figure>

<p>清理所有处于终止状态的容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container prune</span></span><br></pre></td></tr></table></figure>

<h1 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>注册服务器（<code>Registry</code>）是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。</p>
<p>从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<h2 id="Docker-Hub-1"><a href="#Docker-Hub-1" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><h3 id="登录登出"><a href="#登录登出" class="headerlink" title="登录登出"></a>登录登出</h3><p> <code>docker login YourDomainName OR HostIP</code> </p>
<p> <code>docker logout</code> </p>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p> <code>docker push</code> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">ubuntu       18.04     2c047404e52d   4 months ago     63.3MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker tag ubuntu:18.04 hellozhaolq/ubuntu:18.04 <span class="comment"># 必须重打标签，否则没有权限。hellozhaolq为Docker账号用户名</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">hellozhaolq/ubuntu   18.04     2c047404e52d   4 months ago   63.3MB</span><br><span class="line">ubuntu               18.04     2c047404e52d   4 months ago   63.3MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push hellozhaolq/ubuntu:18.04</span></span><br><span class="line">The push refers to repository [docker.io/hellozhaolq/ubuntu]</span><br><span class="line">fe6d8881187d: Pushed</span><br><span class="line">23135df75b44: Pushed</span><br><span class="line">b43408d5f11b: Pushed</span><br><span class="line">18.04: digest: sha256:a7fa45fb43d471f4e66c5b53b1b9b0e02f7f1d37a889a41bbe1601fac70cb54e size: 943</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker search hellozhaolq</span></span><br><span class="line">NAME      DESCRIPTION   STARS     OFFICIAL   AUTOMATED</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索不到，不知为何，但是可以pull</span></span><br></pre></td></tr></table></figure>

<h3 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h3><p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E9%92%A9%E5%AD%90">网络钩子 - 维基百科</a> </p>
<p>自动构建（<code>Automated Builds</code>）功能对于需要经常升级镜像内程序来说，十分方便。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a target="_blank" rel="noopener" href="https://github.com/">GitHub</a> 或 <a target="_blank" rel="noopener" href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>1、创建 GitHub 仓库： <code>docker-automated-builds-test</code> ，包含 <code>Dockerfile</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">COPY EchoContent /home/</span><br><span class="line">WORKDIR /home/</span><br><span class="line">CMD cat EchoContent</span><br></pre></td></tr></table></figure>

<p><img src="/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210402145935031.png" alt="image-20210402145935031"></p>
<p>2、Docker Hub 关联账户。在 Docker Hub 上点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站。例如关联GitHub，成功关联后会在 <code>Acccount settings</code> - <code>Applications</code> 看到授权的OAuth应用 <code>Docker Hub Builder</code>。</p>
<p>3、创建 Docker Hub 仓库： <code>docker-automated-builds-test</code> 。</p>
<p>4、配置自动构建。在 Docker Hub 仓库 <code>Builds</code> 选项卡中选取一个目标网站中的项目，指定 <code>Dockerfile</code> 的位置，最后点击 Sava And Build 自动构建。这时，目标网站仓库的 <code>settings</code> 中已经配置了 <code>Webhooks</code> 和 <code>Deploy keys</code>。</p>
<p><img src="/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210402153201618.png" alt="image-20210402153201618"></p>
<p>5、查看构建结果：</p>
<p><img src="/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210402154047211.png" alt="image-20210402154047211"></p>
<p>配置完成之后，一旦GitHub仓库中的文件有更新，Docker Hub上的镜像构建就会自动触发（使用Webhooks），从而保证镜像始终都是最新的。</p>
<h2 id="私有仓库-docker-registry"><a href="#私有仓库-docker-registry" class="headerlink" title="私有仓库 docker-registry"></a>私有仓库 docker-registry</h2><p><font color="red">请使用 <code>Nexus3.x 的私有仓库</code> 。</font> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库（本地仓库）。本文内容基于 <a target="_blank" rel="noopener" href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p>
<h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>使用官方的 <code>registry</code> 镜像来启动私有仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 5000:5000 --restart=always --name registry registry</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下，可以通过 <code>-v</code> 参数来将仓库路径挂载到本地的 <code>/opt/data/registry</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d \</span></span><br><span class="line"><span class="language-bash">    -p 5000:5000 \</span></span><br><span class="line"><span class="language-bash">    -v /opt/data/registry:/var/lib/registry \</span></span><br><span class="line"><span class="language-bash">    registry</span></span><br></pre></td></tr></table></figure>

<h3 id="推送镜像到本地仓库"><a href="#推送镜像到本地仓库" class="headerlink" title="推送镜像到本地仓库"></a>推送镜像到本地仓库</h3><p>例如私有仓库地址为 <code>127.0.0.1:5000</code>，需先使用 <code>docker tag</code> 来标记一个镜像，然后就可以推送到仓库了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images -a</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu       latest    f643c72bc252   4 months ago   72.9MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest <span class="comment"># 将ubuntu:latest这个镜像标记为127.0.0.1:5000/ubuntu:latest</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span> -a</span></span><br><span class="line">REPOSITORY              TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu   latest    f643c72bc252   4 months ago   72.9MB</span><br><span class="line">ubuntu                  latest    f643c72bc252   4 months ago   72.9MB</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push 127.0.0.1:5000/ubuntu:latest <span class="comment"># 推送标记的镜像</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>{&quot;repositories&quot;:[&quot;ubuntu&quot;]}</code>，表明镜像已经被成功推送了。</p>
<h3 id="搜索本地仓库镜像"><a href="#搜索本地仓库镜像" class="headerlink" title="搜索本地仓库镜像"></a>搜索本地仓库镜像</h3><p>浏览器访问 <code>http://127.0.0.1:5000/v2/_catalog</code> 或使用命令 <code>curl</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:5000/v2/_catalog <span class="comment"># 查看仓库中的镜像</span></span></span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拉取本地仓库镜像"><a href="#拉取本地仓库镜像" class="headerlink" title="拉取本地仓库镜像"></a>拉取本地仓库镜像</h3><p>先删除已有镜像，再尝试从私有仓库中拉取这个镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker rmi 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull 127.0.0.1:5000/ubuntu:latest</span></span><br></pre></td></tr></table></figure>

<h3 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h3><p>若想让本网段的其他主机也能把镜像推送到私有仓库，就要使用例如 <code>172.27.13.27:5000</code> 这样的内网地址做为私有仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker tag nginx:latest 172.27.13.27:5000/nginx:latest</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push 172.27.13.27:5000/nginx:latest</span></span><br><span class="line">The push refers to repository [172.27.13.27:5000/nginx]</span><br><span class="line">Get https://172.27.13.27:5000/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure>

<p>会发现推送失败。这是因为 <font color="red">Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像</font>。可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://registry-1.docker.io&quot;,</span><br><span class="line">    &quot;https://dockerproxy.net&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot;: [</span><br><span class="line">    &quot;172.27.13.27:5000&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p>
</blockquote>
<p>然后重新启动服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p>检查是否生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker info <span class="comment"># 保证docker为启动状态</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结尾看到如下内容，说明配置成功。</span></span><br><span class="line"> Insecure Registries:</span><br><span class="line">  172.27.13.27:5000</span><br><span class="line">  127.0.0.0/8</span><br></pre></td></tr></table></figure>

<h2 id="私有仓库高级配置"><a href="#私有仓库高级配置" class="headerlink" title="私有仓库高级配置"></a>私有仓库高级配置</h2><p> <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/repository/registry_auth.md">https://github.com/yeasy/docker_practice/blob/master/repository/registry_auth.md</a> </p>
<h2 id="Nexus3-x-的私有仓库"><a href="#Nexus3-x-的私有仓库" class="headerlink" title="Nexus3.x 的私有仓库"></a>Nexus3.x 的私有仓库</h2><p> <a target="_blank" rel="noopener" href="https://www.sonatype.com/product/repository-oss">https://www.sonatype.com/product/repository-oss</a> </p>
<p>使用 Docker 官方的 Registry 创建的仓库面临一些<font color="red">维护问题</font>。比如<font color="red">某些镜像删除</font>以后空间默认不会回收，需要一些命令去回收空间然后重启 Registry。在企业中把内部的一些工具包放入 <code>Nexus</code> 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <a target="_blank" rel="noopener" href="https://www.sonatype.com/nexus/repository-oss-download"><code>Nexus3.x</code></a> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p>
<h3 id="启动-Nexus-容器"><a href="#启动-Nexus-容器" class="headerlink" title="启动 Nexus 容器"></a>启动 Nexus 容器</h3><p>参考 <a target="_blank" rel="noopener" href="https://hub.docker.com/r/sonatype/nexus3">https://hub.docker.com/r/sonatype/nexus3</a> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create --name nexus-data <span class="comment"># 创建一个数据卷，在 /var/lib/docker/volumes 下</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 8081:8081 -p 5001:5001 \</span></span><br><span class="line"><span class="language-bash">    --name nexus3 \</span></span><br><span class="line"><span class="language-bash">    -v nexus-data:/nexus-data \</span></span><br><span class="line"><span class="language-bash">    sonatype/nexus3</span></span><br></pre></td></tr></table></figure>

<p><strong>这里的 5001 端口映射出来供后面使用。</strong> </p>
<p>首次运行需等待 3-5 分钟。</p>
<p>查看滚动日志，输出以下内容表示启动成功，可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 <code>Nexus</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f nexus3</span></span><br><span class="line"></span><br><span class="line">2021-04-06 04:27:00,455+0000 INFO  [jetty-main-1] *SYSTEM org.sonatype.nexus.bootstrap.jetty.JettyServer -</span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">Started Sonatype Nexus OSS 3.29.2-02</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>获取初始密码 (默认帐号是 <code>admin</code> )，首次登录会提示更改初始密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> nexus3 <span class="built_in">cat</span> /nexus-data/admin.password</span></span><br></pre></td></tr></table></figure>

<p>登录后，点击页面上方的齿轮按钮 <img src="/article/2020/01/Docker%E6%95%99%E7%A8%8B/image-20210406135103964.png" alt="image-20210406135103964"> 按照下面的方法进行设置。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p>
<ul>
<li><strong>Name</strong>: 仓库的名称</li>
<li><strong>HTTP</strong>: 仓库单独的访问端口（例如：<strong>5001</strong>） <font color="red">记得添加端口映射</font> </li>
<li><strong>Hosted -&gt; Deployment pollcy</strong>: 请选择 <strong>Allow redeploy</strong> 否则无法上传 Docker 镜像。</li>
</ul>
<p>其它的仓库创建方法请各位自己摸索，还可以创建一个 <code>docker (proxy)</code> 类型的仓库链接到 DockerHub 上。再创建一个 <code>docker (group)</code> 类型的仓库把刚才的 <code>hosted</code> 与 <code>proxy</code> 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p>
<blockquote>
<p><font color style="background-color:#FFF333;">注意：这里的 5001 端口需要对外映射，否则后面无法使用 <code>docker login HostIP:5001</code> 登录，最简单的方式就是删除容器，重新启动一个。由于已经挂载了 <code>/nexus-data</code> 目录，所以一切设置都不会丢失。</font>更复杂操作参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kingsonfu/p/11578073.html">docker容器添加对外映射端口</a> 。</p>
</blockquote>
<h3 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h3><p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p>
<h3 id="添加角色"><a href="#添加角色" class="headerlink" title="添加角色"></a>添加角色</h3><p>菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p>
<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p>
<h3 id="NGINX-加密代理"><a href="#NGINX-加密代理" class="headerlink" title="NGINX 加密代理"></a>NGINX 加密代理</h3><p>证书的生成请参见 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/repository/registry_auth.md"><code>私有仓库高级配置</code></a> 里面证书生成一节。</p>
<p>NGINX 示例配置如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">upstream register</span><br><span class="line">&#123;</span><br><span class="line">    server &quot;YourHostName OR IP&quot;:5001; # 端口为上面添加私有镜像仓库时设置的 HTTP 选项的端口号</span><br><span class="line">    check interval=3000 rise=2 fall=10 timeout=1000 type=http;</span><br><span class="line">    check_http_send &quot;HEAD / HTTP/1.0\r\n\r\n&quot;;</span><br><span class="line">    check_http_expect_alive http_4xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    server_name YourDomainName; # 如果没有DNS服务器做解析，请删除此选项使用本机IP地址访问</span><br><span class="line">    listen       443 ssl;</span><br><span class="line"></span><br><span class="line">    ssl_certificate key/example.crt;</span><br><span class="line">    ssl_certificate_key key/example.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers   on;</span><br><span class="line">    large_client_header_buffers 4 32k;</span><br><span class="line">    client_max_body_size 300m;</span><br><span class="line">    client_body_buffer_size 512k;</span><br><span class="line">    proxy_connect_timeout 600;</span><br><span class="line">    proxy_read_timeout   600;</span><br><span class="line">    proxy_send_timeout   600;</span><br><span class="line">    proxy_buffer_size    128k;</span><br><span class="line">    proxy_buffers       4 64k;</span><br><span class="line">    proxy_busy_buffers_size 128k;</span><br><span class="line">    proxy_temp_file_write_size 512k;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_pass http://register;</span><br><span class="line">        proxy_read_timeout 900s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问镜像仓库"><a href="#访问镜像仓库" class="headerlink" title="访问镜像仓库"></a>访问镜像仓库</h3><p>如果不启用 SSL 加密可以通过 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/repository/registry.md">前面章节</a> 的方法添加非 https 仓库地址到 Docker 的配置文件中然后重启 Docker。</p>
<p>使用 SSL 加密以后程序需要访问就不能采用修改配置的方式了。具体方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl s_client -showcerts -connect YourDomainName OR HostIP:443 &lt;/dev/null 2&gt;/dev/null|openssl x509 -outform PEM &gt;ca.crt</span><br><span class="line">$ cat ca.crt | sudo tee -a /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker login YourDomainName OR HostIP</code> 进行测试，用户名密码填写上面 Nexus 中设置的。</p>
<h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p> <a target="_blank" rel="noopener" href="https://einverne.github.io/post/2018/03/docker-v-and-mount.html">docker volumes 中 -v 和 -mount 区别</a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/storage/volumes/">https://docs.docker.com/storage/volumes/</a> </p>
<p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
</ul>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是<font color="red">一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性</font>：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会<font color="red">复制到数据卷中</font>（仅数据卷为空时会复制）。</p>
</blockquote>
<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create my-vol</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span> <span class="comment"># 查看所有数据卷</span></span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     my-vol</span><br><span class="line">local     nexus-data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect my-vol <span class="comment"># 查看指定数据卷的信息</span></span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2021-04-06T16:10:26+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>用 <code>docker run</code> 命令时，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P \</span></span><br><span class="line"><span class="language-bash">    --name web \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># -v my-vol:/usr/share/nginx/html \</span></span></span><br><span class="line"><span class="language-bash">    --mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html \</span></span><br><span class="line"><span class="language-bash">    nginx:alpine</span></span><br></pre></td></tr></table></figure>

<h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect web</span></span><br></pre></td></tr></table></figure>

<p><code>数据卷</code> 的信息在 “Mounts” Key 下面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">rm</span> my-vol</span></span><br></pre></td></tr></table></figure>

<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker <font color="red">不会在容器被删除后自动删除 <code>数据卷</code></font>，并且也<font color="red">不存在垃圾回收这样的机制</font>来处理没有任何容器引用的 <code>数据卷</code>。如果需要在<font color="red">删除容器的同时移除数据卷，使用 <code>docker rm -v</code> 命令</font>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">rm</span> -fv web <span class="comment"># 本人测试无效</span></span></span><br></pre></td></tr></table></figure>

<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume prune</span></span><br></pre></td></tr></table></figure>

<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P \</span></span><br><span class="line"><span class="language-bash">    --name web \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html \</span></span></span><br><span class="line"><span class="language-bash">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \</span></span><br><span class="line"><span class="language-bash">    nginx:alpine</span></span><br></pre></td></tr></table></figure>

<p>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。</p>
<p><font color="red">本地目录的路径必须是绝对路径，使用 <code>-v</code> 参数时 Docker 会自动创建文件夹，使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</font> </p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>。用户可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P \</span></span><br><span class="line"><span class="language-bash">    --name web \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html:ro \ # ro是readonly简写</span></span></span><br><span class="line">    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \</span><br><span class="line">    nginx:alpine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这时如果在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误</span></span><br><span class="line">[root@1da1fc9f10f4 html]# pwd</span><br><span class="line">/usr/share/nginx/html</span><br><span class="line">[root@1da1fc9f10f4 html]# touch new.txt</span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></table></figure>

<h3 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect web</span></span><br></pre></td></tr></table></figure>

<p><code>挂载主机目录</code> 的信息在 “Mounts” Key 下面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/src/webapp&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> -it \</span></span><br><span class="line"><span class="language-bash">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span></span><br><span class="line"><span class="language-bash">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span></span><br><span class="line"><span class="language-bash">   ubuntu:18.04 \</span></span><br><span class="line"><span class="language-bash">   bash</span></span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/# history</span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure>

<p><font color="red">这样就可以记录容器输入过的命令了。</font> </p>
<h1 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>
<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。使用 <code>docker container ls</code> 可以看到随机端口。<code>docker logs</code> 查看访问记录。</p>
<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式将本地 80 端口映射到容器 80 端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 80:80 nginx:alpine</span></span><br></pre></td></tr></table></figure>

<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 127.0.0.1::80 nginx:alpine</span></span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span></span><br></pre></td></tr></table></figure>

<h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port fa 80</span></span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d \</span></span><br><span class="line"><span class="language-bash">    -p 80:80 \</span></span><br><span class="line"><span class="language-bash">    -p 443:443 \</span></span><br><span class="line"><span class="language-bash">    nginx:alpine</span></span><br></pre></td></tr></table></figure>

<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>如果有 <code>Docker</code> 使用经验，可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p>
<p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个新的 Docker 网络</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create -d bridge my-net</span></span><br></pre></td></tr></table></figure>

<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/swarm_mode">Swarm mode</a>，在本小节中可以忽略它。</p>
<h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> --name busybox1 --network my-net busybox sh</span></span><br></pre></td></tr></table></figure>

<p><font color="blue">打开新的终端</font>，再运行一个容器并加入到 <code>my-net</code> 网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> --name busybox2 --network my-net busybox sh</span></span><br></pre></td></tr></table></figure>

<p><font color="blue">再打开一个新的终端</font>查看容器信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">ls</span></span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             &quot;sh&quot;                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             &quot;sh&quot;                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure>

<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p>在 <code>busybox1</code> 容器输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping busybox2</span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</span><br></pre></td></tr></table></figure>

<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p>
<p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>如果有多个容器之间需要互相连接，推荐使用 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/compose">Docker Compose</a>。</p>
<h2 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？<font color="red">秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</font> </p>
<p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">/dev/sda1 on /etc/resolv.conf type ext3 (rw,seclabel,relatime,data=ordered)</span><br><span class="line">/dev/sda1 on /etc/hostname type ext3 (rw,seclabel,relatime,data=ordered)</span><br><span class="line">/dev/sda1 on /etc/hosts type ext3 (rw,seclabel,relatime,data=ordered)</span><br></pre></td></tr></table></figure>

<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p>
<p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;114.114.115.115&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>114.114.115.115</code>。使用以下命令来证明其已经生效。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> ubuntu:18.04  <span class="built_in">cat</span> etc/resolv.conf</span></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>

<p><font color="red" size="4"><strong>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</strong></font> </p>
<p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p>
<p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p>
<p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p>
<blockquote>
<p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p>
</blockquote>
<h1 id="高级网络配置"><a href="#高级网络配置" class="headerlink" title="高级网络配置"></a>高级网络配置</h1><blockquote>
<p>注意：本章属于 <code>Docker</code> 高级配置，初学者可以暂时跳过本章节，直接学习 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/compose">Docker Compose</a> 一节。</p>
</blockquote>
<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc1918">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口，一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="/article/2020/01/Docker%E6%95%99%E7%A8%8B/network.png" alt="Docker 网络"></p>
<p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置，以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p>
<h2 id="快速配置指南"><a href="#快速配置指南" class="headerlink" title="快速配置指南"></a>快速配置指南</h2><p>下面是一个跟 Docker 网络相关的命令列表。</p>
<p>其中有些命令选项只有在 Docker 服务（即<font color="red"> <code>dockerd --help</code> </font>）启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> 定制 docker0 的掩码</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> Docker 服务端接收命令的通道</li>
<li><code>--icc=true|false</code> 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> 是否允许 Docker 添加 iptables 规则</li>
<li><code>--mtu=BYTES</code> 容器网络中的 MTU</li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务（即<font color="red"> <code>dockerd --help</code> </font>）启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li>
</ul>
<p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li>
<li><code>-p SPEC</code> 或 <code>--publish=SPEC</code> 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li>
</ul>
<h2 id="容器访问控制"><a href="#容器访问控制" class="headerlink" title="容器访问控制"></a>容器访问控制</h2><p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>

<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sysctl -w net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure>

<p>如果在启动 Docker 服务（即<font color="red"> <code>dockerd --help</code> </font>）的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
<h3 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h3><p>容器之间相互访问，需要两方面的支持。</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li>
<li>本地系统的防火墙软件 – <code>iptables</code> 是否允许通过。</li>
</ul>
<h4 id="访问所有端口"><a href="#访问所有端口" class="headerlink" title="访问所有端口"></a>访问所有端口</h4><p>当启动 Docker 服务（即<font color="red"> <code>dockerd --help</code> </font>）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，<font color="red" style="background-color:#FFF333;">默认情况下，不同容器之间是允许网络互通的。</font>如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{&quot;icc&quot;: false}</code> 来禁止它。</p>
<h4 id="访问指定端口"><a href="#访问指定端口" class="headerlink" title="访问指定端口"></a>访问指定端口</h4><p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务（即<font color="red"> <code>dockerd --help</code> </font>）时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>此时，系统中的 <code>iptables</code> 规则可能是类似</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iptables -nL</span></span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p>
<p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iptables -nL</span></span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80</span><br><span class="line">ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p><font color="red" style="background-color:#FFF333;">注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</font> </p>
<h2 id="映射容器端口到宿主主机的实现"><a href="#映射容器端口到宿主主机的实现" class="headerlink" title="映射容器端口到宿主主机的实现"></a>映射容器端口到宿主主机的实现</h2><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h3 id="容器访问外部实现"><a href="#容器访问外部实现" class="headerlink" title="容器访问外部实现"></a>容器访问外部实现</h3><p><strong>容器所有到外部网络的连接，源地址都会被 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">NAT</a> 成本地系统的 IP 地址</strong>。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iptables -t nat -nL</span></span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，<strong>上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。</strong> </p>
<p><strong>MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</strong> </p>
<h3 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h3><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p>
<p>使用 <code>-P</code> 时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -nL</span></span><br><span class="line">...</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>

<p>使用 <code>-p 80:80</code> 时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -nL</span></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这里的规则映射了 <code>0.0.0.0</code>，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</li>
<li><font color="red">如果希望永久绑定到某个固定的 IP 地址</font>，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;ip&quot;: &quot;0.0.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置-docker0-网桥"><a href="#配置-docker0-网桥" class="headerlink" title="配置 docker0 网桥"></a>配置 docker0 网桥</h2><p>Docker 服务（即<font color="red"> <code>dockerd --help</code> </font>）默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址和子网掩码，让<font color="red">主机和容器之间可以通过网桥相互通信</font>，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes（或宿主主机网络路由上支持的默认值）。这些值都可以在服务启动的时候进行配置。</p>
<ul>
<li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5&#x2F;24</li>
<li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li>
</ul>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p>
<p><font color="red">由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</font> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.02428680967e       no              veth7a59900</span><br><span class="line">                                                        veth7bd0625</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color="red" style="background-color:#FFF333;">注：<code>brctl</code> 命令需要安装网桥管理工具包 bridge-utils，Debian、Ubuntu 使用 <code>sudo apt-get install bridge-utils</code> 来安装，Red Hat、CentOS 使用 <code>yum install bridge-utils -y</code>。</font> </p>
</blockquote>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -dit --name centos centos:centos8</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it centos bash</span></span><br><span class="line">[root@32bdc88226eb /]# ip addr show eth0</span><br><span class="line">27: eth0@if28: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:05 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.5/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@32bdc88226eb /]# ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">27: eth0@if28: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:05 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.5/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@32bdc88226eb /]# ip route</span><br><span class="line">default via 172.17.0.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.5</span><br></pre></td></tr></table></figure>

<h2 id="自定义网桥"><a href="#自定义网桥" class="headerlink" title="自定义网桥"></a>自定义网桥</h2><p> <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-ip.html">Linux ip 命令 - 菜鸟教程</a> </p>
<p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务（即<font color="red"> <code>dockerd --help</code> </font>）的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl stop docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 down</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl delbr docker0</span></span><br></pre></td></tr></table></figure>

<p>然后创建一个网桥 <code>bridge0</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addbr bridge0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr add 192.168.5.1/24 dev bridge0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev bridge0 up</span></span><br></pre></td></tr></table></figure>

<p>查看确认网桥创建并启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip addr show bridge0</span></span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bridge&quot;: &quot;bridge0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重新启动 Docker 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p>
<p>在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>系统重启网桥 <code>bridge0</code> 就不存在了，导致docker服务无法启动。如何持久化网桥？</p>
<h2 id="编辑网络配置文件"><a href="#编辑网络配置文件" class="headerlink" title="编辑网络配置文件"></a>编辑网络配置文件</h2><p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p>
<p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p>
<h2 id="创建一个点到点连接"><a href="#创建一个点到点连接" class="headerlink" title="创建一个点到点连接"></a><a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/advanced_network/ptp.md">创建一个点到点连接</a></h2><p>…</p>
<h1 id="Docker-Buildx"><a href="#Docker-Buildx" class="headerlink" title="Docker Buildx"></a>Docker Buildx</h1><p> <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/buildx/README.md">https://github.com/yeasy/docker_practice/blob/master/buildx/README.md</a> </p>
<p>Docker Buildx 是一个 docker CLI 插件，其扩展了 docker 命令，支持 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/buildx/buildkit.md">Moby BuildKit</a> 提供的功能。提供了与 docker build 相同的用户体验，并增加了许多新功能。</p>
<blockquote>
<p>该功能仅适用于 Docker v19.03+ 版本</p>
</blockquote>
<h1 id="Docker-Compose-1"><a href="#Docker-Compose-1" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p>
<h2 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h2><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a target="_blank" rel="noopener" href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p><strong>对于 Docker Engine、Docker Compose、Compose file 三者的版本关系有点模糊。</strong> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/release-notes/">https://docs.docker.com/engine/release-notes/</a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/compose/release-notes/">https://docs.docker.com/compose/release-notes/</a> </p>
<p><strong>Compose file format</strong> 版本和 <strong>Docker Engine</strong> 版本对应关系：</p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/compose-versioning/">https://docs.docker.com/compose/compose-file/compose-versioning/</a> </p>
<h2 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h2><p><code>Compose</code> 支持 Linux、macOS、Windows 10 三大平台。</p>
<p><code>Compose</code> 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p>
<p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose --version</span></span><br><span class="line">docker-compose version 1.27.4, build 40524192</span><br></pre></td></tr></table></figure>

<p>Linux 系统请使用以下介绍的方法安装。</p>
<h3 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h3><p>在 Linux 上的也安装十分简单，从 <a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> curl -L https://github.com/docker/compose/releases/download/<span class="variable">$&#123;version&#125;</span>/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">国内用户可以使用以下方式加快下载</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> curl -L https://download.fastgit.org/docker/compose/releases/download/<span class="variable">$&#123;version&#125;</span>/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure>

<h3 id="PIP-安装"><a href="#PIP-安装" class="headerlink" title="PIP 安装"></a>PIP 安装</h3><p><em>注：</em> <code>x86_64</code> 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 <code>ARM</code> (例如，树莓派)，再使用 <code>pip</code> 安装。</p>
<p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p>
<p>执行安装命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> pip install -U docker-compose</span></span><br></pre></td></tr></table></figure>

<p>可以看到类似如下输出，说明安装成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting docker-compose</span><br><span class="line">  Downloading docker-compose-1.27.4.tar.gz (149kB): 149kB downloaded</span><br><span class="line">...</span><br><span class="line">Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</span><br></pre></td></tr></table></figure>

<h3 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -L https://raw.githubusercontent.com/docker/compose/1.27.4/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span></span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">rm</span> /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure>

<p>如果是通过 <code>pip</code> 安装的，则执行如下命令即可删除。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> pip uninstall docker-compose</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>首先介绍几个术语。</p>
<ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<h4 id="web-应用"><a href="#web-应用" class="headerlink" title="web 应用"></a>web 应用</h4><p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=&#x27;redis&#x27;, port=6379)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    count = redis.incr(&#x27;hits&#x27;)</span><br><span class="line">    return &#x27;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#x27;.format(count)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, debug=True)</span><br></pre></td></tr></table></figure>

<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>编写 <code>Dockerfile</code> 文件，内容为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;5000:5000&quot;</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br></pre></td></tr></table></figure>

<h4 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose up</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose up -d <span class="comment"># 后台运行</span></span></span><br></pre></td></tr></table></figure>

<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h2 id="Compose-命令说明"><a href="#Compose-命令说明" class="headerlink" title="Compose 命令说明"></a>Compose 命令说明</h2><h3 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h3><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>

<h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><ul>
<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
<h3 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h3><h4 id="help"><a href="#help" class="headerlink" title="help"></a><code>help</code></h4><p>获得一个命令的帮助。</p>
<h4 id="version"><a href="#version" class="headerlink" title="version"></a><code>version</code></h4><p>格式为 <code>docker-compose version</code>。</p>
<p>打印版本信息。</p>
<h4 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li><code>--force-rm</code> 删除构建过程中的临时容器。</li>
<li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li>
</ul>
<h4 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h4><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<h4 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h4><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络。</p>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h4><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 后台运行容器。</li>
<li><code>--name NAME</code> 为容器指定一个名字。</li>
<li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li>
<li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li>
<li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li>
<li><code>--no-deps</code> 不自动启动关联的服务容器。</li>
<li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li>
<li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li>
<li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li>
<li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose run ubuntu ping docker.com</span></span><br></pre></td></tr></table></figure>

<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>给定命令将会覆盖原有的自动运行命令；</li>
<li>不会自动创建端口，以避免冲突。</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose run --no-deps web python manage.py shell <span class="comment"># 将不会启动web容器所关联的其它容器</span></span></span><br></pre></td></tr></table></figure>

<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h4><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h4><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h4><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h4><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h4><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose <span class="built_in">kill</span> -s SIGINT</span></span><br></pre></td></tr></table></figure>

<h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a><code>pause</code></h4><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<h4 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h4><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a><code>pull</code></h4><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h4><p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h4><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<h4 id="images"><a href="#images" class="headerlink" title="images"></a><code>images</code></h4><p>列出 Compose 文件中包含的镜像。</p>
<h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a><code>logs</code></h4><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<h4 id="port"><a href="#port" class="headerlink" title="port"></a><code>port</code></h4><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose port web 5000 <span class="comment"># 打印web服务5000端口所映射的公共端口</span></span></span><br><span class="line">0.0.0.0:5000</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li>
</ul>
<h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a><code>scale</code></h4><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 <code>service=num</code> 的参数来设置数量。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose scale web=3 db=2</span></span><br></pre></td></tr></table></figure>

<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h4><p>查看各个服务容器内运行的进程。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h4><p>进入指定的容器。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/reference/overview/">官方文档</a></li>
</ul>
<h2 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h2><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/data&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a><code>build</code></h3><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>或</strong></font> </p>
<p>使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径；</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名；</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量；</p>
<p>使用 <code>cache_from</code> 指定构建镜像的缓存；</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">cache_from:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure>

<h3 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a><code>cap_add, cap_drop</code></h3><p>参考： <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities</a> </p>
<p>指定容器的内核能力（capacity）分配。</p>
<p>例如，让容器拥有所有能力可以指定为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure>

<p>去掉 NET_ADMIN 能力可以指定为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br></pre></td></tr></table></figure>

<h3 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h3><p>覆盖容器启动后默认执行的命令。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a><code>configs</code></h3><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/swarm_mode"><code>Swarm mode</code></a> 一节。</p>
<h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a><code>cgroup_parent</code></h3><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p>
<p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure>

<h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h3><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color="red" style="background-color:#FFF333;">注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</font> </p>
</blockquote>
<h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h3><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/swarm_mode"><code>Swarm mode</code></a> 一节</p>
<h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a><code>devices</code></h3><p>指定设备映射关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span><br></pre></td></tr></table></figure>

<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h3><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> 、<code>db</code> 再启动 <code>web</code> </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color="red" style="background-color:#FFF333;">注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</font> </p>
</blockquote>
<h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a><code>dns</code></h3><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure>

<h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a><code>dns_search</code></h3><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain1.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure>

<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a><code>tmpfs</code></h3><p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Tmpfs">tmpfs -维基百科</a> </p>
<p>挂载一个 tmpfs 文件系统到容器。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/run</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure>

<h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env_file:</span> <span class="string">.env</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env_file:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./common.env</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./apps/web.env</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/opt/secrets.env</span></span><br></pre></td></tr></table></figure>

<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line"><span class="string">PROG_ENV=development</span></span><br></pre></td></tr></table></figure>

<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h3><p>设置环境变量。可以使用数组或字典两种格式。</p>
<p><strong>只给定名称的变量</strong>会自动获取运行 Compose 主机上对应变量的值，<strong>可以用来防止泄露不必要的数据</strong>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a target="_blank" rel="noopener" href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span></span><br></pre></td></tr></table></figure>

<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a><code>expose</code></h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a><code>external_links</code></h3><blockquote>
<p>注意：不建议使用该指令。</p>
</blockquote>
<p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis_1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:postgresql</span></span><br></pre></td></tr></table></figure>

<h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a><code>extra_hosts</code></h3><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;googledns:8.8.8.8&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;dockerhub:52.1.157.61&quot;</span></span><br></pre></td></tr></table></figure>

<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> <span class="string">googledns</span></span><br><span class="line"><span class="number">52.1</span><span class="number">.157</span><span class="number">.61</span> <span class="string">dockerhub</span></span><br></pre></td></tr></table></figure>

<h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h3><p>通过命令检查容器是否健康运行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure>

<h3 id="labels"><a href="#labels" class="headerlink" title="labels"></a><code>labels</code></h3><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">com.startupteam.description:</span> <span class="string">&quot;webapp for a startup team&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.department:</span> <span class="string">&quot;devops department&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.release:</span> <span class="string">&quot;rc3 for v1.0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="links"><a href="#links" class="headerlink" title="links"></a><code>links</code></h3><blockquote>
<p>注意：不推荐使用该指令。</p>
</blockquote>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a><code>logging</code></h3><p>配置日志选项。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">syslog</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">syslog-address:</span> <span class="string">&quot;tcp://192.168.0.42:123&quot;</span></span><br></pre></td></tr></table></figure>

<p>目前支持三种日志驱动类型。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;syslog&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>options</code> 配置日志驱动的相关参数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">max-size:</span> <span class="string">&quot;200k&quot;</span></span><br><span class="line">  <span class="attr">max-file:</span> <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a><code>network_mode</code></h3><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h3><p>配置容器连接的网络。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure>

<h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h3><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">&quot;host&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h3><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br></pre></td></tr></table></figure>

<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a><code>secrets</code></h3><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line">  <span class="attr">secrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line">  <span class="attr">my_other_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a><code>security_opt</code></h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:user:USER</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:role:ROLE</span></span><br></pre></td></tr></table></figure>

<h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a><code>stop_signal</code></h3><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure>

<h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h3><p>配置容器内核参数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure>

<h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h3><p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure>

<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h3><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST路径:CONTAINER路径</code>)或者数据卷名称(<code>VOLUME名称:CONTAINER路径</code>)，并且可以设置访问模式 （<code>HOST路径:CONTAINER路径:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure>

<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span> <span class="comment"># VOLUME名称:CONTAINER路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure>

<h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure>

<p>指定容器中运行应用的用户名。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>指定容器中工作目录。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">working_dir:</span> <span class="string">/code</span></span><br></pre></td></tr></table></figure>

<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="number">-00</span><span class="number">-27</span><span class="number">-00</span><span class="string">-0C-0A</span></span><br></pre></td></tr></table></figure>

<p>允许容器中运行一些特权命令。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/taiyangdao/article/details/73076019">Docker容器的重启策略及docker run的–restart选项详解</a> </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>打开标准输入，可以接受外部输入。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stdin_open:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>模拟一个伪终端。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">&quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line"><span class="string">MONGO_VERSION=3.6</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker/awesome-compose">awesome-compose</a></li>
</ul>
<h1 id="Docker-Compose环境变量"><a href="#Docker-Compose环境变量" class="headerlink" title="Docker Compose环境变量"></a>Docker Compose环境变量</h1><p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9826520.html">Docker Compose 引用环境变量</a> </p>
<h1 id="Docker-Compose实战"><a href="#Docker-Compose实战" class="headerlink" title="Docker Compose实战"></a>Docker Compose实战</h1><p>一条命令拉起所有中间件：</p>
<p> <a href="/resource/file/middleware.tar.gz">middleware.tar.gz</a> </p>
<p><font color="red"><strong>踩坑：</strong></font> </p>
<p>nacos集群启动依赖了mysql服务，但mysql第一次启动时慢，nacos启动快，所以nacos无法连接mysql，导致nacos无法访问。<br>解决办法：<br>    1、执行两次 docker-compose up -d ，第二次mysql启动就快了。<br>    2、参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang_yb/p/9400291.html">docker compose 服务启动顺序控制</a> 。</p>
<h1 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h1><p><strong>推荐连接：</strong> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/machine/">https://docs.docker.com/machine/</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-machine.html">https://www.runoob.com/docker/docker-machine.html</a> </p>
<p> <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/machine/README.md">https://github.com/yeasy/docker_practice/blob/master/machine/README.md</a> </p>
<p><strong>配置 Docker 主机支持远程访问，以供管理主机使用 <code>docker Machine</code> 命令管理：</strong> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/linux-postinstall/#configure-where-the-docker-daemon-listens-for-connections">https://docs.docker.com/engine/install/linux-postinstall/#configure-where-the-docker-daemon-listens-for-connections</a> </p>
<p><strong>选择合适的 Machine 驱动程序创建 Docker 主机实例：</strong> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/machine/drivers/">https://docs.docker.com/machine/drivers/</a> </p>
<p> <a target="_blank" rel="noopener" href="https://docs.docker.com/machine/drivers/generic/">https://docs.docker.com/machine/drivers/generic/</a> </p>
<h1 id="Swarm-mode"><a href="#Swarm-mode" class="headerlink" title="Swarm mode"></a>Swarm mode</h1><p> <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/swarm/">https://docs.docker.com/engine/swarm/</a> </p>
<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-swarm.html">https://www.runoob.com/docker/docker-swarm.html</a> </p>
<p> <a target="_blank" rel="noopener" href="https://github.com/yeasy/docker_practice/blob/master/swarm_mode/README.md">https://github.com/yeasy/docker_practice/blob/master/swarm_mode/README.md</a> </p>
<p>Docker 1.12 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/swarm/">Swarm mode</a> 已经内嵌入 Docker 引擎，成为了 docker 子命令 <code>docker swarm</code>。请注意与旧的 <code>Docker Swarm</code> 区分开来。</p>
<p><code>Swarm mode</code> 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。<font color="red">使得 Docker 原生的 <code>Swarm</code> 集群具备与 Mesos、Kubernetes 竞争的实力。</font> </p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="zhaolq 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="zhaolq 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/2020/01/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE(HTTP)/" rel="prev" title="超文本传输协议(HTTP)">
                  <i class="fa fa-angle-left"></i> 超文本传输协议(HTTP)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/2020/02/DBMS%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" rel="next" title="DBMS中的并发控制">
                  DBMS中的并发控制 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhaolq</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
